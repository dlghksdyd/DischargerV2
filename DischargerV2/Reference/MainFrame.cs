// ------------------------------------------------------
// 23.08.18 모든 float를 double로 변경 : BGH
// ------------------------------------------------------
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;
using System.IO;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;
using System.Diagnostics;
using System.Runtime.InteropServices;

using MinTech.ABTClass;     // ghbaik
using Multimedia;           // ghbaik

using System.Data;
using Peak.Can.Basic;

// 231124
using sysTimer = System.Threading.Timer;
using sysTimeout = System.Threading.Timeout;

//+ Add by LBG - 240523 : 통합관리시스템 연동 기능 추가
using ABT.PUSHER;
using System.Text;
using ABT.Forms;
//-

namespace ABT
{
    public partial class Mainframe : Form
    {
        [StructLayout(LayoutKind.Explicit)]
        public struct TwoByte
        {

            [FieldOffset(0)]
            public Int16 s16data;
            [FieldOffset(0)]
            public UInt16 u16data;
            [FieldOffset(0)]
            public byte b1;
            [FieldOffset(1)]
            public byte b2;

            public void Reset()
            {
                u16data = 0;
            }
        };

        // ---------------------------------------------------------
        // 전압값 라운드 처리
        // ---------------------------------------------------------
        string Volt_Number_Digit = "F3";
        //double m_roundvalue = 0.0005;

        //+ Add by YMJ - 240530 : 채널정보 UI에 온도 출력을 위해 어떤 디바이스에서 온도를 가져올지 설정 추가(기본 MBT)
        string m_temp_Collect_dev = "MBT";
        //-

		//+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
        public bool m_bParallel_Use;

        // 묶는 채널 수
        public int m_bParallel_Ch_Num = 2;
        //-

        //+ Add by YMJ - 250819 : 자동병렬 기능 플래그 추가
        public bool m_bParallel_Auto;
        //-

        // ---------------------------------------
        // Logging
        // 230911 BGH
        // 231126, delta logging 처리 대폭 수정
        // 이유 : 기존 처리가 잘못되어 있음.
        // ---------------------------------------
        // private int log_intv_count = 5;  // 1~10
        double[] log_volt_delta = new double[1];  // 전압변위
        double[] log_curr_delta = new double[1];  // 전류변위
        double[] log_temp_delta = new double[1];  // 온도변위
        double[] log_volt_backup = new double[1];  // 전압변위
        double[] log_curr_backup = new double[1];  // 전류변위
        double[] log_temp_backup = new double[1];  // 온도변위

        // --------------------------------
        // 전류 0A 실제값 로깅
        // --------------------------------
        private bool m_enable_real_rest_current_logging = false;


        // ------------------------------------
        // 전류 Range에 따른 Match-up 체크
        // 2023.08.29, BGH
        // ------------------------------------
        // List<double> m_CurrentRange = null;

        // -----------------------------------
        // + Added by BGH
        // -----------------------------------
        List<Alarm_Info> m_AlarmPopupList = new List<Alarm_Info>();
        //public bool isAlarmWindowPopup = false;  // Alarm창이 활성화 상태인지, Close인지.

        //+ Add by LBG - 231011 : Alarm List 접근 용 Get 생성
        public List<Alarm_Info> Get_Alram_List
        {
            get
            {
                return m_AlarmPopupList;
            }
        }
        //-

        // -----------------------------------
        // 230920, BGH
        // -----------------------------------
        private const int m_AlarmTypesNumber = 3;
        // ----        
        private const int Idx_OverCurr = 0;
        private const int Idx_UnderCurr = 1;
        private const int Idx_NoCurrent = 2;
        
        // ----
        private byte[,] m_AlarmRetryCount;
        // ----
        // 공정중이 아닐때도 전압 Safety 검사 기능
        // ----
        private double m_VsafetyOver = -1;
        private double m_VsafetyUnder = -1;


        // -----------------------------------
        //
        // -----------------------------------
        private byte[] balancingActivated;
        private double[] AUX_V_diff;
        private double[] AUX_V_min;
        private double[] AUX_V_max;
        //+ Revision by YMJ - 231124 : 기존 DAU Min, Max, Diff 구하는 구문 주석처리
        //private double[] DAU_V_diff;
        //private double[] DAU_V_min;
        //private double[] DAU_V_max;
        //-
        private double[] BMS_V_diff;
        private double[] BMS_V_min;
        private double[] BMS_V_max;
        private double[] MBI_V_diff;
        private double[] MBI_V_min;
        private double[] MBI_V_max;
        // -----------------------------------
        // 온도추가
        // -----------------------------------
        //private double[] AUX_T_diff;
        //private double[] AUX_T_min;
        //private double[] AUX_T_max;
        //private double[] DAU_T_diff;
        //private double[] DAU_T_min;
        //private double[] DAU_T_max;
        //private double[] BMS_T_diff;
        //private double[] BMS_T_min;
        //private double[] BMS_T_max;

        private byte[] logopt = new byte[1];

        bool[] m_ChamberReact = new bool[1];

        private int cyclog_intv = 1000; // x 1000ms

        //public double[] mPV_Limit;
        // public byte[] ChamberDirection;  // 0:Stay, 1 : UP(SP > PV), 2 : Down(SP < PV)
        public double mPV_Limit;
        public byte ChamberDirection;  // 0:Stay, 1 : UP(SP > PV), 2 : Down(SP < PV)

        //+ Add by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        public double m_H_PV;
        //-

        // frmRecipe n_frmRecipe = null;
        bool tos_activation = true;  // TOS 연계 여부 (LGES 전용)
        bool tos_iswritting = false;

        bool m_newtype_cycler = false;

        //+ Add by LBG - 230330 : 언어 정의 위치 변경 (clsDefine Class로 이동)
        //public enum LanguageType { KOREAN = 0, ENGLISH = 1, CHINESE = 2 };
        //-
        private LanguageType m_SysLanguage = LanguageType.KOREAN;
        public LanguageType SystemLanguage
        {
            get { return m_SysLanguage; }
            set { m_SysLanguage = value; }
        }

        // -----
        //
        // -----
        public bool m_isMBTKONA = false;
        //+ Add By YMJ - 240617 : MBT Retry 여부 플래그 설정 값 추가
        public bool m_retryMBT = false;
        //-
        // -----
        //
        // -----
        public bool DUPExecution = false;

        // -------------------------------------
        // CCCV, 설정 전압이 배터리 전압보다 충전때 낮거나, 방전때 높은 경우
        // Defauilt : false - skip (Cutoff by Voltage)
        //            true  - alarm 발생
        // --------------------------------------
        public bool CCCV_V_DoAlarm = false;

        // -------------------------------------
        //
        // -------------------------------------
        public bool enableCVTimelogging = true;


        // -----
        // AUX
        // -----
        //int m_AUX_ChCnt = 2;
        //public int AUX_Ch_Count

        //{
        //    get { return m_AUX_ChCnt; }
        //    set
        //    {
        //        m_AUX_ChCnt = value;
        //        ChStartNo = new int[value];
        //    }
        //}
        //int[] ChStartNo = new int[4] { 0, 0, 0, 0 };

        // -------------------------
        //
        // -------------------------
        public int[] m_AuxEndStepNumber;

        // -------------------
        // ghbaik
        // 선택된 채널 Index 배열
        // -------------------
        public int[] m_SelCh4Schedule;

        // ----------------------------
        //
        // ----------------------------
        public int[] m_error = new int[1] { 0 };


        // ghbaik
        //public int[] m_totloop_count = new int[1] { 1 };
        //public int[] m_curloop_number = new int[1] { 0 };

        // ghbaik
        public string[] work_names = new string[1];
        public string[] sche_names = new string[1];
        public string[] sche_names_restart = new string[1];

        //+ Add by LBG - 230308 : 작업 로그명 설정 기능 추가
        //public struct LOG_OPT_SET
        //{
        //    public bool Chk_Work;
        //    public bool Chk_File;
        //    public bool Chk_Time;

        //    public string Log_File;

        //    public void Init_Set()
        //    {
        //        Chk_Work = false;
        //        Chk_File = false;
        //        Chk_Time = false;

        //        Log_File = string.Empty;
        //    }
        //}

        //public bool[] m_Log_Opt_Chk_Work = new bool[1];
        //public bool[] m_Log_Opt_Chk_File = new bool[1];
        //public bool[] m_Log_Opt_Chk_Time = new bool[1];
        public string[] m_Log_Opt_File = new string[1];
        //-

        //+ Add by LBG : 작업 시작 시 Recipe 파일 복사를 위해 해당 파일 경로 미리 저장
        public string[] Recipe_Files = new string[1];

        // ghbaik
        public byte[] typelistacir = new byte[1];  // 0 : Not used, 1 : MBT, 2 : MCZ

        // ghbaik
        public enum ACIR_TYPE { MBT = 0, MCZ = 1 };

        // --------------------------
        // ghbaik
        // ---------------------
        // true : Testing, false:idling
        // --------------------------
        public bool[] IsOnTesting = new bool[1];
        public byte[] IsNoVoltAmp = null;
        public byte[] IsActivateEnding = new byte[1];

        public byte[] doPatternLog = new byte[1];  // 패턴 데이터 Rising 체크

        // -----------------------------------
        // Log
        // -----------------------------------
        public StreamWriter logSystem = null;
        private int m_days = 0;

        public StreamWriter[] logReg = new StreamWriter[1];
        //+ Add by LBG - 230912 : Basic Log 작성 중인 파일의 경로를 담는 변수 추가
        public Dictionary<int, string> m_dicBasicLog_Path;
        public Dictionary<int, string> m_dicBasicLog_Header;
        //-
        public int[] logCond = null;
        public int[] logBuff = null;
        //+ Add by YMJ - 240823 : 패턴 일시 정지 로깅 tick 카운트를 위한 Buff 선언
        public int[] patternBuff = null;
        //-
        public StreamWriter[] logStepRes = new StreamWriter[1];
        public StreamWriter[] logCycler = new StreamWriter[1];
        public StreamWriter[] logCyclerRes = new StreamWriter[1];
        public StreamWriter logAlarm = null;

        FileStream[] cfile = null;
        string[] logCyclerPath = null;

        //+ Add by YMJ - 250410 : 데이터 저장 경로 처리
        string m_DataFilePath = null;
        //-

        // ----------------------------------------------------
        //
        // ----------------------------------------------------  
        List<string> m_syslog_list = new List<string>();

        // --------------------------
        // ghbaik
        // --------------------------
        private const int OK = 0;
        private const int NG = -1;
        private const int DISABLED = -1;

        // ---------------------------------
        // REST Option
        //     false - CC 0 A 
        //     true - Standby
        // +
        // ---------------------------------
        public bool m_RestOptionStandby = false;
        public bool m_currautocal = true;
        public bool m_cccv_retouch = true;

        public clsAppSetting m_clsAppSet;
        public clsSystem_Link m_clsSys_Link;
        //+ Revision by KGY -20241209 : DAU Setting 추가
        public clsSystem_Setting m_clsSys_Set;
        public frmDAU_Set m_frmDAU_Set;
        //-
        public ucBoard_Status m_ucBoard_Status;
        public ucChannel_Status m_ucChannel_Status;

        List<cls_devCyclerABT> m_ucCycler_ABT_List = new List<cls_devCyclerABT>(); // null;
        List<cls_stepInfo> m_ucStepInfo_List = new List<cls_stepInfo>(); // null;
        List<cls_devMBT> m_ucMbT_List = new List<cls_devMBT>(); // null;
        // ----------
        // ghbaik
        // ----------
        //+ Revisioin by YMJ - 250213 : MxZ class 변경
        List<cls_devMxZ> m_ucMcz_List = new List<cls_devMxZ>(); // null;
        //-
        List<cls_devDAQDMM> m_ucDAQ_List = new List<cls_devDAQDMM>(); // null;
        List<cls_udds> m_ucUDDS_List = new List<cls_udds>(); // null;
        List<cls_devBalancing> m_ucBalancer_List = new List<cls_devBalancing>(); // null;

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        public cls_devChamber m_ucChamber = new cls_devChamber();
        //+ Revision by LBG - 241104 : Chiller가 멀티 채널이여서 변경
        //cls_devChiller_Temp2520 m_ucChiller = new cls_devChiller_Temp2520();  // 241028, BGH
        bool m_bChiller_Use = false;
        int m_bChiller_Cnt = 0;
        Dictionary<int, cls_devChiller> m_ucChiller = new Dictionary<int, cls_devChiller>();
        //-
        //-

        cls_devDIO_I7055 m_ucChamberDIO;
                
        cls_devPowerSupply_PT m_ucPowerSupply_PT = new cls_devPowerSupply_PT();
        // ----------------------------
        // + BGH
        // ----------------------------
        public bool m_BalancingEnable = false;
        public bool m_powersupply = false;

        // --------------------------------------
        // 231103 BGH
        // --------------------------------------
        public bool m_MCZEnable = false;

        // ----------------------------
        // + MTVD 관련 객체 List
        // ----------------------------
        List<cls_devLeakingSocket> m_ucTVocSOCList;
        //+ Revisioin by LBG - 240520 : MTVD v2로 변경하여 해당 제어 Class 추가
        cls_devMTVD_V2 m_cls_devMTVD_V2;
        //-
        public bool m_tVOCEnable = false;
        public int m_NumOftVOC = 0;

        //+ Add by LBG - 240513 : MTVD 관련 접속 정보 추가
        public int m_iMTVD_Type = -1;
        public uint m_tVOC_Chk_Val = 0;
        public List<string> m_tVOC_Addr = new List<string>();
        public List<int> m_tVOC_Port    = new List<int>();
        //-

        // -----------------------
        // AUX
        // -----------------------
        //public enum AUX_TYPE { NONE = -1, MT_DAU = 0, M_7017, BOTH };
        //public enum AUX_TYPE { NONE = 0, MT_DAU = 1, M_7017 = 2, BOTH = 3, IONIQ5 = 4 };
        //public AUX_TYPE[] m_AUX_Type;
        //public AUX_TYPE[] m_DAU_Type;
        //public AUX_TYPE[] m_BMS_Type;

        public bool m_AUXEnable = false;

        List<cls_devAUX_M7019> m_ucAUX7019_List = new List<cls_devAUX_M7019>();  // null
        public int m_NumOfAUX = 0;
        public double[,] m_AUX_Volt;  // [List Index, #AUX]
        public double[,] m_AUX_Temp;  // [List Index, #AUX]
        //public int[] m_unitpermodule;
        public int[] m_voltcount_aux;   // m_AUXValue 배열에서 전압의 시작 위치
        public int[] m_tempcount_aux;   // m_AUXValue 배열에서 온도의 시작 위치
        //public int[] m_voltpos;   // m_AUXValue 배열에서 전압의 시작 위치
        //public int[] m_temppos;   // m_AUXValue 배열에서 온도의 시작 위치

        // --------------------
        // DAU
        // --------------------
        public bool m_DAUEnable = false;
        List<cls_devDAU> m_ucDAU_List = new List<cls_devDAU>(); //  null;
        public int m_NumOfDAU = 0;
        public int[] m_voltcount_dau;   // [전압갯수]
        public int[] m_tempcount_dau;   // [온도갯수]        
        //+ Revision by KGY -20241209 : DAU 전압 온도 자료형 변경
        //public double[,] m_DAU_Volt;  // [#AUX]
        //public double[,] m_DAU_Temp;  // [#AUX]
        public List<List<double>> m_DAU_Volt;  // [#AUX]
        public List<List<double>> m_DAU_Temp;  // [#AUX]
        //-
        //+ Add by KGY -20241209 : NTC 경로 변수 추가
        public Dictionary<int, string> m_dDAU_NTC_Path; //<ch,path>
        //-

        //+ Add by YMJ - 240530 : 채널정보 UI에 온도 출력을 위해 DAU 수집 온도 평균 추가
        public double[] m_DAU_TempAvg;
        //-
        //+ Add by YMJ - 231124 : DAU Min, Max, Diff 값 파라미터
        public double[] m_DAU_V_Max;
        public double[] m_DAU_V_Min;
        public double[] m_DAU_V_Diff;
        //-
        //+ Add by LBG - 230809 : 온도 읽기 Type 설정
        /// <summary>
        /// 0 : NTC , 1 : K , 2 : BOTH
        /// </summary>
        public int[] m_TypeOfTemp;
        //-
        //+ Add by LBG - 230809 : Client D Class
        public int[] m_DAU_Clinet_DClass;
        //-
        public int[] m_NumOfModule;           // DAU 사용시, 팩을 구성하는 모듈의 갯수

        public int MAX_MODULE_COUNT = 24;

        public int[,] m_NumOfCell;  // DAU 사용시, 모듈별 Cell의 갯수 (예를들면, 코나의 경우 20S, 19S,..), DAU 파싱할때 사용.

        //public byte[,] m_1stidx_OP_D_Clsss;  // DAU IP D class, Ch number(0-All, 1, 2,.. Channel number)
        //public byte[,] m_1stidx_CAN_ID;      // BMS CAN ID, Ch number(0-All, 1, 2,.. Channel number)

        // --------------------
        // BMS
        // --------------------
        public bool m_BMSEnable = false;
        List<cls_devBMS_IONIQ5> m_ucBMS_List = new List<cls_devBMS_IONIQ5>(); // null;
        public int m_NumOfBMS = 0;
        public int[] m_voltcount_bms;   // [전압갯수]
        public int[] m_tempcount_bms;   // [온도갯수]        
        public double[,] m_BMS_Volt;  // [#AUX]
        public double[,] m_BMS_Temp;  // [#AUX]


        // --------------------
        // MBI
        // --------------------
        public bool m_MBIEnable = false;
        List<cls_devMBI> m_ucMBI_List = new List<cls_devMBI>(); // null;
        public int m_NumOfMBI = 0;
        public int[] m_voltcount_mbi;   // [전압갯수]
        public int[] m_tempcount_mbi;   // [온도갯수]        
        public double[,] m_MBI_Volt;  // [#AUX]
        public double[,] m_MBI_Temp;  // [#AUX]

        //+ Add by YMJ - 241105 : CREVIS AUX 추가
        public bool m_CREVISEnable = false;
        List<cls_devCREVIS> m_ucCREVIS_List = new List<cls_devCREVIS>(); //  null;
        public int m_NumOfCREVIS = 0;
        public int[] m_voltcount_crevis;   // [전압갯수]
        public int[] m_tempcount_crevis;   // [온도갯수]        
        public double[,] m_CREVIS_Volt;  // 
        public double[,] m_CREVIS_Temp;  // 

        public double[] m_CREVIS_V_Max;
        public double[] m_CREVIS_V_Min;
        public double[] m_CREVIS_V_Diff;

        public double[] m_CREVIS_T_Max;
        public double[] m_CREVIS_T_Min;
        public double[] m_CREVIS_T_Diff;
        //-

        //+ Add by YMJ - 250717 : CREVIS 장비 1:N 분할 옵션 추가(Default 1:1)
        public int m_CREVIS_DEVISION = 1;
        //-

        public bool m_ParallelEnable = false;
        List<cls_devParallel> m_ucParallel_List = new List<cls_devParallel>();
        public int m_NumOfParallel = 0;

        // --------------------
        // CAN
        // --------------------
        public bool m_CANEnable = false;
        List<cls_devCAN> m_ucCAN_List = new List<cls_devCAN>();
        public int m_NumOfCAN = 0;
        public bool m_alwaysLog = false;

        // -------------------------------------------------
        // 절연저항기
        // 231027 BGH
        // -------------------------------------------------
        //+ Revision by YMJ - 240613 : 절연저항기 class 수정
        //List<cls_devInsulation> m_ucIT_List = new List<cls_devInsulation>(); // null;
        List<cls_devInsulationTester> m_ucIT_List = new List<cls_devInsulationTester>(); // null;
        //-
        public bool m_ITDevEnable = false;
        public int m_NumOfIT = 0;

        public bool[] m_ITType;
        public string[] m_IT_Comport;
        public string[] m_IT_Relay_Comport;
        public uint[] m_IT_TestVoltage;
        public uint[] m_IT_TestTime;


        // ------------
        // Chamber 추가할것.
        // ------------
        //+ Add By YMJ - 240416 : 알람 시 챔버 stop 여부 판단을 위한 변수 선언
        public bool m_chamberAutoStop = true;
        //-

        // ----------------------------------------------
        // Ch별로 몇번째 보드에 있는지...
        // ----------------------------------------------
        public int[] Board_Ch_Mapping = new int[1];

        //int m_Cur_BD_idx = -1;       // 현재 선택된 보드 보드 번호 : base 0, -1(미설정)
        //int m_Cur_Ch_idx_in_BD = -1; // 보드내 채널 index : base 0
        //int m_Cur_Max_Ch_in_BD = 0;  // 보드내 MAX 채널 갯수

        //int m_iCur_CH_NO = -1;       // 현재 선택된 채널 번호 : base 0, -1(미설정)
        int m_Tot_Ch_Count = 0;      // 총 채널 갯수 

        // ----------------------------------------------
        // Ch별로 몇번째 보드에 있는지...
        // ----------------------------------------------
        // public bool[] Is_On_Testin = new bool[1];

        // ----------------------------------------------
        // for Repeat
        // ----------------------------------------------
        public const int CST_CyclingSize = 200;  // Start/End 쌍의 갯수
        public short[,,] cycling = new short[1, CST_CyclingSize, 3];  // Cycle Start index, end index, Count
        public short[] cycling_start = new short[1];
        public short[] cycling_end = new short[1];
        public short[] cycling_loopcount = new short[1];

        public int[] m_currentStep = new int[1];
        public short[] m_timelimit = new short[1];
        public short[] m_timelimitSUB = new short[1];

        //Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
        //Display_CH_Data m_dispChData = new Display_CH_Data();

        // --------------------------
        // ghbaik
        // --------------------------
        public Channel_Info m_CurChStatusInfo = new Channel_Info();

        frmGraph_RT_Cycler m_Graph_RT_Cycler;
        frmGraph_RT_ACIA m_Graph_RT_ACIA;

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        // --------------------------------------------
        // 241028, BGH
        // 챔버와 칠러 Display 통합위해
        // --------------------------------------------
        public struct ChamChillDisplay
        {
            public string Name;
            public double value;
            public int CH_NO;

            public void Set_Value(string n_sName, double n_dValue)
            {
                Name = n_sName;
                value = n_dValue;
            }

            public void Set_Value(int n_iCH_No, string n_sName, double n_dValue)
            {
                CH_NO = n_iCH_No;
                Name = n_sName;
                value = n_dValue;
            }
        }
        // index 0 : Chamber SP
        //       1 : Chamber PV
        //       2 : Chamber 출력량
        //       3 : tVOC 1
        //       4 : tVOC 2
        // index 5 : Chiller SP
        //       6 : Chiller PV
        //       7 : Chiller 출력량
        // index 8 : Chiller SP_Flow
        //       9 : Chiller PV_Flow
        //      10 : Chiller Flow 출력량

        //+ Revision by LBG - 241104 : 챔버 및 칠러, MTVD 데이터 디스플레이를 위하여 변경
        //public ChamChillDisplay[] rtChamChill = new ChamChillDisplay[11];
        public List<ChamChillDisplay> m_Chamber_Val = new List<ChamChillDisplay>();
        public Dictionary<int, List<ChamChillDisplay>> m_Chiller_Val = new Dictionary<int, List<ChamChillDisplay>>();
        public Dictionary<int, ChamChillDisplay> m_MTVD_Val = new Dictionary<int, ChamChillDisplay>();
        //public const int CST_Chamber_SP = 0;
        //public const int CST_Chamber_PV = 1;
        //public const int CST_Chamber_OUT = 2;

        //public const int CST_tVOC1 = 3;
        //public const int CST_tVOC2 = 4;

        //public const int CST_Chiller_SP = 5;
        //public const int CST_Chiller_PV = 6;
        //public const int CST_Chiller_OUT = 7;
        //public const int CST_Chiller_Flow_SP = 8;
        //public const int CST_Chiller_Flow_PV = 9;
        //public const int CST_Chiller_Flow_OUT = 10;
        //-
        // ---------------------------------------------
        //-

        //+ Revision By YMJ - 241217 : 미선택 구분을 위해 초기값 변경 0 -> -1
        /// <summary>
        /// 선택된 채널 번호
        /// base 0 ~
        /// </summary>
        int m_iCur_CH_NO = -1;
        //-

        public int Cur_CH_NO
        {
            set
            {
                m_iCur_CH_NO = value;
            }
        }

        /// <summary>
        /// LBG : 실시간 그래프 화면 표시 여부 확인(Cycler)
        /// </summary>
        bool m_bGraph_RT_Cycler = false;

        /// <summary>
        /// LBG : 실시간 그래프 화면 표시 여부 확인(ACIA)
        /// </summary>
        bool m_bGraph_RT_ACIA = false;

        public bool IS_Graph_RT_Cycler
        {
            get
            {
                return m_bGraph_RT_Cycler;
            }
            set
            {
                m_bGraph_RT_Cycler = value;
            }
        }

        public bool IS_Graph_RT_ACIA
        {
            get
            {
                return m_bGraph_RT_ACIA;
            }
            set
            {
                m_bGraph_RT_ACIA = value;
            }
        }

		// ----------------------------------------------------
		//
		// ----------------------------------------------------
		/// <summary>
		/// 선택한 채널의 진행 스케줄을 표시하는 Form
		/// </summary>
		frmRecipe_View m_frmRecipeView;
		public delegate void SetStepIndexEventHandler(int chidx, int m_stepnumber);
		public SetStepIndexEventHandler OnChangedStepNumber = null;


		/// <summary>
		/// 진행 스케줄 표시 화면 표시 여부 확인
		/// </summary>
		bool m_bCurSchedule_View = false;

        public bool IS_Recipe_View
        {
            get
            {
                return m_bCurSchedule_View;
            }
            set
            {
                m_bCurSchedule_View = value;
            }
        }

        public string Get_StartPath
        {
            get
            {
                return Application.StartupPath;
            }
        }

        // ----------------------------------------
        // gbaik #1
        // ----------------------------------------
        public enum DeViceTyPe
        {
            cycler_ABT, cycler_PNE, cycler_AV, cycler_HANA, cycler_PHENIXON,
            discharge_MinTech, discharge_MaroOn,
            acia_MBT, acia_MXZ,
            InsulationTester_Hioki,
            BI_Praj, BMS_KonaNiro, BMS_MinTech,
            DAQDMM_KeySight,
            DAU_Mintech,
            NotDesignedYet
        };

        private struct mtTimerVar
        {
            public bool enable;
            public int limit;      // 1-100ms
            public int tick;       // 1-100ms

            public mtTimerVar(bool pEnable, int plimit, int pTick)
            {
                enable = pEnable;
                limit = plimit;
                tick = pTick;
            }
            public void Reset()
            {
                enable = false;
                limit = 1;
                tick = 0;
            }
        };

        private mtTimerVar t001_10ms = new mtTimerVar(false, 1, 0);
        private mtTimerVar t002_1000ms = new mtTimerVar(false, 1, 0);
        private mtTimerVar t003_100ms = new mtTimerVar(false, 1, 0);
        private mtTimerVar t004_100ms = new mtTimerVar(false, 1, 0);
        private mtTimerVar t005_30sec = new mtTimerVar(false, 1, 0);

        // private Multimedia.Timer Timer5ms = new Multimedia.Timer();
        private Multimedia.Timer Timer10ms = new Multimedia.Timer();
        private Multimedia.Timer Timer100ms = new Multimedia.Timer();

        //+ revision by KGY 20240517 : splash 버전 정보 출력을 위해 수정
        frmSplash m_splash = new frmSplash();
        //-

        // --------------
        //
        // --------------
        public delegate void Raise5msTickEventHandler();  // , ABT.Mainframe.DeViceTyPe m_dvtype
        public Raise5msTickEventHandler OnTick5ms = null;

        public delegate void Raise10msTickEventHandler();  // , ABT.Mainframe.DeViceTyPe m_dvtype
        public Raise10msTickEventHandler OnTick10ms = null;

        public delegate void Raise100msTickEventHandler();  // , ABT.Mainframe.DeViceTyPe m_dvtype
        public Raise100msTickEventHandler OnTick100ms = null;

        // --------------
        //
        // --------------
        ToolTip toolTip = new ToolTip();

        //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
        public struct StruParallelMode
        {
            public bool use;
            public bool ismaster;    // true : 대장, false : 쫄병채널
            public int master_ch;    // 대장이면 자기채널 번호, 쫄병이면 대장 채널(base 0)

            public void Reset()
            {
                use = false;
                ismaster = false;
                master_ch = 0;
            }
        }
        public StruParallelMode[] m_paramode;
        //-

        // --------------------------------------------
        // Chamber 연동관련, 230917, BGH
        // --------------------------------------------
        public bool SetChamberMaintainUsage = false;
        public List<int> ChlistMaintain = new List<int>();

        public void ResetChamberMaintainSetting()
        {
            SetChamberMaintainUsage = false;
            ChlistMaintain.Clear();
        }
        public void SetChamberMaintainSetting(int addch)
        {
            SetChamberMaintainUsage = true;
            ChlistMaintain.Add(addch);              
        }
        public void RemoveChamberMaintainSetting(int remch)
        {
            int ifound = -1;
            for (int i = 0; i < ChlistMaintain.Count; i++)
            {
                if (ChlistMaintain[i] == remch)
                {
                    ifound = i;
                    break;
                }
            }

            if (ifound >= 0)
            {
                ChlistMaintain.RemoveAt(ifound);
            }

            if (ChlistMaintain.Count < 1)
            {
                SetChamberMaintainUsage = false;
            }
        }
        // ------------------------------------------
        // to here, ghbaik
        // ------------------------------------------

        //+ Add by LBG : Mainframe 현재 위치에서의 Center Point 가져오기
        public Point MainForm_Center
        {
            get
            {
                int n_iMain_X = this.Location.X;
                int n_iMain_Y = this.Location.Y;

                int n_iMainWidth = this.Width;
                int n_iMainHeight = this.Height;

                Point n_Ret_Pos = new Point();

                n_Ret_Pos.X = n_iMain_X + (n_iMainWidth / 2);
                n_Ret_Pos.Y = n_iMain_Y + (n_iMainHeight / 2);

                return n_Ret_Pos;
            }
        }
        //-

        //+ Add By LBG - 230921 : 작업 Step 설정 기능 추가
        Dictionary<int, Work_Step_Set> m_Work_Step_Set;
        //-

        //+ Add By LBG - 231024 : Get CH Count
        public int Get_CH_Cnt
        {
            get
            {
                if (m_clsSys_Link != null && m_clsSys_Link.m_Link_Info != null)
                {
                    return m_clsSys_Link.m_Link_Info.Count;
                }
                else
                {
                    return 0;
                }
            }
        }
        //-

        //+ Revision by LBG - 231124 : Timer에서 Delay 발생으로 채널 정보를 별도로 표시하는 기능 추가
        private sysTimer m_Tmr_Channel_Disp_Detail;
        //-

        //+ Add by KGY -20240516 : About,Splash에 버전 표시를 위한 코드추가
        public string m_sVersionText;
        public string Version
        {
            get { return m_sVersionText; }
        }
        //-

        //+ Add by LBG - 240523 : 통합관리시스템 연동 기능 추가
        PusherClient m_PusherClient = null;
        //-

        //+ Add by YMJ - 240809 : DTNC DAU 통신 누락감지 시간 옵션화 이전(Add by KGY - 240704)
        public int m_DauLimitTime;
        //-

        //+ Add by YMJ - 251014 : Chanmber 통신 누락감지 시간 옵션화
        public int m_ChamberLimitTime;
        //-

        //+ Add by YMJ - 251028 : CREVIS 통신 끊김 시 알람 or 0 데이터 플래그 추가
        public bool m_CrevisCommAlarm;
        //-

        //+ Add by YMJ - 250410 : UDP 통신 기능 추가
        UdpClient m_udpClient = null;
        Thread m_UDPSendThread = null;
        bool m_udpClientSend = false;
        IPEndPoint m_udpIPEndPoint = null;
        int m_UDPSend_Interval = 1000;
        //-

        //+ Add by YMJ - 250716 : CAN TX 전송 쓰레드 및 플래그 추가
        List<Thread> m_CANTXSendThread = null;
        List<bool> m_CANTXSend = null;
        //-

        //+ Revision by YMJ - 250410 : 데이터 저장 경로 처리
        public Mainframe(clsAppSetting n_clsAppSet, string n_DataFilePath)
        //-
        {
            InitializeComponent();

            //+ Add by YMJ - 250410 : 데이터 저장 경로 처리
            m_DataFilePath = n_DataFilePath;
            //-

            //+ revision by KGY 20240517 : splash 버전 정보 출력을 위해 위치 변경
            // ----------------------------------------------
            // this.Text
            // ----------------------------------------------
            // this.Text = "ABTProV2 [V1.0.0.0, R11.22] - Mintech";
            // this.Text = "ABTProV2 [v1.0.1.0, R07.03] - Mintech";  // LGES 서비스팀 (DAU)
            // this.Text = "ABTProV2 [v1.0.1.1, R08.22] - Mintech";     // LGES 2차 검수 버전
            // this.Text = "ABTProV2 [v1.0.1.2, R09.25] - Mintech";     // LGES 2차 검수 버전, Rest를Standby로, 챔버에 출력량 지원
            // this.Text = "ABTProV2 [v1.0.2.1, R10.11] - Mintech (Test Ver.)";     // Cell Voltage 기준으로 CV 적용 기능 추가 Test Version
            // this.Text = "ABTProV2 [v1.0.2.1]";     // LGES 정식 업데이트 버전 (231030에 발행)
            // this.Text = "ABTProV2 [v1.0.2.2, R11.24] - Mintech (Test Ver.)";
            // this.Text = "ABTProV2 [v1.0.2.2, R11.27] - Mintech (Test Ver.)";  // BGH, 팩전압CV, cellCV 값처리
            // this.Text = "ABTProV2 [v1.0.2.2, R11.30] - Mintech (Test Ver.)";  // LBG : Pattern 설정 관련 버그 수정
            // this.Text = "ABTProV2 [v1.0.2.2, R12.01] - Mintech (Test Ver.)";  // LBG : 메인에서 채널 상세 정보 업데이트 버그 수정, 레시피 작성 중 용량 안전 범위 검사 기능 주석 처리
            // this.Text = "ABTProV2 [v1.0.2.2, R12.04] - Mintech (Test Ver.)";  // LBG : MBT로 Data Logging 통일, Chamber 대기 중 다음 스텝 버그 수정
            // this.Text = "ABTProV2 [v1.0.2.2]";  // LBG : 정식 발행 버전 23.12.13
            // this.Text = "ABTProV2 [v1.0.2.3, R24.01.04] - Mintech (Test Ver.)";  // LBG : 각종 버그 수정 및 기능 강화 추가 (버전 관리 문서 참조)
            // this.Text = "ABTProV2 [v1.0.2.4]";  // LBG : 각종 버그 수정 및 기능 강화 추가 (버전 관리 문서 참조)
            // this.Text = "ABTProV2 [v1.0.2.5, R24.03.28] - Mintech (Test Ver.)";  // LBG : 각종 버그 수정 및 기능 강화 추가 (버전 관리 문서 참조)
            //this.Text = "ABTProV2 [v1.0.2.6, R24.05.07] - Mintech (Test Ver.)";  // YMJ : 각종 버그 수정 및 기능 강화 추가 (버전 관리 문서 참조)
            //this.Text = "ABTProV2 [v1.0.2.7, R24.11.27] - Mintech (Test Ver.)"; // YMJ : 각종 버그 수정 및 기능 강화 추가 (버전 관리 문서 참조)
            // this.Text = "ABTProV2 [v1.0.2.8, R25.02.24]";
            //this.Text = "ABTProV2 [v1.0.3.1]"; // KGY : FITI 버전 병합 ( Device UI Setting 및 DAU UI설정,분리 사용 기능) 
            this.Text = "ABTProV2 [v1.0.4.1]";
            //+ Add by KGY -20240516 : About,Splash에 버전 표시를 위한 코드추가
            try
            {
                //m_versionText = this.Text.Substring(this.Text.IndexOf('v') + 1, (this.Text.IndexOf(',') != -1 ? this.Text.IndexOf(',') : this.Text.IndexOf(']')) - (this.Text.IndexOf('v') + 1));
                //m_versionText = this.Text.Substring(this.Text.IndexOf('[') + 1, this.Text.IndexOf(']') - this.Text.IndexOf('[') - 1);
                m_sVersionText = this.Text.Substring(this.Text.IndexOf('[') + 1, this.Text.IndexOf(']') - this.Text.IndexOf('[') - 1).Split(',')[0];
            }
            catch (Exception e)
            {

                //WriteSystemLog("version Text error"+e); // 추가 피드백필요
            }
            //-

            #region create folder
            //+ Revision by KGY -20241209 : Setting 경로 추가
            string[] sDirPath = new string[]
            {
                "\\log",
                "\\System",
                "\\Pattern",
                "\\mdbc",
                "\\log\\Cycler",
                "\\log\\Data",
                "\\device",
                "\\Data",
                "\\Setting"
            };
            //-
            string sNewPath;
            DirectoryInfo di;
            try
            {
                for (int i = 0; i < sDirPath.Length; i++)
                {
                    sNewPath = Application.StartupPath + sDirPath[i];
                    di = new DirectoryInfo(sNewPath);
                    if (di.Exists == false)
                    {
                        di.Create();
                    }
                }
            }
            catch { }
            #endregion
            //+ revision by KGY 20240517 : splash 버전 정보 출력을 위해 수정
            m_clsAppSet = n_clsAppSet;
            m_clsAppSet.Set_MainFrame = this;
            //m_clsAppSet = new clsAppSetting(this);
            //-
            m_clsSys_Set = new clsSystem_Setting(Application.StartupPath);
            m_clsSys_Link = new clsSystem_Link(Application.StartupPath, m_clsSys_Set);

            this.m_SysLanguage = m_clsAppSet.APP_LANGUAGE;

            //+ Add by LBG - 230403 : 언어 변경 적용
            clsLang_Conv n_clsLang_Conv = new clsLang_Conv(this, this, this.Get_StartPath + "\\Language\\Define_Language.xml");
            //-
            //clsLang_Conv(this, this, Get_StartPath + "\\Language\\Define_Language.xml");

            // --------------------
            // ghbaik
            // --------------------
            //Timer5ms.Mode = TimerMode.Periodic;
            //Timer5ms.Period = 5;
            //Timer5ms.Resolution = 5;
            //Timer5ms.SynchronizingObject = this;
            //Timer5ms.Tick += new EventHandler(TimerEvent5);

            // --------------------
            // ghbaik
            // --------------------
            Timer10ms.Mode = TimerMode.Periodic;
            Timer10ms.Period = 10;
            Timer10ms.Resolution = 10;
            Timer10ms.SynchronizingObject = this;
            Timer10ms.Tick += new EventHandler(TimerEvent10);
            // Timer10ms.Start();

            // --------------------
            // ghbaik
            // --------------------
            Timer100ms.Mode = TimerMode.Periodic;
            Timer100ms.Period = 100;
            Timer100ms.Resolution = 10;
            Timer100ms.SynchronizingObject = this;
            Timer100ms.Tick += new EventHandler(TimerEvent100);
            // Timer100ms.Start();


            SetTimer10msTimer(1, 10);  // 10ms

            SetTimer(2, 1000);  // 1 sec
            SetTimer(5, 30000);  // 30 sec, for TOS

            // -------------------------------
            // ghbaik
            // -------------------------------
            Screen[] screens = Screen.AllScreens;

            if (screens.Length > 1)
            {
                Screen scrn = null;
                for (int i = 0; i < screens.Length; i++)
                {
                    string n_sDevice_Name = screens[i].DeviceName;
                    n_sDevice_Name = n_sDevice_Name.Substring(n_sDevice_Name.LastIndexOf('\\'));

                    if (n_sDevice_Name.Equals("\\DISPLAY1"))
                    {
                        scrn = screens[i];
                        break;
                    }
                }

                if (scrn == null)
                {
                    scrn = screens[0];
                }
                //m_splash.OnSplashEnd += DelayedFormLoadingTask;

                //+ Add by KGY - 240517 : 언어 변경을 위해 수정
                m_splash.Set_Mainframe = this;
                m_splash.TopMost = true;
                m_splash.Show();
                //-

                int scrx = scrn.Bounds.Width / 2 - m_splash.Width / 2;
                int scry = scrn.Bounds.Height / 2 - m_splash.Height / 2;
                //m_splash.Location = new System.Drawing.Point(scrn.Bounds.Left, 0);
                m_splash.Location = new System.Drawing.Point(scrx, scry);
            }
            else
            {
                //m_splash.OnSplashEnd += DelayedFormLoadingTask;
                m_splash.Set_Mainframe = this;
                m_splash.TopMost = true;
                m_splash.Show();
            }


            // -------------------------------------------
            // System Log
            // -------------------------------------------
            string m_logpath = Application.StartupPath + "\\System";
            string fldpath = m_logpath + "\\Syslog\\" + DateTime.Now.ToString("yyyy_MM_dd");
            try
            {
                di = new DirectoryInfo(fldpath);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            // ghbaik :  cvs --> cyc
            fldpath = fldpath + "\\Systemlog_" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".log";
            logSystem = new StreamWriter(fldpath, true, System.Text.Encoding.UTF8);
            m_days = DateTime.Now.Day;


            // ------------------------------
            //
            // ------------------------------

            //+ Revision by KGY -250428 : 설정 옵션 로드 변경 (ini -> AppSetting)
            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 채널 병렬 출력 모드 사용 여부 Flag 추가
            //m_bParallel_Use = false;
            //string n_sRead_P = inifile.GetIniValue("PARALLEL_USE", "PARALLEL", "FALSE");
            //if (n_sRead_P.ToUpper() == "TRUE")
            //{
            //    m_bParallel_Use = true;
            //}
            m_bParallel_Use = m_clsAppSet.Option_Set.Parallel_Use;
            //m_bParallel_Ch_Num = 2;
            //n_sRead_P = inifile.GetIniValue("PARALLEL_USE", "PARALLEL", "COMBINE_CH_NUM");
            //if (!int.TryParse(n_sRead_P, out m_bParallel_Ch_Num))
            //{
            //    m_bParallel_Ch_Num = 2;
            //}
            m_bParallel_Ch_Num = m_clsAppSet.Option_Set.Parallel_CH_Num;
            if (!m_bParallel_Use) m_bParallel_Ch_Num = 0;
            else
            {
                if (m_bParallel_Ch_Num < 2) m_bParallel_Ch_Num = 2;
            }
            //-
            //-
            m_bParallel_Auto = m_clsAppSet.Option_Set.Parallel_Auto;
            // ------------------------------
            //
            // ------------------------------
            #region MBT
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_isMBTKONA = m_clsAppSet.Option_Set.MBT_KONA_EFFECT;
            //+ Add By YMJ - 240617 : MBT Retry 여부 플래그 설정 값 추가
            m_retryMBT = m_clsAppSet.Option_Set.MBT_Retry_Enable;
            //-
            //-
            #endregion

            // -----------------------------------
            // 밸런싱은 AUX 처리 루틴 안으로 이동함
            // 23.08.12
            // -----------------------------------

            #region Power Supply
            //+ Revision by KGY - 20241206 : AUX 설정 개수 및 사용여부 load변경(ini -> SysSetting)
            m_powersupply = false;
            m_powersupply = m_clsSys_Set.m_Sys_POWERSUPPLY.POWERSUPPLY_Use;
            if (m_powersupply)
            {
                WriteSystemLog("");
                WriteSystemLog("// Power Supply Activated ");

                m_ucPowerSupply_PT = new cls_devPowerSupply_PT(this);
                m_ucPowerSupply_PT.datalog_path = Application.StartupPath + "\\device";
                m_ucPowerSupply_PT.SerialPort = m_clsSys_Set.m_Sys_POWERSUPPLY.POWERSUPPLY_COM_Port;

                int ibdrate = 115200;
                int.TryParse(m_clsSys_Set.m_Sys_POWERSUPPLY.POWERSUPPLY_Baudrate, out ibdrate);
                m_ucPowerSupply_PT.BaudRate = ibdrate;

                m_powersupply = m_ucPowerSupply_PT.StartSerial();

                WriteSystemLog("// Power Supply Setting // COMPORT=" + m_ucPowerSupply_PT.SerialPort + " // BaudRate=115200 // Enable=" + m_powersupply.ToString());
            }
            //-
            #endregion

            // ------------------------------
            //
            // ------------------------------
            #region Factor for Pattern
            //string strFct = inifile.GetIniValue("100MS_SETTING", "BASIC_FACTOR", "99.8");  // 98 --> 0.98
            //float itmp = 99.8f;
            //float.TryParse(strFct, out itmp);
            //if (itmp < 99 || itmp > 100) itmp = 99;
            //hmilfactor = itmp / 100;
            #endregion

            // ------------------------------
            //
            // ------------------------------
            #region lOGGING iNTERVAL
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            cyclog_intv = m_clsAppSet.Option_Set.CYCLER_LOG;
            //-
            // cycler log는 시간으로
            cyclog_intv /= 100;
            cyclog_intv *= 100;
            if (cyclog_intv < 100) cyclog_intv = 100;
            // 100ms 단위로 맞춤

            // system log는 ACIR제외, Step에 맞추어 cycler데이터 제공
            //strFct = inifile.GetIniValue("LOGGING", "SYSTEM_LOG", "1000");
            //if (!int.TryParse(strFct, out syslog_intv))
            //{
            //    syslog_intv = 1000;
            //}
            //syslog_intv /= 10;  // 100ms --> 10개의 구간으로 처리 (1초=100개) (인터럽트가 10ms 단위)
            //syslog_intv_buff = syslog_intv;
            #endregion

            // ------------------------------
            //
            // ------------------------------
            #region 우진산전부터 납품된 New Cycler 옵션
            // ------------------------------------------------------
            // 특징 
            //     1) 연결할때마다 시간 맞춤
            //     2) Safety 전압 제어
            //     3) CC/CV 모드 제어 (CC로 시작 후 CCCV로 전환)
            // ------------------------------------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_newtype_cycler = m_clsAppSet.Option_Set.Time_Setting_Auto;
            //-
            #endregion

            // ------------------------------
            // W-Scope용 REST 옵션
            // ------------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_RestOptionStandby = m_clsAppSet.Option_Set.REST_Use_Standby;
            //-
            // -----------------------------
            // + 230920, BGH
            // 0A Rest 실제 전류값 logging
            // -----------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_enable_real_rest_current_logging = m_clsAppSet.Option_Set.REST_Option_Logging;
            //-
            // ------------------------------
            //
            // ------------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_currautocal = m_clsAppSet.Option_Set.AUTO_CurrCal;
            //+ Add by YMJ - 240530 : 채널정보 UI에 온도 출력을 위해 어떤 디바이스에서 온도를 가져올지 설정 추가(기본 MBT)
            m_temp_Collect_dev = m_clsAppSet.Option_Set.TEMP_Collect_DEV;
            //-
            //-

            // -------------------------------------
            // CCCV, 설정 전압이 배터리 전압보다 충전때 낮거나, 방전때 높은 경우
            // Defauilt : false - skip (Cutoff by Voltage)
            //            true  - alarm 발생
            // --------------------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            CCCV_V_DoAlarm = m_clsAppSet.Option_Set.CCCV_V_Alarm_Control;
            //+ Add by YMJ - 240809 : DTNC DAU 통신 누락감지 시간 옵션화 이전(Add by KGY - 240704)
            m_DauLimitTime = m_clsAppSet.Option_Set.DAU_LimitTime;
            //-
            //-
            //+ Add by YMJ - 251014 : Chanmber 통신 누락감지 시간 옵션화
            m_ChamberLimitTime = m_clsAppSet.Option_Set.Chamber_LimitTime;
            //-
            //+ Add by YMJ - 251028 : CREVIS 통신 끊김 시 알람 or 0 데이터 플래그 옵션화
            m_CrevisCommAlarm = m_clsAppSet.Option_Set.Crevis_CommAlarm;
            //-
        }

        private void Mainframe_Load(object sender, EventArgs e)
        {

            string sysstr = "";

            //+ Add by LBG - 230330 : 언어 변경 관련 함수 호출
            //clsLang_Conv n_clsLang_Conv = new clsLang_Conv(this, this, Get_StartPath + "\\Define_Language.xml");
            //-

            //+ Add by LBG - 230822 : Main Menu에서 제어 부분 버튼 처리
            mn_Control_Start.Enabled        = false;
            mn_Control_Stop.Enabled         = false;
            mn_Control_Next_Step.Enabled    = false;
            mn_Control_Schedule.Enabled     = false;
            mn_Control_Graph.Enabled        = false;
            mn_Control_Nyquist.Enabled      = false;
            //-

            //+ Add By LBG - 22.11.18 : Main Menu Visiable Check
            MainMenu_Visiable_Set();
            //-

            int ch_count = m_clsSys_Link.m_Link_Info.Count;

            m_ucBoard_Status = new ucBoard_Status(m_clsSys_Set.m_Sys_BD.Count, this);
            m_ucBoard_Status.Dock = DockStyle.Fill;

            pn_Status_Board.Controls.Add(m_ucBoard_Status);

            m_ucChannel_Status = new ucChannel_Status(this, ch_count);
            m_ucChannel_Status.Volt_Number_Digit = m_clsAppSet.Logging_Set.Volt_Digit;
            //+ Add by KGY - 20241128 : DAU_Setting생성
            m_frmDAU_Set = new frmDAU_Set(this, m_clsSys_Set, m_clsSys_Link);
            //-

            // --------------------------------------------------------------------
            // 전압 Cut-Off, Safety등 round 처리
            // --------------------------------------------------------------------
            Volt_Number_Digit = m_clsAppSet.Logging_Set.Volt_Digit;
            //if (m_clsAppSet.Logging_Set.Volt_Digit == "F4") m_roundvalue = 0.00005;
            //else m_roundvalue = 0.0005;


            // ghbaik
            //m_ucChannel_Status.OnRenewChInformation += ReNewChDispInformation;


                //+ Add By LBG - 22.11.18 : 채널 상태에서 Popup Menu에서 버튼 눌렀을 경우 Event
            m_ucChannel_Status.OnPopupMenu_Event += CH_Status_Popup_Event;

            //-
            // ghbaik
            m_ucChannel_Status.Dock = DockStyle.Fill;
            pn_Status_Channel.Controls.Add(m_ucChannel_Status);

            // ghbaik
            IsOnTesting = new bool[ch_count];
            IsActivateEnding = new byte[ch_count];

            // ghbaik
            m_CurChStatusInfo.Reset();

            //logTOS = new StreamWriter[ch_count];
            logReg = new StreamWriter[ch_count];
            //+ Add by LBG - 230911 : Basic Log 작성 중인 파일의 경로를 담는 변수 추가
            m_dicBasicLog_Path = new Dictionary<int, string>();
            m_dicBasicLog_Header = new Dictionary<int, string>();
            //-
            logCond = new int[ch_count];
            logBuff = new int[ch_count];
            //+ Add by YMJ - 240823 : 패턴 일시 정지 로깅 tick 카운트를 위한 Buff 초기화
            patternBuff = new int[ch_count];
            //-
            logStepRes = new StreamWriter[ch_count];
            logCycler = new StreamWriter[ch_count];
            logCyclerRes = new StreamWriter[ch_count];

            logCyclerPath = new string[ch_count];
            cfile = new FileStream[ch_count];

            balancingActivated = new byte[ch_count];
            logopt = new byte[ch_count];

            m_ChamberReact = new bool[ch_count];

            m_AlarmRetryCount = new byte[ch_count, m_AlarmTypesNumber];

            // +
            // BGH 230911
            //mPV_Limit = new double[ch_count];
            //ChamberDirection = new byte[ch_count];  // 0:Stay, 1 : UP(SP > PV), -1 : Down(SP < PV)

            WriteSystemLog("// Assign Channel // Channel Count=" + ch_count.ToString());

            //+ Add By LBG - 230921 : 작업 Step 설정 기능 추가
            m_Work_Step_Set = new Dictionary<int, Work_Step_Set>();
            //-

            for (int i = 0; i < ch_count; i++)
            {
                IsOnTesting[i] = false;
                IsActivateEnding[i] = 0;

                //logTOS[i] = null; 
                logReg[i] = null;
                logStepRes[i] = null;
                logCycler[i] = null;
                logCyclerRes[i] = null;

                logCond[i] = 0;
                logBuff[i] = 0;
                //+ Add by YMJ - 240823 : 패턴 일시 정지 로깅 tick 카운트를 위한 Buff 초기값 선언
                patternBuff[i] = 0;
                //-

                logCyclerPath[i] = "";
                cfile[i] = null;

                balancingActivated[i] = 0;
                logopt[i] = 0;

                //m_eStepType[i] = cls_stepInfo.enumStepType.STANDBY;
                //m_eStepMode[i] = cls_stepInfo.enumStepMode.STANDBY;
                m_ChamberReact[i] = false;

                mPV_Limit = 0;
                ChamberDirection = 0;
                
                for (int m = 0; m < m_AlarmTypesNumber; m++ )
                {
                    m_AlarmRetryCount[i, m] = 0;
                }

                //+ Add By LBG - 230921 : 작업 Step 설정 기능 추가
                if (!m_Work_Step_Set.ContainsKey(i))
                {
                    Work_Step_Set n_Work_Step_Set_Temp = new Work_Step_Set();
                    n_Work_Step_Set_Temp.Reset();

                    m_Work_Step_Set.Add(i, n_Work_Step_Set_Temp);
                }
                //-
            }

            //+ Add by LBG - 240523 : 통합관리시스템 연동 기능 추가
            //string n_sPusher_Enable = inifile.GetIniValue("MONITORING_PARAMETER", "ENABLE", "FALSE");
            //if (n_sPusher_Enable.Equals("TRUE"))
            if (m_clsSys_Set.m_bUse_DIMS)
            {
                //string n_sPusher_Addr = inifile.GetIniValue("MONITORING_PARAMETER", "SERVER_IP", "127.0.0.1");
                string n_sPusher_Addr = m_clsSys_Set.m_Sys_DIMS[0].DIMS_IP;
                //string n_sPusher_Port = inifile.GetIniValue("MONITORING_PARAMETER", "SERVER_PORT", "1968");
                string n_sPusher_Port = m_clsSys_Set.m_Sys_DIMS[0].DIMS_Port;

                int n_iPusher_Port = 1968;

                if (!int.TryParse(n_sPusher_Port, out n_iPusher_Port))
                {
                    n_iPusher_Port = 1968;
                }

                //string n_sSend_Interval = inifile.GetIniValue("MONITORING_PARAMETER", "STATE_SEND_INTERVAL", ABT.PUSHER.GD.STATE_SEND_INTERVAL.ToString());

                int n_iSend_Interval = ABT.PUSHER.GD.STATE_SEND_INTERVAL;

                //if (!int.TryParse(n_sSend_Interval, out n_iSend_Interval))
                //{
                //    n_iSend_Interval = ABT.PUSHER.GD.STATE_SEND_INTERVAL;
                //}
                n_iSend_Interval = m_clsSys_Set.m_Sys_DIMS[0].DIMS_Send_Interval;

                GD.SERVER_IP = n_sPusher_Addr;
                GD.SERVER_PORT = n_iPusher_Port;
                GD.STATE_SEND_INTERVAL = n_iSend_Interval;

                m_PusherClient = new PusherClient(this);
                m_PusherClient.startConnect(IPAddress.Parse(GD.SERVER_IP), GD.SERVER_PORT);
            }
            //-

            // -----------------------------------------
            // 230920, 공정중일 아닐때도 전압 Safety 체크
            // -----------------------------------------
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            m_VsafetyUnder = m_clsAppSet.Option_Set.Volt_Under_Limit;
            m_VsafetyOver = m_clsAppSet.Option_Set.Volt_Over_Limit;
            //-

            // ------------------------------
            //
            // ------------------------------
            #region AUX   

            m_NumOfAUX = 0;
            m_NumOfDAU = 0;
            m_NumOfBMS = 0;
            m_NumOfMBI = 0;
            //+ Add by YMJ - 241105 : CREVIS AUX 초기값 추가
            m_NumOfCREVIS = 0;
            //-
            m_NumOfParallel = 0;


            m_AUXEnable = false;
            m_DAUEnable = false;
            m_BMSEnable = false;
            m_MBIEnable = false;
            //+ Add by YMJ - 241105 : CREVIS AUX 초기값 추가
            m_CREVISEnable = false;
            //-
            m_ParallelEnable = false;

            //m_ucAUX7019_List = null;
            //m_ucDAU_List = null;
            //m_ucBMS_List = null;

            //+ Revision by KGY - 20241206 : 설정 개수 및 사용여부 load변경(ini -> SysSetting)
            if (m_clsSys_Set.m_bUse_AUX || m_clsSys_Set.m_bUse_DAU || m_clsSys_Set.m_bUse_BMS || m_clsSys_Set.m_bUse_MBI || m_clsSys_Set.m_bUse_CREVIS || m_clsSys_Set.m_bUse_Parallel)
            {
                WriteSystemLog("");
                WriteSystemLog("// AUX Activated");

                #region AUX 종류별 갯수 
                // -----------------------------
                // AUX 갯수
                // -----------------------------
                m_NumOfAUX = m_clsSys_Set.m_Sys_AUX.Count;
                m_AUXEnable = m_clsSys_Set.m_bUse_AUX;

                // -----------------------------
                // DAU 갯수
                // -----------------------------
                m_NumOfDAU = m_clsSys_Set.m_Sys_DAU.Count;
                m_DAUEnable = m_clsSys_Set.m_bUse_DAU;
                // -----------------------------
                // BMS 갯수
                // -----------------------------
                m_NumOfBMS = m_clsSys_Set.m_Sys_BMS.Count;
                m_BMSEnable = m_clsSys_Set.m_bUse_BMS;
                // -----------------------------
                // MBI 갯수
                // -----------------------------
                m_NumOfMBI = m_clsSys_Set.m_Sys_MBI.Count;
                m_MBIEnable = m_clsSys_Set.m_Sys_MBI[0].MBI_Use;
                // -----------------------------
                // CREVIS 갯수
                // -----------------------------
                //+ Add by YMJ - 241105 : CREVIS AUX 설정 개수 읽어오기 추가
                m_NumOfCREVIS = m_clsSys_Set.m_Sys_CREVIS.Count;
                m_CREVISEnable = m_clsSys_Set.m_bUse_CREVIS;
                //-

                //+ Add by YMJ - 250717 : CREVIS 장비 1:N 분할 옵션 추가(Default 1:1)
                m_CREVIS_DEVISION = m_clsAppSet.Option_Set.CREVIS_DIVISION;
                //-

                //+ Add by YMJ - 250819 : 자동병렬 기능 관련 항목 추가
                m_NumOfParallel = m_clsSys_Set.m_Sys_Parallel.Count;
                m_ParallelEnable = m_clsSys_Set.m_bUse_Parallel;
                //-
                //-
                #endregion

                // -------------------------------------------------------
                // AUX 
                // -------------------------------------------------------
                if (m_NumOfAUX > 0 && m_AUXEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=ICPDAS[M-7019]");

                    // ------------------------------------
                    // M_7017 : M-7017 Series
                    // ------------------------------------
                    m_ucAUX7019_List = new List<cls_devAUX_M7019>();
                    m_voltcount_aux = new int[m_NumOfAUX];   // 전압 갯수
                    m_tempcount_aux = new int[m_NumOfAUX];   // 온도갯수
                    //m_voltpos = new int[m_NumOfAUX];
                    //m_temppos = new int[m_NumOfAUX];

                    AUX_V_diff = new double[m_NumOfAUX];
                    AUX_V_max = new double[m_NumOfAUX];
                    AUX_V_min = new double[m_NumOfAUX];

                    //AUX_T_diff = new double[m_NumOfAUX];
                    //AUX_T_max = new double[m_NumOfAUX];
                    //AUX_T_min = new double[m_NumOfAUX];

                    // ---------------------------------------
                    // 1번 Device 6개 모듈, 48개 전압 예제
                    //[AUX_DEVICE_1]
                    //COM_PORT = COM18
                    //BAUDRATE = 115200
                    //#DEVICE = 6  --> MODULE_COUNT
                    //#AUX = 48 
                    //#VOLT = 48
                    //#TEMP = 0
                    // ---------------------------------------  
                    for (int i = 0; i < m_NumOfAUX; i++)
                    {
                        string m_strAUX = "AUX_DEVICE_" + (i + 1).ToString();
                        Sys_Set_AUX n_Sys_AUX = m_clsSys_Set.m_Sys_AUX[i];

                        //string strCPrt = inifile.GetIniValue(m_strAUX, "COM_PORT", "COM0");
                        string strCPrt = n_Sys_AUX.AUX_COM_Port;
                        sysstr = "// AUX Setting  // " + m_strAUX + " // COMPort=" + strCPrt;

                        //string strBDrt = inifile.GetIniValue(m_strAUX, "BAUDRATE", "115200");
                        string strBDrt = n_Sys_AUX.AUX_Baudrate;
                        int ibdrate = 115200;
                        int.TryParse(strBDrt, out ibdrate);
                        sysstr = sysstr + " // BaudRate=" + ibdrate.ToString();

                        //m_auxstr = inifile.GetIniValue(m_strAUX, "#DEVICE", "1");  // Module Count - Serial 포트당 
                        int moduleTotalCount = n_Sys_AUX.AUX_VModule_Count + n_Sys_AUX.AUX_TModule_Count;
                        //int.TryParse(m_auxstr, out moduleTotalCount);
                        if (moduleTotalCount < 0 || moduleTotalCount > 255) moduleTotalCount = 1;


                        //m_auxstr = inifile.GetIniValue(m_strAUX, "#AUX", "1");  // COMPort에 할당된 AUX 갯수
                        int auxcount = n_Sys_AUX.AUX_Voltage_Count + n_Sys_AUX.AUX_Temp_Count;
                        //int.TryParse(m_auxstr, out auxcount);
                        if (auxcount < 0 || auxcount > 255) auxcount = 1;
                        sysstr = sysstr + " // #AUX=" + auxcount.ToString();

                        m_voltcount_aux[i] = 0;
                        m_tempcount_aux[i] = 0;
                        //m_auxstr = inifile.GetIniValue(m_strAUX, "#VOLT", "0");  // COMPort에 할당된 AUX 갯수
                        //if (!int.TryParse(m_auxstr, out m_voltcount_aux[i]))
                        //{
                        //    m_voltcount_aux[i] = 0;
                        //}
                        m_voltcount_aux[i] = n_Sys_AUX.AUX_Voltage_Count;
                        //m_auxstr = inifile.GetIniValue(m_strAUX, "#TEMP", "0");  // COMPort에 할당된 AUX 갯수
                        //if (!int.TryParse(m_auxstr, out m_tempcount_aux[i]))
                        //{
                        //    m_tempcount_aux[i] = 0;
                        //}
                        m_tempcount_aux[i] = n_Sys_AUX.AUX_Temp_Count;

                        if (m_voltcount_aux[i] > auxcount) m_voltcount_aux[i] = auxcount;
                        if (m_tempcount_aux[i] > auxcount) m_tempcount_aux[i] = auxcount;

                        if ((m_voltcount_aux[i] + m_tempcount_aux[i]) > auxcount)
                        {
                            m_tempcount_aux[i] = auxcount - m_voltcount_aux[i];
                        }

                        //m_voltpos[i] = 0;
                        //m_temppos[i] = m_voltcount_aux[i];

                        sysstr = sysstr + " // #VOLT=" + m_voltcount_aux[i].ToString();
                        sysstr = sysstr + " // #TEMP=" + m_tempcount_aux[i].ToString();

                        cls_devAUX_M7019 inst_aux = new cls_devAUX_M7019(this);
                        inst_aux.SerialPort = strCPrt;
                        inst_aux.ModuleCount = moduleTotalCount;
                        inst_aux.BaudRate = ibdrate;

                        //string strenable = inifile.GetIniValue(m_strAUX, "DEVICE_ENABLE", "FALSE");
                        //if (strenable.ToUpper() == "TRUE")
                        //{
                        //    inst_aux.ControlEnabled = true;
                        //}
                        //else
                        //{
                        //    inst_aux.ControlEnabled = false;
                        //}
                        inst_aux.ControlEnabled = n_Sys_AUX.AUX_Use;
                        //string strmdl = inifile.GetIniValue(m_strAUX, "#APPLIED_MODULE_NO", "1");
                        int m_mdl = n_Sys_AUX.AUX_Applied_ModuleNo;
                        //int.TryParse(strmdl, out m_mdl);
                        sysstr = sysstr + " // CtrlDIO Module Index=" + m_mdl.ToString();
                        inst_aux.ModduleIdWillbeRead = m_mdl;

                        int m_cnt = 0;
                        int n_AUX_D_index = 0;
                        foreach (Sys_Set_AUX_Detail n_item in m_clsSys_Set.m_Sys_AUX_Detail)
                        {
                            if (n_Sys_AUX.AUX_No == n_item.AUX_No)
                            {
                                break;
                            }
                            n_AUX_D_index++;
                        }
                        for (int m3 = 0; m3 < n_Sys_AUX.AUX_VModule_Count; m3++)
                        {
                            m_cnt = m_clsSys_Set.m_Sys_AUX_Detail[n_AUX_D_index].AUX_VList[m3];
                            inst_aux.m_VPerMdl[m3] = m_cnt;

                        }
                        for (int m3 = 0; m3 < n_Sys_AUX.AUX_TModule_Count; m3++)
                        {
                            m_cnt = m_clsSys_Set.m_Sys_AUX_Detail[n_AUX_D_index].AUX_TList[m3];
                            inst_aux.m_VPerMdl[m3 + n_Sys_AUX.AUX_VModule_Count] = m_cnt;

                        }
                        inst_aux.CalcVTStartPosition();

                        //m_unitpermodule[m_NumOfAUX] = auxcount / moduleTotalCount;  // 모듈당 AUX 갯수

                        inst_aux.datalog_path = Application.StartupPath + "\\device";
                        inst_aux.ChannelNo = i;
                        inst_aux.OnReadAUXM7019 += ReadPacketAUX;
                        inst_aux.OnDisconnectedAlarm += Disconnected_AUX;

                        if (strCPrt == "COM0" || strCPrt == "COM1")
                        {
                            inst_aux.ControlEnabled = false;  // Not Valid Status
                        }

                        AUX_V_diff[i] = 0;
                        AUX_V_max[i] = 0;
                        AUX_V_min[i] = 0;

                        //AUX_T_diff[i] = 0;
                        //AUX_T_max[i] = 0;
                        //AUX_T_min[i] = 0;

                        m_ucAUX7019_List.Add(inst_aux);
                    }

                    // ------------------------------------
                    //
                    // ------------------------------------
                    int maxnum_v = 0, maxnum_t = 0;
                    for (int k = 0; k < m_NumOfAUX; k++)
                    {
                        if (m_voltcount_aux[k] > maxnum_v) maxnum_v = m_voltcount_aux[k];
                        if (m_tempcount_aux[k] > maxnum_t) maxnum_t = m_tempcount_aux[k];
                    }
                    m_AUX_Volt = new double[m_NumOfAUX, maxnum_v];
                    m_AUX_Temp = new double[m_NumOfAUX, maxnum_t];

                    for (int i = 0; i < m_NumOfAUX; i++)
                    {
                        for (int k = 0; k < m_voltcount_aux[i]; k++)
                        {
                            m_AUX_Volt[i, k] = 0;
                        }
                        for (int k = 0; k < m_tempcount_aux[i]; k++)
                        {
                            m_AUX_Temp[i, k] = 0;
                        }
                    }

                    WriteSystemLog("// AUX Setting // " + sysstr);
                    // SetTimer10msTimer(3, 700);  // 600 msec


                    // -----------------------------------------------------------
                    // Balancing Setting
                    // -----------------------------------------------------------
                    #region Balancing
                    string strbal = "";

                    //string bal = inifile.GetIniValue("BALANCING_SETTING", "ENABLE", "FALSE");
                    //m_BalancingEnable = false;
                    //bool.TryParse(bal, out m_BalancingEnable);
                    m_BalancingEnable = m_clsSys_Set.m_bUse_BALANCER;
                    if (m_BalancingEnable)
                    {
                        WriteSystemLog("");
                        WriteSystemLog("// Balancing Activated");

                        bool balenable = false;
                        int bcount = 0;
                        //bal = inifile.GetIniValue("BALANCING_SETTING", "BALANCER_COUNT", "0");
                        //int.TryParse(bal, out bcount);
                        bcount = m_clsSys_Set.m_Sys_BALANCER.Count;
                        // ---------------------------------------------
                        // Balancing은 AUX만 제공.
                        // DAU는 제공안함.
                        // ---------------------------------------------
                        if (bcount > 0 && bcount == m_NumOfAUX)
                        {
                            for (int i = 0; i < bcount; i++)
                            {
                                strbal = "BALANCER_" + (i + 1).ToString();

                                cls_devBalancing m_ucBala = new cls_devBalancing(this, m_voltcount_aux[i]);

                                //bal = inifile.GetIniValue(strbal, "DEVICE_ENABLE", "FALSE");
                                //bool.TryParse(bal, out balenable);
                                balenable = m_clsSys_Set.m_Sys_BALANCER[i].BALANCER_Use;
                                if (balenable)
                                {
                                    m_ucBala.ControlEnabled = true;

                                    //bal = inifile.GetIniValue(strbal, "COM_PORT", "COM5");
                                    m_ucBala.datalog_path = Application.StartupPath + "\\device";
                                    m_ucBala.SerialPort = m_clsSys_Set.m_Sys_BALANCER[i].BALANCER_COM_Port;

                                    //bal = inifile.GetIniValue(strbal, "BAUDRATE", "115200");
                                    string bal = m_clsSys_Set.m_Sys_BALANCER[i].BALANCER_Baudrate;
                                    int ibdrate = 115200;
                                    int.TryParse(bal, out ibdrate);
                                    m_ucBala.BaudRate = ibdrate;

                                    m_ucBala.StartSerial();
                                    m_ucBalancer_List.Add(m_ucBala);

                                    WriteSystemLog("// Balancer Enabled #" + (i + 1).ToString() + "  // Balancing Setting // COMPORT=" + bal + " // BaudRate=115200 // Enable=" + m_BalancingEnable.ToString());
                                }
                                else
                                {
                                    m_ucBala.ControlEnabled = false;
                                    WriteSystemLog("// Balancer Disabled #" + (i + 1).ToString());
                                }
                            }
                        }
                        else
                        {
                            m_BalancingEnable = false;
                            WriteSystemLog("// Balancing Not Same AUX // Balancing Cnt" + m_clsSys_Set.m_Sys_BALANCER.Count.ToString() + "//AUX Cnt" + m_clsSys_Set.m_Sys_AUX.Count.ToString());
                            for (int i = 0; i < m_clsSys_Set.m_Sys_BALANCER.Count; i++)
                            {
                                WriteSystemLog("//Balancing No." + i + " Info // COMPORT=" + m_clsSys_Set.m_Sys_BALANCER[i].BALANCER_COM_Port + " // BaudRate=" + m_clsSys_Set.m_Sys_BALANCER[i].BALANCER_Baudrate + " // Enable=" + m_BalancingEnable.ToString());
                            }
                        }

                    }
                    else
                    {
                        m_BalancingEnable = false;
                        WriteSystemLog("// Balancing OFF");
                    }
                    #endregion
                }

                // -------------------------------------------------------
                // DAU
                // m_numOfDAU : Client 갯수, 서버는 PC 하나.
                // -------------------------------------------------------
                if (m_NumOfDAU > 0 && m_DAUEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=DAU");


                    // ------------------------------------
                    // DAU
                    // ------------------------------------
                    m_ucDAU_List = new List<cls_devDAU>();

                    m_voltcount_dau = new int[ch_count];   // 전압 갯수
                    m_tempcount_dau = new int[ch_count];   // 온도갯수
                    m_NumOfModule = new int[m_NumOfDAU];   // 모듈갯수
                    m_NumOfCell = new int[m_NumOfDAU, MAX_MODULE_COUNT];  // MAX 모듈 24개

                    //+ Revision By LBG - 230809 : DAU관련 설정 추가
                    m_TypeOfTemp = new int[ch_count];
                    m_DAU_Clinet_DClass = new int[m_NumOfDAU];
                    //-

                    m_DAU_Volt = new List<List<double>>();
                    for (int i = 0; i < ch_count; i++) 
                    {
                        m_DAU_Volt.Add(new List<double>()); 
                    }
                    m_DAU_Temp = new List<List<double>>();
                    for (int i = 0; i < ch_count; i++)
                    {
                        m_DAU_Temp.Add(new List<double>());
                    }
                    m_dDAU_NTC_Path = new Dictionary<int, string>();

                    //+ Add by YMJ - 240530 : 채널정보 UI에 온도 출력을 위해 DAU 수집 온도 평균 초기화
                    m_DAU_TempAvg = new double[ch_count];
                    //-
                    //+ Add by YMJ - 231124 : DAU Min, Max, Diff 값 파라미터 초기화
                    m_DAU_V_Max = new double[ch_count];
                    m_DAU_V_Min = new double[ch_count];
                    m_DAU_V_Diff = new double[ch_count];
                    //-
                    //m_NumOfCell = new int[m_NumOfDAU, maxnum_m];
                    
                    DAU_VT_Recount();
                    
                    for (int i = 0; i < ch_count; i++)
                    {
                        if (m_voltcount_dau[i] > 0)
                        {
                            // for (int k = 0; k < m_DAU_Volt.GetLength(1); k++)
                            for (int k = 0; k < m_voltcount_dau[i]; k++)
                            {
                                m_DAU_Volt[i].Add(0);
                            }
                        }
                        if (m_tempcount_dau[i] > 0)
                        {
                            for (int k = 0; k < m_tempcount_dau[i]; k++)
                            {
                                m_DAU_Temp[i].Add(0);
                            }
                        }
                    }
                    //+ Add by LBG - 230915 : DAU 통신 확인 기능 추가
                    cls_devDAU inst_dau = new cls_devDAU(this);
                    //-
                    inst_dau.datalog_path = Application.StartupPath + "\\device";
                    inst_dau.Client_Count = m_NumOfDAU;
                    

                    string[] strClient = new string[m_NumOfDAU];

                    for (int i = 0; i < m_NumOfDAU; i++)
                    {
						Sys_Set_DAU n_Sys_DAU = m_clsSys_Set.m_Sys_DAU[i];

                        sysstr = "// AUX Setting // #ofDAU=" + m_NumOfDAU.ToString();

                        string m_strDAU = "DAU_DEVICE_" + (i + 1).ToString();

                        inst_dau.m_CtrlEnabled[i] = n_Sys_DAU.DAU_Use;
                        sysstr = sysstr + "#DAU USE =" + n_Sys_DAU.DAU_Use;
                        List<int> n_ChList = m_clsSys_Link.Get_DAU_CH(n_Sys_DAU.DAU_No);
                        
                        int auxcn = 1;
                        auxcn = n_Sys_DAU.DAU_Voltage_Count + n_Sys_DAU.DAU_Temp_Count;
                        if (auxcn < 0 || auxcn > 255) auxcn = 1;
                        
                        //sysstr = sysstr + " // #VOLT=" + m_voltcount_dau[i].ToString();
                        //sysstr = sysstr + " // #TEMP=" + m_tempcount_dau[i].ToString();

                        m_NumOfModule[i] = n_Sys_DAU.DAU_VModule_Count;

                        sysstr = sysstr + " // #ofDAUModule=" + m_NumOfModule.ToString();

                        //string strSVRAddr = "192.168.5.100";
                        //+ Add by KGY -250509 : DAU 서버IP 설정 Option추가
                        inst_dau.myServerIPAddr = m_clsAppSet.Option_Set.DAU_SERVER_IP;
                        //-
                        string strTAddr = n_Sys_DAU.DAU_IP;
                        try
                        {
                            int.TryParse(strTAddr.Split('.')[3], out m_DAU_Clinet_DClass[i]);
                        }
                        catch
                        {
                            m_DAU_Clinet_DClass[i] = i;
                        }
                        strClient[i] = strTAddr;
                        string str_d_class = strClient[i].Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries)[3];
                        str_d_class = string.Format("{0:D3}", int.Parse(str_d_class));

                        byte m_dclass = 0;
                        byte.TryParse(str_d_class, out m_dclass);

                        sysstr = sysstr + " // " + m_strDAU + " // " + inst_dau.myServerIPAddr + " // " + strTAddr + "// #AUX=" + auxcn.ToString();


                        inst_dau.m_D_Class[i] = m_dclass;
                        inst_dau.strTCPIP[i] = strClient[i];

                        inst_dau.m_AutoLogging[i] = n_Sys_DAU.DAU_Auto_Logging;
                        if (inst_dau.m_AutoLogging[i])
                        {
                            string m_title = "Timestamp,";
                            if (n_ChList != null && n_ChList.Count > 0)
                            {
                                foreach (int ch in n_ChList)
                                {
                                    if (m_voltcount_dau[ch] > 0)
                                    {
                                        for (int loop1 = 0; loop1 < m_voltcount_dau[ch]; loop1++)
                                        {
                                            if (loop1 < (m_voltcount_dau[ch] - 1)) m_title += ("V" + (loop1 + 1).ToString() + ",");
                                            else m_title += ("V" + (loop1 + 1).ToString());
                                        }

                                        if (m_tempcount_dau[ch] > 0)
                                        {
                                            if (m_voltcount_dau[ch] != 0)
                                            {
                                                m_title += ",";
                                            }
                                        }

                                        for (int loop1 = 0; loop1 < m_tempcount_dau[ch]; loop1++)
                                        {
                                            if (loop1 < (m_tempcount_dau[ch] - 1)) m_title += ("T" + (loop1 + 1).ToString() + ",");
                                            else m_title += ("T" + (loop1 + 1).ToString());
                                        }

                                    }
                                }
                            }
                            inst_dau.OpenLog(i, m_title);
                        }

                        WriteSystemLog("// DAU Setting // " + sysstr);

                        m_ucDAU_List.Add(inst_dau);
                    }
                    
                    //+ Revision by KGY -240703 : 로그삭제(StratTcp이전이라 연결전임->항상 False)
                    //WriteSystemLog("// DAU Opened -" + inst_dau.isConnected.ToString());
                    //-          
                }

                // ----------------------------------------------
                // CAN 직결
                // 추후 NIRO/KONA 지원 필요
                // ----------------------------------------------
                if (m_NumOfBMS > 0 && m_BMSEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=BMS[IONIQ5/EV6]");

                    m_BMSEnable = true;

                    // ------------------------------------
                    // IONIQ5, EV6 (BMN이용)
                    // ------------------------------------
                    m_ucBMS_List = new List<cls_devBMS_IONIQ5>();
                    sysstr = "// AUX Setting";
                    m_voltcount_bms = new int[m_NumOfBMS];   // 전압 갯수
                    m_tempcount_bms = new int[m_NumOfBMS];   // 온도갯수

                    BMS_V_diff = new double[m_NumOfBMS];
                    BMS_V_max = new double[m_NumOfBMS];
                    BMS_V_min = new double[m_NumOfBMS];

                    //BMS_T_diff = new double[m_NumOfBMS];
                    //BMS_T_max = new double[m_NumOfBMS];
                    //BMS_T_min = new double[m_NumOfBMS];

                    if (m_NumOfBMS > 0)
                    {
                        m_BMSEnable = true;
                        sysstr = "// BMSEnable=" + m_BMSEnable.ToString() + " // #ofBMS=" + m_NumOfBMS.ToString();

                        for (int i = 0; i < m_NumOfBMS; i++)
                        {
                            string strBMSID = "BMS_DEVICE_" + (i + 1).ToString();

                            // string str = inifile.GetIniValue(strBMSID, "CAN_ID", "");
                            string str = m_clsSys_Set.m_Sys_BMS[i].BMS_CAN_Id;
                            int mnum = 0;

                            m_voltcount_bms[i] = 0;
                            m_tempcount_bms[i] = 0;
                            cls_devBMS_IONIQ5 m_bmscan = new cls_devBMS_IONIQ5(this);
                            if (str.Length == 2)
                            {
                                m_bmscan.ControlEnabled = true;
                                m_bmscan.datalog_path = Application.StartupPath + "\\device";
                                m_bmscan.m_ListIdx = i;

                                //m_voltcount_bms[i] = 0;
                                //m_tempcount_bms[i] = 0;
                                //str = inifile.GetIniValue(strBMSID, "#VOLT", "0");
                                //if (!int.TryParse(str, out m_voltcount_bms[i]))
                                //{
                                //    m_voltcount_bms[i] = 0;
                                //}
                                m_voltcount_bms[i] = m_clsSys_Set.m_Sys_BMS[i].BMS_Voltage_Count;
                                //str = inifile.GetIniValue(strBMSID, "#TEMP", "0");
                                //if (!int.TryParse(str, out m_tempcount_bms[i]))
                                //{
                                //    // m_tempcount_dau[i] = 0;
                                //    m_tempcount_bms[i] = 0;
                                //}
                                m_tempcount_bms[i] = m_clsSys_Set.m_Sys_BMS[i].BMS_Temp_Count;
                                sysstr = sysstr + " // Ch" + mnum.ToString() + " #VOLT=" + m_voltcount_bms[i].ToString();
                                sysstr = sysstr + " // Ch" + mnum.ToString() + " #TEMP=" + m_tempcount_bms[i].ToString();

                                WriteSystemLog("// BMS Setting // " + sysstr);
                            }
                            else
                            {
                                m_bmscan.ControlEnabled = false;
                            }
                            m_bmscan.m_ListIdx = i;

                            BMS_V_diff[i] = 0;
                            BMS_V_max[i] = 0;
                            BMS_V_min[i] = 0;

                            //BMS_T_diff[i] = -50;
                            //BMS_T_max[i] = -50;
                            //BMS_T_min[i] = -50;

                            m_ucBMS_List.Add(m_bmscan);
                            WriteSystemLog("// BMS Opened -" + m_bmscan.isConnected.ToString());
                        }

                        // ------------------------------------
                        //
                        // ------------------------------------
                        int maxnum_v = 0, maxnum_t = 0;
                        for (int k = 0; k < m_NumOfBMS; k++)
                        {
                            if (m_voltcount_bms[k] > maxnum_v) maxnum_v = m_voltcount_bms[k];
                            if (m_tempcount_bms[k] > maxnum_t) maxnum_t = m_tempcount_bms[k];
                        }
                        m_BMS_Volt = new double[m_NumOfBMS, maxnum_v];
                        m_BMS_Temp = new double[m_NumOfBMS, maxnum_t];

                        // for (int i = 0; i < m_NumOfAUX; i++)
                        for (int i = 0; i < m_NumOfBMS; i++)
                        {
                            for (int k = 0; k < m_voltcount_bms[i]; k++)
                            {
                                // m_AUX_Volt[i, k] = 0;
                                m_BMS_Volt[i, k] = 0;
                            }
                            for (int k = 0; k < m_tempcount_bms[i]; k++)
                            {
                                // m_AUX_Temp[i, k] = 0;
                                m_BMS_Temp[i, k] = 0;
                            }
                        }
                    }
                }

                // ----------------------------------------------
                // MBI - RAON
                // ----------------------------------------------
                if (m_NumOfMBI > 0 && m_MBIEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=MBI[RAon]");

                    m_MBIEnable = true;

                    m_ucMBI_List = new List<cls_devMBI>();
                    sysstr = "// AUX Setting";

                    // -------------------------------------------------------
                    // 230911
                    // MBI는 무조건 한대만 지원
                    // 한대가 2채널 가능하기 때문에, m_NumOfMBI = 1 OR 2가 됨.
                    // -------------------------------------------------------
                    m_NumOfMBI = 1;
                    //int.TryParse(str, out m_NumOfMBI);
                    m_NumOfMBI = m_clsSys_Set.m_Sys_MBI.Count;

                    m_voltcount_mbi = new int[m_NumOfMBI];   // 전압 갯수
                    m_tempcount_mbi = new int[m_NumOfMBI];   // 온도갯수

                    MBI_V_diff = new double[m_NumOfMBI];
                    MBI_V_max = new double[m_NumOfMBI];
                    MBI_V_min = new double[m_NumOfMBI];

                    sysstr = "// MBIEnable=" + m_MBIEnable.ToString() + " // #ofMBI=" + m_NumOfMBI.ToString();

                    //str = inifile.GetIniValue(strMBIID, "CAN_ID", "");
                    //mnum = 0;
                    string str = m_clsSys_Set.m_Sys_MBI[0].MBI_CAN_ID;
                    for (int i = 0; i < m_NumOfMBI; i++)
                    {
                        m_voltcount_mbi[i] = 0;
                        m_tempcount_mbi[i] = 0;
                    }

                    cls_devMBI m_mbican = new cls_devMBI(this);
                    if (str.Length == 2)
                    {
                        m_mbican.ControlEnabled = true;
                        m_mbican.datalog_path = Application.StartupPath + "\\device";

                        for (int i = 0; i < m_NumOfMBI; i++)
                        {
                            //str = inifile.GetIniValue(strMBIID, "#VOLT_" + (i + 1).ToString(), "0");
                            //if (!int.TryParse(str, out m_voltcount_mbi[i]))
                            //{
                            //    m_voltcount_mbi[i] = 0;
                            //}
                            m_voltcount_mbi[i] = m_clsSys_Set.m_Sys_MBI[i].MBI_VOLT;
                            //str = inifile.GetIniValue(strMBIID, "#TEMP_" + (i+1).ToString(), "0");
                            //if (!int.TryParse(str, out m_tempcount_mbi[i]))
                            //{
                            //    m_tempcount_mbi[i] = 0;
                            //}
                            m_tempcount_mbi[i] = m_clsSys_Set.m_Sys_MBI[i].MBI_TEMP;

                            sysstr = sysstr + " // Ch" + (i + 1).ToString() + " #VOLT=" + m_voltcount_mbi[i].ToString();
                            sysstr = sysstr + " // #TEMP=" + m_tempcount_mbi[i].ToString();

                            WriteSystemLog("// MBI Setting // " + sysstr);
                        }
                    }
                    else
                    {
                        m_mbican.ControlEnabled = false;
                    }

                    for (int i = 0; i < m_NumOfMBI; i++)
                    {
                        MBI_V_diff[i] = 0;
                        MBI_V_max[i] = 0;
                        MBI_V_min[i] = 0;
                    }

                    if (m_NumOfMBI == 1)
                    {
                        m_mbican.Num_of_Volt_ch1 = m_voltcount_mbi[0];
                        m_mbican.Num_of_Temp_ch1 = m_tempcount_mbi[0];
                        m_mbican.Num_of_Volt_ch2 = 0;
                        m_mbican.Num_of_Temp_ch2 = 0;
                        m_mbican.OneChUse = 1; // pack
                    }
                    else
                    {

                        m_mbican.Num_of_Volt_ch1 = m_voltcount_mbi[0];
                        m_mbican.Num_of_Temp_ch1 = m_tempcount_mbi[0];
                        m_mbican.Num_of_Volt_ch2 = m_voltcount_mbi[1];
                        m_mbican.Num_of_Temp_ch2 = m_tempcount_mbi[1];
                        m_mbican.OneChUse = 0;  // module, 2Ch use
                    }
                    m_mbican.OnDisconnectedAlarm += Disconnected_MBI;

                    //if (m_mbican.ControlEnabled)
                    //{
                    //    if (m_mbican.StartPCANComm() == cls_devMBI.PCANReturnCode.PCAN_OK)
                    //    {
                    //        m_mbican.WriteStartCommandLaon();
                    //    }
                    //}

                    m_ucMBI_List.Add(m_mbican);
                    WriteSystemLog("// MBI Opened -" + m_mbican.isConnected.ToString());
                    //}

                    // ------------------------------------
                    //
                    // ------------------------------------
                    int maxnum_v = 0, maxnum_t = 0;
                    for (int k = 0; k < m_NumOfMBI; k++)
                    {
                        if (m_voltcount_mbi[k] > maxnum_v) maxnum_v = m_voltcount_mbi[k];
                        if (m_tempcount_mbi[k] > maxnum_t) maxnum_t = m_tempcount_mbi[k];
                    }
                    m_MBI_Volt = new double[m_NumOfMBI, maxnum_v];
                    m_MBI_Temp = new double[m_NumOfMBI, maxnum_t];

                    for (int i = 0; i < m_NumOfMBI; i++)
                    {
                        for (int k = 0; k < m_voltcount_mbi[i]; k++)
                        {
                            m_MBI_Volt[i, k] = 0;
                        }
                        for (int k = 0; k < m_tempcount_mbi[i]; k++)
                        {
                            m_MBI_Temp[i, k] = 0;
                        }
                    }
                }

                //+ Add by YMJ - 241105 : CREVIS AUX 설정 값 읽어오기 추가
                 
                if (m_NumOfCREVIS > 0 && m_CREVISEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=CREVIS AUX");

                    // ------------------------------------
                    // IONIQ5, EV6 (BMN이용)
                    // ------------------------------------
                    m_ucCREVIS_List = new List<cls_devCREVIS>();
                    //sysstr = "// AUX Setting";
                    m_voltcount_crevis = new int[m_NumOfCREVIS];   // 전압 갯수
                    m_tempcount_crevis = new int[m_NumOfCREVIS];   // 온도갯수

                    //+ Revision by YMJ -250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
                    m_CREVIS_T_Diff = new double[Get_CH_Cnt];
                    m_CREVIS_T_Max = new double[Get_CH_Cnt];
                    m_CREVIS_T_Min = new double[Get_CH_Cnt];
                    //-

                    m_CREVISEnable = true;
                    sysstr = "// CREVISEnable=" + m_CREVISEnable.ToString() + " // #ofCREVIS=" + m_NumOfCREVIS.ToString();

                    WriteSystemLog("// CREVIS AUX Setting" + sysstr);
                    m_ucCREVIS_List.Clear();
                    for (int i = 0; i < m_NumOfCREVIS; i++)
                    {
                        string strCREVISID = "CREVIS_DEVICE_" + (i + 1).ToString();

                        m_voltcount_crevis[i] = 0;
                        m_tempcount_crevis[i] = 0;

                        cls_devCREVIS m_crevis = new cls_devCREVIS(i, this);
						//+ Revision by KGY -250430 : FITI버전 통합후 설정 적용 방식변경
                        //string eble = inifile.GetIniValue(strCREVISID, "DEVICE_ENABLE", "FALSE");
                        //if (eble.ToUpper() == "TRUE")
                        //{
                        //    m_crevis.ControlEnabled = true;
                        //}
                        //else
                        //{
                        //    m_crevis.ControlEnabled = false;
                        //}
                        m_crevis.ControlEnabled = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_Use;

                        if (m_crevis.ControlEnabled)
                        {
                            m_crevis.datalog_path = Application.StartupPath + "\\device";
                            m_crevis.mIndex = i;
                            m_crevis.OnReadCrevisData += OnReadCREVIS;


                            //eble = inifile.GetIniValue(strCREVISID, "IP_ADDRESS", "192.168.1.61");
                            m_crevis.IP_Address = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_IP;
                            m_crevis.IP_Port = 502;

                            //eble = inifile.GetIniValue(strCREVISID, "#AUX", "0");

                            int maxaux = 0, m_iv = 0;
                            //if (!int.TryParse(eble, out maxaux))
                            //{
                            //    maxaux = 0;
                            //}
                            maxaux = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_VOLT + m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_TEMP;
                            if (maxaux < 1)
                            {
                                m_crevis.VOLT_COUNT = 0;

                                m_crevis.ControlEnabled = false;
                            }
                            else
                            {
                                //eble = inifile.GetIniValue(strCREVISID, "#VOLT", "0");
                                //int.TryParse(eble, out m_iv);
                                m_voltcount_crevis[i] = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_VOLT;
                                m_crevis.VOLT_COUNT = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_VOLT;

                                //eble = inifile.GetIniValue(strCREVISID, "#TEMP", "0");
                                //int.TryParse(eble, out m_iv);
                                m_tempcount_crevis[i] = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_TEMP;
                                m_crevis.TEMP_COUNT = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_TEMP;

                                m_crevis.m_sysCalList = m_clsSys_Set.m_Sys_CREVIS[i].CREVIS_CALIBRATION;
                            }
                        }
                        m_ucCREVIS_List.Add(m_crevis);
                    }
                    //-
                    // ------------------------------------
                    // 
                    // ------------------------------------

                    //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
                    m_CREVIS_Volt = new double[Get_CH_Cnt, m_CREVIS_DEVISION];
                    m_CREVIS_Temp = new double[Get_CH_Cnt, m_CREVIS_DEVISION];
                    
                    for (int i = 0; i < Get_CH_Cnt; i++)
                    {
                        for (int k = 0; k < m_CREVIS_DEVISION; k++)
                        {
                            m_CREVIS_Volt[i, k] = 0;
                        }
                        for (int k = 0; k < m_CREVIS_DEVISION; k++)
                        {
                            m_CREVIS_Temp[i, k] = -100;
                        }
                    }
                    //-
                }
                //-

                //+ Add by YMJ - 250819 : 자동병렬 기능 장비 세팅 로드 추가
                if (m_NumOfParallel > 0 && m_ParallelEnable)
                {
                    WriteSystemLog("");
                    WriteSystemLog("// AUX TYPE=AUTO Parallel AUX");

                    m_ucParallel_List = new List<cls_devParallel>();

                    sysstr = "// ParallelEnable=" + m_ParallelEnable.ToString() + " // #ofParallel=" + m_NumOfParallel.ToString();

                    WriteSystemLog("// AUTO Parallel AUX Setting" + sysstr);
                    m_ucParallel_List.Clear();
                    for (int i = 0; i < m_NumOfParallel; i++)
                    {
                        cls_devParallel m_Parallel = new cls_devParallel(i, this);

                        m_Parallel.ControlEnabled = m_clsSys_Set.m_Sys_Parallel[i].Parallel_Use;

                        if(m_Parallel.ControlEnabled)
                        {
                            m_Parallel.datalog_path = Application.StartupPath + "\\device";

                            m_Parallel.IP_Address = m_clsSys_Set.m_Sys_Parallel[i].Parallel_IP;
                            m_Parallel.IP_Port = 502;
                        }
                        m_ucParallel_List.Add(m_Parallel);
                    }
                }
                //-
            }
            else
            {
                WriteSystemLog("// AUX OFF");
            }
            #endregion

            // --------------------
            // Chamber
            // --------------------
            #region 
            //+ Revision by KGY - 20241206 : Chamber 설정 값 load변경(ini -> SysSetting)
            // 챔버는 일단 0번째 기준으로만 사용
            Sys_Set_Chamber n_Sys_Chamber = m_clsSys_Set.m_Sys_Chamber[0];

            //string strCh = inifile.GetIniValue("CHAMBER_SETTING", "MODEL", "TEMP2500");
            string strCh = n_Sys_Chamber.Chamber_Model;
            int m_tmp = 0;
            bool b_tmp = false;

            //m_ucChamber = new cls_devChamber_Temp2500(this, 0);
            m_ucChamber = new cls_devChamber(this);

            if (strCh == "NEX1000") m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.NEX1000;
            else if (strCh == "NEX1100") m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.NEX1100;
            else if (strCh == "TEMP2520") m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.TEMP2520;
            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            // 240913, BGH
            // +
            else if (strCh == "SIMPAC") m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.SIMPAC;
            // -
            //+ Add by LBG - 250818 : TEMI2500 추가
            else if (strCh == "TEMI2500") m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.TEMI2500;
            //-
            else m_ucChamber.ChamberType = cls_devChamber.Chamber_Type.TEMP2500;

            //+ Add by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
            //+ Revision by LBG - 250818 : TEMI2500 추가로 인한 설정 변경
            //if (m_ucChamber.ChamberType != cls_devChamber.Chamber_Type.SIMPAC)
            //{
            //    m_ucChamber.OnReadChamberData += GotChamberTemp;
            //    m_ucChamber.OnSetDirection += SetChamberDirection;
            //}
            //else
            //{
            //    m_ucChamber.OnReadChamberData_SIMPAC += GotChamberTemp_SIMPAC;

            //    //+ Revision by LBG - 250623 : Simpac 챔버는 여러대를 연동 할 경우 Device No가 필요
            //    //                             우선은 1대를 사용하기 대문에 1로 지정, 차후 수정 필요
            //    //string n_sDevice_No = inifile.GetIniValue("CHAMBER_SETTING", "Device_No", "1");
            //    string n_sDevice_No = "1";
            //    //-
            //    int n_iDevice_No = 1;
            //    int.TryParse(n_sDevice_No, out n_iDevice_No);

            //    m_ucChamber.Device_No = n_iDevice_No;
            //}
            
            if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
            {
                m_ucChamber.OnReadChamberData_SIMPAC += GotChamberTemp_SIMPAC;

                string n_sDevice_No = "1";
                //-
                int n_iDevice_No = 1;
                int.TryParse(n_sDevice_No, out n_iDevice_No);

                m_ucChamber.Device_No = n_iDevice_No;
            }
            else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
            {
                m_ucChamber.OnReadChamberData_TEMI2500 += GotChamberTemp_TEMI2500;
            }
            else
            {
            m_ucChamber.OnReadChamberData += GotChamberTemp;
            m_ucChamber.OnSetDirection += SetChamberDirection;
            }
            //-

            // 230103, BGH
            bool chamenable = false;
            b_tmp = false;
            //strCh = inifile.GetIniValue("CHAMBER_SETTING", "ENABLE", "FALSE");
            //if (bool.TryParse(strCh, out b_tmp))
            //{
            //    chamenable = b_tmp;
            //    // m_ucChamber.EnableFlag = b_tmp; 240103, BGH
            //}
            //else
            //{
            //    chamenable = false;
            //    // m_ucChamber.EnableFlag = false; 240103, BGH
            //}
            chamenable = n_Sys_Chamber.Chamber_Use;

            //strCh = inifile.GetIniValue("CHAMBER_SETTING", "COM_PORT", "");
            strCh = n_Sys_Chamber.Chamber_COM_Port;
            m_ucChamber.SerialPort = strCh;
            if (strCh == "" || strCh.Length < 4)
            {
                chamenable = false;
                // m_ucChamber.EnableFlag = false; 240103, BGH
            }
            m_ucChamber.EnableFlag = chamenable;

            WriteSystemLog("");
            WriteSystemLog("// Chamber Usage = " + m_ucChamber.EnableFlag.ToString());
            sysstr = "// " + strCh;

            //+ Add By YMJ - 240416 : 알람 시 챔버 stop 여부 판단을 위한 변수에 설정 값 넣기
            //strCh = inifile.GetIniValue("CHAMBER_SETTING", "ALARM_AUTO_STOP ", "TRUE");
                
            if (n_Sys_Chamber.Chamber_Alarm_Auto_Stop)
            {
                if (m_chamberAutoStop)
                {
                    m_ucChannel_Status.SetPopupVisibledChamberStop(false);
                }
                else
                {
                    m_ucChannel_Status.SetPopupVisibledChamberStop(chamenable);
                }
            }
            else
            {
                m_ucChannel_Status.SetPopupVisibledChamberStop(false);
            }
            //-

            //strCh = inifile.GetIniValue("CHAMBER_SETTING", "BAUDRATE", "115200");
            strCh = n_Sys_Chamber.Chamber_Baudrate;
            m_tmp = 115200;
            int.TryParse(strCh, out m_tmp);
            m_ucChamber.BaudRate = m_tmp;
            sysstr = sysstr + " // BaudRate=" + m_tmp.ToString();

            //b_tmp = true;
            //strCh = inifile.GetIniValue("CHAMBER_SETTING", "CHECKSUM", "TRUE");
            //bool.TryParse(strCh, out b_tmp);
            b_tmp = n_Sys_Chamber.Chamber_Checksum;
            m_ucChamber.EnableChecksum = b_tmp;
            sysstr = sysstr + " // Checksum Use=" + b_tmp.ToString();

            m_ucChamber.datalog_path = Application.StartupPath + "\\device";

            m_ucChamber.ChamberIndex = 0;

            WriteSystemLog("// Chamber Setting" + sysstr);

            // -------------------------------
            // I-7055 (Digital I/O Dev)
            // -------------------------------
            m_ucChamberDIO = new cls_devDIO_I7055(this);
            m_ucChamberDIO.datalog_path = Application.StartupPath + "\\device";
            if (m_ucChamber.EnableFlag)
            {
                if(n_Sys_Chamber.ChamberDIO_Baudrate != "" && n_Sys_Chamber.ChamberDIO_COM_Port !="" 
                    && n_Sys_Chamber.ChamberDIO_Device !="" && n_Sys_Chamber.ChamberDIO_Module_No > -1)
                {
                    sysstr = "// ChamberDIO Enable=True";
                    m_ucChamberDIO.EnableFlag = true;
                }
                else
                {
                    sysstr = "// ChamberDIO Enable=false";
                    m_ucChamberDIO.EnableFlag = false;
                }

                //strCh = inifile.GetIniValue("CHAMBER_SETTING", "CONTROL_DEV", "I7055");
                strCh = n_Sys_Chamber.ChamberDIO_Device;
                if (strCh == "I7055")
                {
                    sysstr = sysstr + " // DEV=I-7055";

                    //strCh = inifile.GetIniValue("CHAMBER_SETTING", "CONTROL_PORT", "");
                    strCh = n_Sys_Chamber.ChamberDIO_COM_Port;
                    m_ucChamberDIO.SerialPort = strCh;
                    if (strCh == "" || strCh.Length < 4)
                    {
                        m_ucChamberDIO.EnableFlag = false;
                    }
                    sysstr = sysstr + " // Enable Adjust=" + m_ucChamberDIO.EnableFlag.ToString();

                    //strCh = inifile.GetIniValue("CHAMBER_SETTING", "BAUDRATE", "115200");
                    strCh = n_Sys_Chamber.ChamberDIO_Baudrate;
                    m_tmp = 115200;
                    int.TryParse(strCh, out m_tmp);
                    m_ucChamberDIO.BaudRate = m_tmp;
                    sysstr = sysstr + " // BaudRate=" + m_tmp.ToString();

                    //strCh = inifile.GetIniValue("CHAMBER_SETTING", "CONTROL_MODULE_NO", "1");
                    //m_tmp = 1;
                    //int.TryParse(strCh, out m_tmp);
                    m_tmp = n_Sys_Chamber.ChamberDIO_Module_No;
                    m_ucChamberDIO.ModuleNumber = m_tmp;
                    sysstr = sysstr + " // DIO Ctrl Module Index=" + m_tmp.ToString();

                    m_ucChamberDIO.OnReadAUXI7055Data += ReadPacketAUXI7055;

                    WriteSystemLog("// ChamberDIO Setting" + sysstr);


                    // -------------------------
                    // 230911 연결시에 챔버 start
                    // + 
                    if (m_ucChamber.StartSerial())
                    {
                        // 231115 BGH
                        //m_ucChamber.StopAction();
                        //Thread.Sleep(100);
                        // -

                        //m_ucChamber.SendReadPVSPCmd();  // 연결되자 마자 한번 읽는다.
                        //m_ucChamber.SetReadTimer();
                        //Thread.Sleep(100);

                        WriteSystemLog(">> Start Chamber - OnStart");

                        //if (m_ucChamberDIO.EnableFlag)
                        //{
                        //    m_ucChamberDIO.StartSerial();
                        //    WriteSystemLog(">> Start Chamber DIO - OnStart");
                        //}
                    }
                    else
                    {
                        WriteSystemLog(">> Start Chamber [Not connected] - OnStart");
                    }

                    // ----------------------------------------
                    // Chamber DIO는 챔버 연결과 독립적으로 연결해야함.
                    // -----------------------------------------
                    if (m_ucChamberDIO.EnableFlag)
                    {
                        if (m_ucChamberDIO.StartSerial())
                        {
                            WriteSystemLog(">> Start Chamber DIO - OnStart");
                        }
                        else
                        {
                            WriteSystemLog(">> Start Chamber DIO [Not connected] - OnStart");
                        }
                    }
                    else
                    {
                        WriteSystemLog("// Chamber DIO Enable = False");
                    }
                }
            }
            else
            {
                m_ucChamberDIO.EnableFlag = false;
                WriteSystemLog("// Chamber Enable = False");
            }
            //-

            // --------------------
            // Chiller
            // --------------------
            #region
            //+ Revision by LBG -250623 : Chiller 제어가 통합되어 변경 (단독 -> 여러대)
            //+ Revision by KGY - 20241206 : Chiller 설정 값 load변경(ini -> SysSetting)
            //if (m_clsSys_Set.m_bUse_Chiller) 
            //{
            //    #region
            //    //strCh = inifile.GetIniValue("CHILLER_SETTING", "MODEL", "TEMP2520");
            //    strCh = m_clsSys_Set.m_Sys_Chiller[0].Chiller_Model;
                
            //    m_ucChiller = new cls_devChiller_Temp2520(this);
            //    m_ucChiller.OnReadT2520Data += GotChillerValue;
            //    m_ucChiller.OnCoolerOn += ChillerCoolerON;
            //    m_ucChiller.OnCoolerOff += ChillerCoolerOff;
            //    //strCh = inifile.GetIniValue("CHILLER_SETTING", "COM_PORT", "COM5");
            //    strCh = m_clsSys_Set.m_Sys_Chiller[0].Chiller_COM_Port;
            //    m_ucChiller.SerialPort = strCh;
            //    //strCh = inifile.GetIniValue("CHILLER_SETTING", "BAUDRATE", "115200");
            //    strCh = m_clsSys_Set.m_Sys_Chiller[0].Chiller_Baudrate;
            //    m_tmp = 115200;
            //    int.TryParse(strCh, out m_tmp);
            //    m_ucChiller.BaudRate = m_tmp;

            //    b_tmp = m_clsSys_Set.m_Sys_Chiller[0].Chiller_Checksum;
            //    //strCh = inifile.GetIniValue("CHILLER_SETTING", "CHECKSUM", "TRUE");
            //    //bool.TryParse(strCh, out b_tmp);
            //    m_ucChiller.EnableChecksum = b_tmp;

            //    b_tmp = m_clsSys_Set.m_Sys_Chiller[0].Chiller_Use;
            //    //strCh = inifile.GetIniValue("CHILLER_SETTING", "ENABLE", "FALSE");
            //    //bool.TryParse(strCh, out b_tmp);
            //    m_ucChiller.EnableFlag = b_tmp;

            //    m_ucChiller.datalog_path = Application.StartupPath + "\\device";
            //}

            m_bChiller_Use = m_clsSys_Set.m_bUse_Chiller;

            if (m_bChiller_Use)
            {
                int.TryParse(strCh, out m_bChiller_Cnt);
                m_bChiller_Cnt = m_clsSys_Set.m_Sys_Chiller.Count;

                for (int i = 0; i < m_bChiller_Cnt; i++)
                {
                    cls_devChiller n_cls_devChiller     = new cls_devChiller(this);
                    n_cls_devChiller.OnReadChillerData  += GotChillerValue;  // 241028, BGH
                    n_cls_devChiller.OnCoolerOn         += ChillerCoolerON;
                    n_cls_devChiller.OnCoolerOff        += ChillerCoolerOff;

                    n_cls_devChiller.SerialPort = m_clsSys_Set.m_Sys_Chiller[i].Chiller_COM_Port;

                    int n_BaudRate_Chiller = 0;
                    int.TryParse(m_clsSys_Set.m_Sys_Chiller[i].Chiller_Baudrate, out n_BaudRate_Chiller);
                    if (n_BaudRate_Chiller != 0)
                    {
                        n_cls_devChiller.BaudRate = n_BaudRate_Chiller;
                    }
                    else
                    {
                        n_cls_devChiller.BaudRate = 115200;
                    }

                    n_cls_devChiller.EnableChecksum = m_clsSys_Set.m_Sys_Chiller[i].Chiller_Checksum;

                    n_cls_devChiller.datalog_path = Application.StartupPath + "\\device";
                    n_cls_devChiller.CH_NO = i; // Zero Base

                    if (n_cls_devChiller.StartSerial())
                    {
                        WriteSystemLog(">> Start Chiller_" + i.ToString() +"CH - OnStart");
                    }
                    else
                    {
                        WriteSystemLog(">> Start Chiller_" + i.ToString() + "CH [Not connected] - OnStart");
                    }

                    n_cls_devChiller.EnableFlag = m_bChiller_Use;

                    m_ucChiller.Add(i, n_cls_devChiller);

                    Thread.Sleep(1000);
                }
            }
            // ----
            //
            // ----
            pn_ChannelDetail.AutoScrollPosition = new Point(0, 0);
            #endregion
            //-

            // --------------------------------
            // Cycler
            // --------------------------------
            ReNewBoardInformation();

            // --------------------------------------------------
            // for support repeat loop
            // ------------------
            // Cycle Start index, end index, Count
            // --------------------------------------------------
            cycling = new short[ch_count, CST_CyclingSize, 3];

            m_currentStep = new int[ch_count];
            m_timelimit = new short[ch_count];
            m_timelimitSUB = new short[ch_count];

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            m_paramode = new StruParallelMode[ch_count];
            //-

            // -------------------------
            // Add Stepinfo & Device List
            // -------------------------
            m_ucStepInfo_List = new List<cls_stepInfo>();
            m_ucMbT_List = new List<cls_devMBT>();
            //+ Revisioin by YMJ - 250213 : MxZ class 변경
            m_ucMcz_List = new List<cls_devMxZ>();
            //-
            //+ Revision by YMJ - 240613 : 절연저항기 class 수정
            //m_ucIT_List = new List<cls_devInsulation>();  // 231027
            m_ucIT_List = new List<cls_devInsulationTester>();
            //-
            m_ucDAQ_List = new List<cls_devDAQDMM>();
            //m_ucCAN_List = new List<cls_devMBI>();
            m_ucUDDS_List = new List<cls_udds>(); // ghbaik


            // ---------------
            // ghbaik
            // ---------------
            work_names = new string[ch_count];
            sche_names = new string[ch_count];
            sche_names_restart = new string[ch_count];

            Recipe_Files = new string[ch_count];
            m_AuxEndStepNumber = new int[ch_count];

            //m_Log_Opt_Chk_Work = new bool[ch_count];
            //m_Log_Opt_Chk_File = new bool[ch_count];
            //m_Log_Opt_Chk_Time = new bool[ch_count];
            m_Log_Opt_File = new string[ch_count];


            // ------------------------------------
            // 231126, delta processing
            // ------------------------------------
            log_volt_backup = new double[ch_count];
            log_curr_backup = new double[ch_count];
            log_temp_backup = new double[ch_count];
            log_volt_delta = new double[ch_count];
            log_curr_delta = new double[ch_count];
            log_temp_delta = new double[ch_count];

            // -----------------------------------
            //
            // -----------------------------------
            doPatternLog = new byte[ch_count];

            // -----------------------------------
            // 231103 BGH
            // -----------------------------------
            m_MCZEnable = false;
            
            m_MCZEnable = m_clsSys_Set.m_bUse_MCZ;
            
            for (int i = 0; i < ch_count; i++)
            {
                cls_stepInfo n_stinfo = new cls_stepInfo(this, i);
                m_ucStepInfo_List.Add(n_stinfo);

                work_names[i] = "";
                sche_names[i] = "";
                Recipe_Files[i] = "";

                //+ Add by LBG - 230308 : 작업 로그명 설정 기능 추가
                //m_Log_Opt_Chk_Work[i] = false;
                //m_Log_Opt_Chk_File[i] = false;
                //m_Log_Opt_Chk_Time[i] = false;
                m_Log_Opt_File[i] = "";
                //-

                cls_devMBT n_stmbt = new cls_devMBT(i, this);
                //+ Revisioin by YMJ - 250213 : MxZ class 변경
                cls_devMxZ n_stmcz = new cls_devMxZ(i, this);
                //-

                // -----------------------
                // MBT
                // -----------------------
                n_stmbt.OnConnected += Connected_MBT;
                n_stmbt.OnIsNotConnected += IsNotConnected_MBT;
                n_stmbt.OnStepEnd += StepEnd_MBT;
                n_stmbt.OnReadMBTData += WriteBasicLogwithNyquist;
                n_stmbt.OnReadTemperature += GetMBTTemperature;               
                // n_stmbt.ConnectionChecking = true;  // 240102, BGH
                m_ucMbT_List.Add(n_stmbt);

                //+ Revisioin by YMJ - 250213 : MxZ delegate 및 정보 읽어오는 방식 변경
                // -------------------------
                // MCZ
                // -------------------------
                n_stmcz.OnConnected += Connected_MCZ;
                n_stmcz.OnIsNotConnected += IsNotConnected_MCZ;
                n_stmcz.OnStepEnd += StepEnd_MCZ;
                n_stmcz.OnReadMCZData += WriteBasicLogwithNyquist;
                n_stmcz.OnReadTemperature += GetMBTTemperature;
                m_ucMcz_List.Add(n_stmcz);
                //-

                // ---------------------------
                // UDDS
                // ---------------------------
                cls_udds n_stPatrn = new cls_udds(i, this);
                n_stPatrn.datalog_path = Application.StartupPath + "\\log\\Pattern";
                n_stPatrn.OnStepEnd += StepEnd_UDDS;
                //n_stPatrn.OnWrite1stPatternRegLog += Write1stPatternLog;

				// 매번 갱신할 필요 없음
                //n_stPatrn.OnRenewChPatternInfo += ReNewChInfo4Pattern;  // ghbaik
                m_ucUDDS_List.Add(n_stPatrn);


                for (int i2 = 0; i2 < CST_CyclingSize; i2++)
                {
                    cycling[i, i2, 0] = -1;
                    cycling[i, i2, 1] = -1;
                    cycling[i, i2, 2] = 1;
                }
                m_currentStep[i] = -1;
                m_timelimit[i] = -1;
                m_timelimitSUB[i] = -1;

                m_AuxEndStepNumber[i] = 0;

                doPatternLog[i] = 0;


                // ------------------------------
                // 231126 delta
                // BGH
                // ------------------------------
                log_volt_delta[i] = -1;
                log_curr_delta[i] = -1;
                log_temp_delta[i] = -1;
                log_volt_backup[i] = -1;
                log_curr_backup[i] = -1;
                log_temp_backup[i] = -1;

                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬모드값 초기화
                m_paramode[i].Reset();
                //-
            }

            FillWorkNames(ch_count);

            //+ Add by YMJ - 250819 : 병렬 기능 사용 시 기 세팅 값 설정 추가
            if (m_bParallel_Use)
            {
                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬처리 정보 읽어서 저장
                PopParallelInfo();
                //-

                int boardid = 0;
                int bzch = 0;
                int master_bzch = 0;
                int master2_bzch = 0;
                for (int m = 0; m < m_paramode.Length; m++)
                {
                    if (m_paramode[m].use)
                    {
                        master_bzch = m_paramode[m].master_ch;
                        boardid = Board_Ch_Mapping[m];
                        bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m);
                        master2_bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(master_bzch);

                        m_ucCycler_ABT_List[boardid].MakeSetParallelModeABT(master2_bzch + 1, bzch + 1, true);
                    }
                    else
                    {
                        master_bzch = m_paramode[m].master_ch;
                        boardid = Board_Ch_Mapping[m];
                        bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m);
                        master2_bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(master_bzch);

                        m_ucCycler_ABT_List[boardid].MakeSetParallelModeABT(master2_bzch + 1, bzch + 1, false);
                    }
                }
            }
            //-

            //+ Add by YMJ - 250819 : 자동병렬 기능 사용 시 기 세팅 값 설정 추가
            if (m_ParallelEnable && m_bParallel_Use)
            {
                if (m_bParallel_Auto)
                {
                    string mstr = " >> Set Parallel Mode[Load] ";

                    WriteSystemLog(mstr);

                    mstr = " >> AutoParallel = TRUE // ";
                    for (int i = 0; i < m_paramode.Length; i++)
                    {
                        if(m_paramode[i].use)
                        {
                            if(m_paramode[i].ismaster)
                            {
                                if (!m_ucParallel_List[0].AutoParallelRelayChk())
                                {
                                    if (m_ucParallel_List[0].AutoParallelRelay(true))
                                    {
                                        m_bParallel_Use = true;
                                        mstr += "Relay on";
                                    }
                                    else
                                    {
                                        m_bParallel_Use = false;
                                        mstr += "Fail";
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (m_ucParallel_List[0].AutoParallelRelayChk())
                            {
                                if (m_ucParallel_List[0].AutoParallelRelay(false))
                                {
                                    mstr += "Relay Off";
                                }
                                else
                                {
                                    mstr += "Fail";
                                }
                            }
                        }
                    }
                    WriteSystemLog(mstr);
                }
                else
                {
                    m_ParallelEnable = false;
                }
            }
            //-

            // -------------------------------------------
            // Check AUX Connection
            // -------------------------------------------
            if (m_clsAppSet.Enable_Set.Enable_AUX)
            {
                if (m_AUXEnable && m_ucAUX7019_List != null)
                {
                    for (int i = 0; i < m_ucAUX7019_List.Count; i++)
                    {
                        // + Control Enable 조건 체크 추가, 230911
                        if (m_ucAUX7019_List[i].ControlEnabled && !m_ucAUX7019_List[i].isConnected)
                        {
                            m_ucAUX7019_List[i].StartSerial();

                            WriteSystemLog("// AUX #" + (i + 1).ToString() + " Connect // Connectivity=" + m_ucAUX7019_List[i].isConnected.ToString() + " // Start " + m_ucAUX7019_List[i].SerialPort);
                        }
                    }
                    SetTimer10msTimer(3, 700);  // 600 msec

                }

                if (m_DAUEnable && m_ucDAU_List != null)
                {
                    for (int i = 0; i < m_ucDAU_List.Count; i++)
                    {
                        if (m_ucDAU_List[i].m_CtrlEnabled[i])
                        {
                            //+ Revision by KGY - 240703 : SysLog ;기록시점 변경으로 주석처리
                            m_ucDAU_List[0].StartTCP();
                            break;
                            /*
                            if (m_ucDAU_List[i].StartTCP())
                            {
                                WriteSystemLog("// DAU Server #" + (i + 1).ToString() + " Connected // Start " + m_ucDAU_List[i].strTCPIP);
                            }
                            */
                        }
                    }
                    SetTimer10msTimer(3, 500);  // 600 msec
                }

                if (m_BMSEnable && m_ucBMS_List != null)
                {
                    for (int i = 0; i < m_NumOfBMS; i++)
                    {
                        if (m_ucBMS_List[i].ControlEnabled)
                        {
                            if (m_ucBMS_List[i].StartPCANCommFD() == cls_devBMS_IONIQ5.PCANReturnCode.PCAN_OK)
                            {
                                // ----------------------------------------
                                // Awake & 전압/온도 읽기
                                // ----------------------------------------
                                m_ucBMS_List[i].SetTimer(585, 5000);
                                m_ucBMS_List[i].SetTimer(586, 100);

                                // ----------------------------------------
                                // Relay 붙이기
                                // ----------------------------------------
                                m_ucBMS_List[i].SetTimer(582, 100);
                                m_ucBMS_List[i].SetTimerBy10ms(583, 10);
                                m_ucBMS_List[i].SetTimer(584, 100);

                                WriteSystemLog("// CAN #" + (i + 1).ToString() + " Connected // Start ");
                            }
                            else
                            {
                                WriteSystemLog("// CAN #" + (i + 1).ToString() + " Failed Connection ");
                            }
                        }
                    }
                    SetTimer10msTimer(3, 500);  // 600 msec
                }

                if (m_MBIEnable && m_ucMBI_List != null)
                {
                    for (int i = 0; i < m_ucMBI_List.Count; i++)
                    {
                        if (m_ucMBI_List[i].ControlEnabled)
                        {
                            if (m_ucMBI_List[i].StartPCANComm() == cls_devMBI.PCANReturnCode.PCAN_OK)
                            {
                                WriteSystemLog("// MBI #" + (i + 1).ToString() + " Connected // Start ");
                                m_ucMBI_List[i].WriteStartCommandLaon();
                            }
                            else
                            {
                                WriteSystemLog("// MBI #" + (i + 1).ToString() + " Failed Connection ");
                            }
                        }
                    }
                    SetTimer10msTimer(3, 500);
                }

                //+ Add by YMJ - 241108 : CREVIS AUX 연결 및 데이터 리드 추가
                if (m_CREVISEnable && m_ucCREVIS_List != null)
                {
                    for (int i = 0; i < m_ucCREVIS_List.Count; i++)
                    {
                        if (m_ucCREVIS_List[i].ControlEnabled)
                        {
                            if (m_ucCREVIS_List[i].StartTCP())
                            {
                                WriteSystemLog("// CREVIS #" + (i + 1).ToString() + " Connected // Start " + m_ucCREVIS_List[i].IP_Address);
                            }
                        }
                    }
                    SetTimer10msTimer(3, 500);  // 600 msec
                }
                //-

            }


            // -------------------------------------
            // CAN
            // --------------------------------------
            //+ Revision by KGY - 20241206 : CAN 설정 값 load변경(ini -> SysSetting)
            m_NumOfCAN = 0;
            m_CANEnable = false;
            if (m_clsSys_Set.m_bUse_CAN)
            {
                m_NumOfCAN = m_clsSys_Set.m_Sys_CAN.Count;
                //+ Add by YMJ - 241018 : CAN 정보 상시 디스플레이 옵션 추가
                if (m_clsAppSet.Option_Set.CAN_ALWAYSLOG)
                {
                    m_alwaysLog = true;
                }
                else
                {
                    m_alwaysLog = false;
                }

                WriteSystemLog("");
                WriteSystemLog("// CAN Setting : Total " + m_NumOfCAN.ToString() + "Channels // alwaysLogging : " + m_alwaysLog.ToString());
                //-

                if (m_NumOfCAN > 0)
                {
                    m_CANEnable = true;
                    //+ Add by YMJ - 250716 : CAN TX 전송 쓰레드 및 플래그 초기화
                    m_CANTXSendThread = new List<Thread>();
                    m_CANTXSend = new List<bool>();
                    //-

                    for (int ich = 0; ich < ch_count; ich++)
                    //for (int ich = 0; ich < m_NumOfCAN; ich++)
                    {
                        int n_CANlink = m_clsSys_Link.Get_CAN_Index(ich);
                        if(n_CANlink != -1)
                        {
                            Sys_Set_CAN n_sysSet_CAN = m_clsSys_Set.m_Sys_CAN[n_CANlink];

                            cls_devCAN m_ucCAN = new cls_devCAN(this);
                            m_ucCAN.datalog_path = Application.StartupPath + "\\device";
                            m_ucCAN.ChannelNo = ich;
                            m_ucCAN.OnGotValue += GotBMSControlValues;
                            m_ucCAN.OnDisconnectedAlarm += Disconnected_CAN;
                            //+ Add by YMJ - 250716 : CAN 통신 실패 알람 추가
                            m_ucCAN.OnCommAlarm += FailCommunication_CAN;
                            //-

                            m_ucCAN.ControlEnabled = n_sysSet_CAN.CAN_Use;
                            //+ Add by YMJ - 241018 : CAN 정보 상시 디스플레이 옵션 추가
                            if (m_alwaysLog)
                            {
                                //+ Revision by YMJ - 250716 : CAN 상시 디스플레이시 mdbc 파일 등록 안되 있을 경우 false로 변경
                                if (n_sysSet_CAN.CAN_MDBC != null)
                                {
                                    //strCan = inifile.GetIniValue(canchstr, "MDBCFILE", "");
                                    m_ucCAN.MDBC_file = Get_StartPath + "\\mdbc\\" + n_sysSet_CAN.CAN_MDBC;
                                    if(File.Exists(m_ucCAN.MDBC_file))
                                    {
                                        m_ucCAN.AlwaysLog = m_alwaysLog;
                                    }
                                    else
                                    {
                                        m_ucCAN.AlwaysLog = false;
                                    }
                                }
                                else
                                {
                                    m_ucCAN.AlwaysLog = false;
                                }
                                //-
                            }
                            //-

                            //+ Add by YMJ - 241018 : CAN 통신 로그 기록 옵션 추가
                            //strCan = inifile.GetIniValue(canchstr, "COMMLOG", "FALSE");
                            if (m_clsAppSet.Option_Set.CAN_COMMLOG)
                            {
                                m_ucCAN.CommunicationLog = true;
                            }
                            else
                            {
                                m_ucCAN.CommunicationLog = false;
                            }
                            //-

                            if (n_sysSet_CAN.CAN_Type == "FD")
                            {
                                //+ Revision by YMJ - 241018 : FD CAN 통신 옵션 상세 설정 추가
                                m_ucCAN.ClockFrequency = n_sysSet_CAN.CAN_FD_ClockFrequency;
                                m_ucCAN.BitRate = n_sysSet_CAN.CAN_FD_BitRate;
                                m_ucCAN.DataBitRate = n_sysSet_CAN.CAN_FD_DataBitRate;

                                WriteSystemLog("// CAN Setting : Ch = " + (ich + 1).ToString() + " // " +
                                    "FD CAN ClockFrequency = " + m_ucCAN.ClockFrequency + "// Bitrate = " + m_ucCAN.BitRate + "// Databitrate = " + m_ucCAN.DataBitRate);
                                m_ucCAN.IS_FD_CAN = true;
                                //-
                            }
                            else
                            {
                                m_ucCAN.IS_FD_CAN = false;
                                m_ucCAN.BaudRate_HS = n_sysSet_CAN.CAN_HS_Bitrate;
                                WriteSystemLog("// CAN Setting : Ch = " + (ich + 1).ToString() + " // HS CAN Bitrate = " + m_ucCAN.BaudRate_HS);
                            }

                            string strCan = n_sysSet_CAN.CAN_ID;
                            //+ Revision by YMJ - 250725 : CAN 기본 ID 0xFF로 변경
                            int canid = 255;
                            //-
                            int.TryParse(strCan, out canid);
                            m_ucCAN.CAN_ID = (byte)canid;

                            //+ Add by YMJ - 250725 : CAN 채널 정보 추가, 기본 채널 0x51
                            string strCanChannel = n_sysSet_CAN.CAN_CH;
                            int canch = 81;
                            int.TryParse(strCanChannel, out canch);
                            m_ucCAN.CAN_CHANNEL = (byte)canch;
                            //-

                            if (m_ucCAN.ControlEnabled)
                            {
                                //+ Add by YMJ - 250725 : CAN 로깅 시작 위치 이동
                                m_ucCAN.OpenLog();
                                //-

                                //+ Revision by YMJ - 250725 : CAN Connect 결과 로그 추가
                                //+ Revision by YMJ - 250716 : CAN 상시 사용일 경우에만 디바이스 등록과 동시에 연결
                                if (m_alwaysLog)
                                {
                                    cls_devCAN.PCANReturnCode result;
                                    if (m_ucCAN.IS_FD_CAN) result = m_ucCAN.StartPCANCommFD();
                                    else result = m_ucCAN.StartPCANComm();
                                    if(result != cls_devCAN.PCANReturnCode.PCAN_OK)
                                    {
                                        WriteSystemLog("// CAN Connect Fail // Result : " + result.ToString());
                                    }
                                    else
                                    {
                                        WriteSystemLog("// CAN Connect Success // Result : " + result.ToString());
                                    }
                                }
                                //-
                                //-

                                SetTimer10msTimer(3, 500);  // 600 msec
                            }
                            WriteSystemLog("// CAN Setting : Ch = " + (ich + 1).ToString() + " // CAN ID = " + canid.ToString("X2") + " // Enabled = " + m_ucCAN.ControlEnabled.ToString());
                            m_ucCAN_List.Add(m_ucCAN);
                            //+ Add by YMJ - 250716 : 장비 등록 시 CAN Tx 전송 쓰레드 및 플래그 초기화
                            Thread n_Thread = null;
                            m_CANTXSendThread.Add(n_Thread);
                            bool n_Bool = false;
                            m_CANTXSend.Add(n_Bool);
                            //-
                        }
                        else
                        {
                            cls_devCAN m_ucCAN = null;
                            m_ucCAN_List.Add(m_ucCAN);
                            //+ Add by YMJ - 250716 : 장비 등록 시 CAN Tx 전송 쓰레드 및 플래그 초기화
                            Thread n_Thread = null;
                            m_CANTXSendThread.Add(n_Thread);
                            bool n_Bool = false;
                            m_CANTXSend.Add(n_Bool);
                            //-
                        }
                    }
                }
            }
            //-


            // ------------------------------------------------------
            // 절연저항기
            // 231027, BGH
            // -------------------------------------------------------
            //+ Revision by KGY - 20241206 : 절연저항기 설정 값 load변경(ini -> SysSetting)
            m_NumOfIT = 0;
            m_ITDevEnable = m_clsSys_Set.m_bUse_Ins;
            if (m_ITDevEnable)
            {
                m_NumOfIT = m_clsSys_Set.m_Sys_Ins.Count;

                WriteSystemLog("");
                WriteSystemLog("// Insulation Tester : Total " + m_NumOfIT.ToString() + "Channels");

                if (m_NumOfIT > 0)
                {
                    //m_ITDevEnable = true;

                    m_ITType = new bool[m_NumOfIT];
                    m_IT_Comport = new string[m_NumOfIT];
                    m_IT_Relay_Comport = new string[m_NumOfIT];
                    m_IT_TestVoltage = new uint[m_NumOfIT];
                    m_IT_TestTime = new uint[m_NumOfIT];

                    string itchstr = "";
                    string itres = "";
                    bool ctrlEnable = true;
                    for (int ich = 0; ich < m_NumOfIT; ich++)
                    {
                        Sys_Set_Insulate n_Sys_Ins = m_clsSys_Set.m_Sys_Ins[ich];
                        itchstr = "IT_DEVICE_" + (ich + 1).ToString();

                        ctrlEnable = false;
                        ctrlEnable = n_Sys_Ins.Ins_Use;

                        itres = n_Sys_Ins.Ins_Mode;

                        m_ITType[ich] = true;
                        if (itres.ToUpper() == "SINGLE")
                        {
                            m_ITType[ich] = false;
                        }

                        itres = n_Sys_Ins.Ins_COM_Port;
                        if (itres.ToUpper() == "" || itres.ToUpper() == "COM0")
                        {
                            ctrlEnable = false;
                        }
                        else
                        {
                            m_IT_Comport[ich] = itres.ToUpper();
                        }

                        itres = n_Sys_Ins.Ins_Rly_COM_Port;
                        if (itres.ToUpper() == "" || itres.ToUpper() == "COM0")
                        {
                            if (m_ITType[ich])
                            {
                                ctrlEnable = false;
                            }
                        }
                        else
                        {
                            m_IT_Relay_Comport[ich] = itres.ToUpper();
                        }

                        itres = n_Sys_Ins.Ins_Voltage.ToString();
                        uint volt = 500;
                        uint.TryParse(itres, out volt);
                        if (volt < 10 || volt > 1000) volt = 500;
                        m_IT_TestVoltage[ich] = volt;

                        itres = n_Sys_Ins.Ins_Time.ToString();
                        volt = 60;
                        uint.TryParse(itres, out volt);
                        if (volt < 10 || volt > 120) volt = 60;
                        m_IT_TestTime[ich] = volt;


                        if (ctrlEnable)
                        {
                            //+ Revision by YMJ - 240613 : 절연저항기 class 수정 및 device 로그 추가
                            //cls_devInsulation m_ucIT = new cls_devInsulation(this, ich, m_ITType[ich], 9600, "N,8,1", m_IT_Comport[ich], m_IT_Relay_Comport[ich], m_IT_TestVoltage[ich], m_IT_TestTime[ich]);
                            cls_devInsulationTester m_ucIT = new cls_devInsulationTester(this, ich, m_ITType[ich], 9600, "N,8,1", m_IT_Comport[ich], m_IT_Relay_Comport[ich], m_IT_TestVoltage[ich], m_IT_TestTime[ich]);

                            m_ucIT.datalog_path = Application.StartupPath + "\\device";
                            //-

                            m_ucIT.ControlEnabled = true;
                            m_ucIT.OnConnected += Connected_IT;
                            m_ucIT.OnIsNotConnected += IsNotConnected_IT;
                            m_ucIT.OnStepEnd += StepEnd_IT;

                            m_ucIT_List.Add(m_ucIT);
                        }
                        //+ Revision by YMJ - 240613 : 절연저항기 class 수정
                        //+ Revision by YMJ - 240809 : 절연저항기 class 수정으로 인해 발생한 오류 수정
                        else
                        {
                            cls_devInsulationTester m_ucIT = new cls_devInsulationTester(this, ich, true, 9600, "N,8,1", "COM1", "COM1", 500, 60);
                            m_ucIT.ControlEnabled = false;
                            m_ucIT_List.Add(m_ucIT);
                        }
                        //-
                        //-

                        WriteSystemLog("// Insulation Tester Setting : Ch = " + (ich + 1).ToString() + " // COMPORT = " + m_IT_Comport[ich].ToString() + 
                                        " // Relay ComPort = " + m_IT_Relay_Comport[ich].ToString() + " // Test Voltage=" + m_IT_TestVoltage[ich].ToString() + "(V)" +
                                        " // Test Time=" + m_IT_TestTime[ich].ToString() + "(Sec)");
                            
                    }
                }
            }
            //-


            // -----------------
            // + 230911, BGH
            // 231126 주석처리함, 이유:더이상 사용하지 않음.
            //string strlogintv = inifile.GetIniValue("LOGGING_SETTING", "INTERVAL_COUNT", "5");
            //log_intv_count = 5;
            //int.TryParse(strlogintv, out log_intv_count);
            //if (log_intv_count <  1) log_intv_count = 5;
            //if (log_intv_count > 10) log_intv_count = 5;


            // -------------------------------
            // tVOC - 위에서 여기로 이동함.
            // BGH 231114
            // -------------------------------
            //+ Revision by KGY - 20241206 : 절연저항기 설정 값 load변경(ini -> SysSetting)
            //+ Revisioin by LBG - 240520 : MTVD v2로 변경하여 해당 제어 Class 변경
            #region MTVD 이전 연동 코드

            m_tVOCEnable = m_clsSys_Set.m_bUse_MTVD;

            if (m_tVOCEnable)
            {
                WriteSystemLog("// tVOC Enable=True");

                int tvcount = 0;
                m_NumOftVOC = 0;

                tvcount = m_clsSys_Set.m_Sys_MTVD.Count;
                m_NumOftVOC = tvcount;
                
                string n_sMTVD_Type = m_clsSys_Set.m_Sys_MTVD[0].MTVD_Model;
                int n_iMTVD_Type = 0;   // 0: MTVDv1, 1:MTVDv2

                if (n_sMTVD_Type == "MTVDv1")
                {
                    n_iMTVD_Type = 0;
                    m_iMTVD_Type = n_iMTVD_Type;
                }
                else if(n_sMTVD_Type == "MTVDv2")
                {
                    n_iMTVD_Type = 1;
                    m_iMTVD_Type = n_iMTVD_Type;
                }

                if (n_iMTVD_Type == 0)
                {
                    m_ucTVocSOCList = new List<cls_devLeakingSocket>();

                    if (tvcount > 0 && tvcount < 12)
                    {
                        m_NumOftVOC = tvcount;

                        for (int ml = 0; ml < tvcount; ml++)
                        {
                            sysstr = "// tVOC Device #" + (ml + 1).ToString();

                            strCh = m_clsAppSet.Option_Set.MTVDv1_Model;  // MTVER1:TCPIP, MTVEr2:Serial
                            if (strCh == "MTVER2")
                            {
                                // Serial
                            }
                            else
                            {
                                // TcpIp
                                strCh = m_clsSys_Set.m_Sys_MTVD[ml].MTVD_IP;
                                if (strCh != "" && strCh.Length > 8)
                                {
                                    cls_devLeakingSocket m_clstvoc = new cls_devLeakingSocket(this);
                                    m_clstvoc.tVOC_Device_Index = (ml + 1);
                                    m_clstvoc.OnReadtVOCData += GottVOC_Socket;
                                    m_clstvoc.datalog_path = Application.StartupPath + "\\device";  // logging folder, bgh

                                    m_clstvoc.strTCPIP = strCh;
                                    m_clstvoc.Start_tVOC();

                                    sysstr = sysstr + "// tVOC Setting=" + strCh;
                                    m_ucTVocSOCList.Add(m_clstvoc);
                                }
                            }
                            sysstr = sysstr + " // No Valid vTOC Device";
                            WriteSystemLog(sysstr);
                        }
                        if (m_ucTVocSOCList.Count() < 1) { m_tVOCEnable = false; }
                    }
                    else { m_tVOCEnable = false; }
                }
                #endregion
                #region 신규 MTVD v2 연동
                else if (n_iMTVD_Type == 1)
                {
                    if (m_NumOftVOC > 0)
                    {
                        string n_tVOC_Chk_Val = m_clsSys_Set.m_Sys_MTVD[0].MTVD_VOC;
                        if (!uint.TryParse(n_tVOC_Chk_Val, out m_tVOC_Chk_Val))
                        {
                            m_tVOC_Chk_Val = 35000;
                        }

                        for (int i = 0; i < m_NumOftVOC; i++)
                        {
                            //+ Revision by LBG - 250626 : 설정값은 다 가져오기 위해서 주석 처리
                            //if (m_clsSys_Set.m_Sys_MTVD[i].MTVD_Use)
                            //-
                            {
                                sysstr = "// tVOC Device #" + (i + 1).ToString();

                                string n_sMTVD_Addr = m_clsSys_Set.m_Sys_MTVD[i].MTVD_IP;
                                m_tVOC_Addr.Add(n_sMTVD_Addr);
                                sysstr = sysstr + "// IP_Address=" + strCh;

                                string n_sMTVD_Port = m_clsSys_Set.m_Sys_MTVD[0].MTVD_Port;
                                int n_iPort_No = 0;

                                if (!int.TryParse(n_sMTVD_Port, out n_iPort_No))
                                {
                                    n_iPort_No = 8000;
                                }
                                m_tVOC_Port.Add(n_iPort_No);
                                sysstr = sysstr + "// Port_No=" + n_iPort_No.ToString();
                            }
                        }

                        bool n_bExist_MTVD = true;

                        for(int i = 0; i < m_tVOC_Addr.Count; i++)
                        {
                            try
                            {
                                System.Net.NetworkInformation.Ping n_Ping_Test = new System.Net.NetworkInformation.Ping();
                                System.Net.NetworkInformation.PingReply n_Ping_Reply = n_Ping_Test.Send(m_tVOC_Addr[i], 500);

                                if (n_Ping_Reply.Status != System.Net.NetworkInformation.IPStatus.Success)
                                {
                                    n_bExist_MTVD = false;
                                    break;
                                }
                            }
                            catch (System.Net.NetworkInformation.PingException ex_Ping)
                            {
                                n_bExist_MTVD = false;

                                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex_Ping.StackTrace, ex_Ping.Message);
                                Write_Log("Mainframe.Mainframe_Load", n_sDebugMsg);
                            }
                            catch (Exception ex)
                            {
                                n_bExist_MTVD = false;

                                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                                Write_Log("Mainframe.Mainframe_Load", n_sDebugMsg);
                            }
                        }

                        if (n_bExist_MTVD)
                        {
                            m_cls_devMTVD_V2 = new cls_devMTVD_V2(this);
                            WriteSystemLog(sysstr);
                        }
                        else
                        {
                            sysstr = sysstr + "Not exist MTVD.";
                            WriteSystemLog(sysstr);
                        }
                    }
                    else
                    {
                        m_tVOCEnable = false;
                        WriteSystemLog("// MTVDv2 Enable = False : Not Setting");
                    }
                }
            }
            #endregion
            //-

            #endregion

            // -------------------------------------------
            // Current Range
            // 보통은 3 Range, MAX 5 Range
            // -------------------------------------------
            //double d_cr = 0;
            //string strRange = "";
            //string strCR = "";

            // m_CurrentRange = new List<double>();            
            // ------------------------------------------------------
            // 높은 구간부터 저장
            // 예) Range1:0~10A, Range2:10~20A, Range3:20~30A 이면
            // Range3 --> Range2 --> Range1 순서로 Add
            // index 0 부터, 30, 20, 10의 순서로 저장됨.
            // ------------------------------------------------------
            //for (int i = 5; i > 0; i--)
            //{
            //    d_cr = 0;
            //    strRange = "#RANGE_" + i.ToString();
            //    strCR = inifile.GetIniValue("RANGE_SETTING", strRange, "0");

            //    if (double.TryParse(strCR, out d_cr))
            //    {
            //        m_CurrentRange.Add(d_cr);
            //    }                
            //}
            //if (m_ucCycler_ABT_List != null)
            //{
            //    for (int i = 0; i < m_ucCycler_ABT_List.Count; i++)
            //    {
            //        m_ucCycler_ABT_List[i].CurrentRange = m_CurrentRange;
            //    }
            //}

            // -------------------------------------------
            // AlarmLog
            // -------------------------------------------
            string m_logpath = Application.StartupPath + "\\log";
            string fldpath = m_logpath + "\\Alarm\\" + DateTime.Now.ToString("yyyy_MM_dd");
            try
            {
                DirectoryInfo di = new DirectoryInfo(fldpath);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            // ghbaik :  cvs --> cyc
            fldpath = fldpath + "\\Alarmlog_" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".log";
            logAlarm = new StreamWriter(fldpath, true, System.Text.Encoding.UTF8);
            string mtitle = "Timestamp,Ch,Code,Type,Message";
            WriteAlarmLog(mtitle);

            // -------------------------------------------
            // 신성도 대리 요청으로 만듦 23.08.11
            // -------------------------------------------
            toolTip.AutoPopDelay = 5000;
            toolTip.InitialDelay = 500;
            toolTip.ReshowDelay = 500;
            toolTip.ShowAlways = true;
            toolTip.IsBalloon = false;

            toolTip.SetToolTip(this.bt_BuzzerStop , "Chamber Venting");
            toolTip.SetToolTip(this.bt_EMG, "Stop All Channels");

            // ----------------------------------------------
            // Start Timer
            // ----------------------------------------------
            Timer10ms.Start();
            Timer100ms.Start();


            //+ Revision by LBG - 231124 : Timer에서 Delay 발생으로 채널 정보를 별도로 표시하는 기능 추가
            m_Tmr_Channel_Disp_Detail = new sysTimer(m_Tmr_Channel_Disp_Detail_Tick, null, 1000, 1000);
            //-

            // ---------------------------------------------------
            // 240102, BGH
            // ---------------------------------------------------
            for (int i = 0; i < m_ucMbT_List.Count; i++)
            {
                int midx = m_clsSys_Link.Get_MBT_Index(i);

                if (m_clsSys_Set.m_Sys_MBT == null) midx = -1;
                else
                {
                    if (m_clsSys_Set.m_Sys_MBT.Count < 1) midx = -1;
                }

                // ----------------------------------------
                // 240115 BGH
                // ControlEnabled 추가
                // ----------------------------------------
                //+ Revision by YMJ - 240530 : MBT 비활성화 했을 경우에도 ControlEnabled가 false가 되도록 변경
                if (midx < 0 || !m_clsSys_Set.m_Sys_MBT[midx].MBT_Use)
                    //-
                {
                    m_ucMbT_List[i].ControlEnabled = false;
                }
                else
                {
                    m_ucMbT_List[i].ControlEnabled = true;

                    m_ucMbT_List[i].strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_IP;
                    //+ Revision by YMJ - 240215 : MBT 통신 PORT 장비 등록 시 등록된 값 가져오기로 변경
                    m_ucMbT_List[i].strTCPPort = m_clsSys_Set.m_Sys_MBT[midx].MBT_TCP_Port.ToString();
                    //-

                    //+ Revision by YMJ - 240328 : MBT 통신 사용 체크 했을 시만 연결 테스트
                    if (m_clsSys_Set.m_bUse_MBT && m_clsSys_Set.m_Sys_MBT[midx].MBT_Use)
                    {
                        ConnectionTestMBT(i);
                    }
                    //-

                    #region COmmect
                    //m_ucMbT_List[i].RetryCount = 1;
                    //if (m_ucMbT_List[i].isConnected)
                    //{
                    //    m_ucMbT_List[i].STOPAcia();
                    //    m_ucMbT_List[i].DisCoNnect();
                    //}

                    //// -------------------------------------------
                    //// 240109 BGH
                    //// 5초후에 Disconnect 할것.
                    //// -------------------------------------------
                    //m_ucMbT_List[i].AutoDisconnect = true;
                    //// m_ucMbT_List[i].ConnectionChecking = true;

                    //m_ucMbT_List[i].CONnect();
                    //m_timelimit[i] = -1;
                    #endregion

                }
            }

            //+ Revision by KGY -250428 : 설정 옵션 로드 변경 (ini -> AppSetting)
            //+ Add by YMJ - 250410 : UDP 통신 기능 추가
            //string n_UDP_Endable = inifile.GetIniValue("UDP_SETTING", "ENABLE", "FALSE");
            //+ Add by KGY -250508 : Table Row가 없을경우 오류 방지 추가
            if (m_clsSys_Set.m_Sys_UDP.Count > 0)
            {
                bool n_UDP_Endable = m_clsSys_Set.m_Sys_UDP[0].UDP_Enable;
                if (n_UDP_Endable)
                {
                    m_udpClient = new UdpClient();
                    m_udpClientSend = true;

                    //string n_sUDP_Addr = inifile.GetIniValue("UDP_SETTING", "SERVER_IP", "127.0.0.1");
                    string n_sUDP_Addr = m_clsSys_Set.m_Sys_UDP[0].UDP_Server_IP;
                    //string n_sUDP_Port = inifile.GetIniValue("UDP_SETTING", "SERVER_PORT", "9000");
                    string n_sUDP_Port = m_clsSys_Set.m_Sys_UDP[0].UDP_Server_Port;

                    IPAddress n_ipUDP_Addr;

                    if (!IPAddress.TryParse(n_sUDP_Addr, out n_ipUDP_Addr))
                    {
                        n_ipUDP_Addr = IPAddress.Parse("127.0.0.1");
                    }

                    int n_iUDP_Port = 9000;

                    if (!int.TryParse(n_sUDP_Port, out n_iUDP_Port))
                    {
                        n_iUDP_Port = 9000;
                    }

                    //string n_sSend_Interval = inifile.GetIniValue("UDP_SETTING", "STATE_SEND_INTERVAL", "1000");

                    //if (!int.TryParse(n_sSend_Interval, out m_UDPSend_Interval))
                    //{
                    //    m_UDPSend_Interval = 1000;
                    //}

                    m_UDPSend_Interval = m_clsSys_Set.m_Sys_UDP[0].UDP_State_Send_Interval;

                    m_udpIPEndPoint = new IPEndPoint(n_ipUDP_Addr, n_iUDP_Port);

                    m_UDPSendThread = new Thread(new ThreadStart(startUDPSend_JTP));
                    m_UDPSendThread.IsBackground = true;
                    m_UDPSendThread.Start();
                }
            }
            //-
            //-
            //-
        }

        //+ Add by YMJ - 250410 : 제주TP용 UDP 통신 기능 추가
        public void startUDPSend_JTP()
        {
            while (m_udpClientSend)
            {
                try
                {
                    for (int ch = 0; ch < IsOnTesting.Length; ch++)
                    {
                        int boardid = Board_Ch_Mapping[ch];
                        int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
                        string message = "ABT," + (ch + 1).ToString() + ",";
                        if (m_ucCycler_ABT_List[boardid].isConnected)
                        {
                            cls_devCyclerABT.struCyclerStatus cyInfo = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];

                            message = message + cyInfo.m_step.steptype.ToString();
                        }
                        else
                        {
                            message = message + "DisConnect";
                        }
                        byte[] data = Encoding.UTF8.GetBytes(message);
                        m_udpClient.Send(data, data.Length, m_udpIPEndPoint);
                    }
                }
                catch (Exception ex)
                {
                    string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                    Write_Log("startUDPSend_JTP", n_sDebugMsg);
                }
                Thread.Sleep(m_UDPSend_Interval);
            }
        }
        //-
		//Add by KGY - 250325 : DAU cnt update 추가
        public void DAU_VT_Recount()
        {
            int maxnum_v = 0, maxnum_t = 0;
            //int maxnum_m = 0;
            if (m_voltcount_dau != null && m_tempcount_dau != null)
            {
                for (int i = 0; i < Get_CH_Cnt; i++)
                {
                    m_voltcount_dau[i] = 0;
                    m_tempcount_dau[i] = 0;
                    int DAUno = m_clsSys_Link.Get_DAU_Index(i);

                    if (DAUno >= 0 && m_clsSys_Set.m_Sys_DAU.Count > DAUno)
                    {
                        Sys_Set_DAU n_Sys_DAU = m_clsSys_Set.m_Sys_DAU[DAUno];
                        if (n_Sys_DAU.DAU_Multi_Use) // 멀티 사용 모드
                        {
                            if (m_frmDAU_Set.m_DAU_MultiUse_ChMapping.TryGetValue(DAUno, out Dictionary<string, List<int>> n_AI))
                            {
                                foreach (string AIName in n_AI.Keys)
                                {
                                    List<int> chList = n_AI[AIName];

                                    if (chList[0] == i && AIName.Contains("V"))
                                    {
                                        if (m_frmDAU_Set.m_DAU_AI_CellUse.ContainsKey(DAUno))
                                        {
                                            if (m_frmDAU_Set.m_DAU_AI_CellUse[DAUno].ContainsKey(AIName))
                                            {
                                                foreach (bool use in m_frmDAU_Set.m_DAU_AI_CellUse[DAUno][AIName])
                                                {
                                                    if (use)
                                                    {
                                                        m_voltcount_dau[i]++;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (chList.Count > 0 && AIName.Contains("T")) //T1
                                    {
                                        foreach (int ch in chList)
                                        {
                                            if (ch == i)
                                            {
                                                if (m_frmDAU_Set.m_DAU_Multi_TempType.ContainsKey(DAUno))
                                                {
                                                    if (m_frmDAU_Set.m_DAU_Multi_TempType[DAUno].ContainsKey(ch))
                                                    {
                                                        string tempType = m_frmDAU_Set.m_DAU_Multi_TempType[DAUno][ch][0];
                                                        if (tempType == "NTC" || tempType == "BOTH")
                                                        {
                                                            if (m_frmDAU_Set.m_DAU_AI_CellUse.ContainsKey(DAUno))
                                                            {
                                                                string Key = "NTC_" + AIName;
                                                                if (m_frmDAU_Set.m_DAU_AI_CellUse[DAUno].ContainsKey(Key))
                                                                {
                                                                    //+ Revision by KGY -250528 : 채널별 전압 온도개수 계산시오류 수정
                                                                    int n_splitcnt = (n_Sys_DAU.DAU_Temp_MultiCnt > 0) ? (16 / n_Sys_DAU.DAU_Temp_MultiCnt) : 16;
                                                                    int n_remain = ch % n_Sys_DAU.DAU_Temp_MultiCnt;
                                                                    int m_startIdx = (n_Sys_DAU.DAU_Temp_MultiCnt == 1) ? 0 : (n_splitcnt * n_remain);
                                                                    //-
                                                                    for (int n_iAICellNo = m_startIdx; n_iAICellNo < m_startIdx + n_splitcnt; n_iAICellNo++)
                                                                    {
                                                                        if (m_frmDAU_Set.m_DAU_AI_CellUse[DAUno][Key][n_iAICellNo])
                                                                        {
                                                                            m_tempcount_dau[ch]++;
                                                                        }
                                                                    }

                                                                }
                                                            }
                                                        }
                                                        if (tempType == "K" || tempType == "BOTH")
                                                        {
                                                            if (m_frmDAU_Set.m_DAU_AI_CellUse.ContainsKey(DAUno))
                                                            {
                                                                string Key = "K_" + AIName;
                                                                if (m_frmDAU_Set.m_DAU_AI_CellUse[DAUno].ContainsKey(Key))
                                                                {
                                                                    //+ Revision by KGY -250528 : 채널별 전압 온도개수 계산시오류 수정
                                                                    int n_splitcnt = 16 / n_Sys_DAU.DAU_Temp_MultiCnt;
                                                                    int n_remain = ch % n_Sys_DAU.DAU_Temp_MultiCnt;
                                                                    int m_startIdx = (n_Sys_DAU.DAU_Temp_MultiCnt == 1) ? 0 : (n_splitcnt * n_remain);
                                                                    //-
                                                                    for (int n_iAICellNo = m_startIdx; n_iAICellNo < m_startIdx + n_splitcnt; n_iAICellNo++)
                                                                    {
                                                                        if (m_frmDAU_Set.m_DAU_AI_CellUse[DAUno][Key][n_iAICellNo])
                                                                        {
                                                                            m_tempcount_dau[ch]++;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            //+ Revision by KGY -2500411 : 단독모드 전압,온도 개수 재설정
                            int n_voltcount = 0;
                            int n_tempcount = 0;
                            if (m_frmDAU_Set.m_DAU_AI_CellUse.TryGetValue(DAUno, out Dictionary<string, List<bool>> n_CellUse))
                            {
                                foreach (string AIName in n_CellUse.Keys)
                                {
                                    if (AIName.Contains("V"))
                                    {
                                        foreach (bool use in n_CellUse[AIName])
                                        {
                                            if (use)
                                            {
                                                n_voltcount++;
                                            }
                                        }
                                    }
                                    else if (AIName.Contains("T"))
                                    {
                                        switch (n_Sys_DAU.DAU_Temp_Type)
                                        {
                                            case 0:
                                                if (AIName.Contains("NTC"))
                                                {
                                                    foreach (bool use in n_CellUse[AIName])
                                                    {
                                                        if (use)
                                                        {
                                                            n_tempcount++;
                                                        }
                                                    }
                                                }
                                                break;
                                            case 1:
                                                if (AIName.Contains("K"))
                                                {
                                                    foreach (bool use in n_CellUse[AIName])
                                                    {
                                                        if (use)
                                                        {
                                                            n_tempcount++;
                                                        }
                                                    }
                                                }
                                                break;
                                            case 2:
                                                foreach (bool use in n_CellUse[AIName])
                                                {
                                                    if (use)
                                                    {
                                                        n_tempcount++;
                                                    }
                                                }
                                                break;
                                        }
                                    }
                                }
                            }
                            n_Sys_DAU.DAU_Voltage_Count = n_voltcount;
                            m_voltcount_dau[i] = n_voltcount;
                            n_Sys_DAU.DAU_Temp_Count = n_tempcount;
                            m_tempcount_dau[i] = n_tempcount;

                            m_TypeOfTemp[i] = n_Sys_DAU.DAU_Temp_Type;
                            string n_NTCPath = "";
                            if (n_Sys_DAU.DAU_NTC != null && n_Sys_DAU.DAU_NTC != "")
                            {
                                n_NTCPath = Get_StartPath + "\\NTC\\" + n_Sys_DAU.DAU_NTC;
                            }
                            if (m_dDAU_NTC_Path.ContainsKey(i)) { m_dDAU_NTC_Path[i] = n_NTCPath; } else { m_dDAU_NTC_Path.Add(i, n_NTCPath); }

                            m_clsSys_Set.Save_System_Setting();
                            //-
                        }
                    }
                    else
                    {
                        m_voltcount_dau[i] = 0;
                        m_tempcount_dau[i] = 0;
                        m_TypeOfTemp[i] = 0;
                    }
                }

                for (int k = 0; k < Get_CH_Cnt; k++)
                {
                    if (m_voltcount_dau[k] > maxnum_v) maxnum_v = m_voltcount_dau[k];
                    if (m_tempcount_dau[k] > maxnum_t) maxnum_t = m_tempcount_dau[k];
                    //if (m_NumOfModule[k] > maxnum_m) maxnum_m = m_NumOfModule[k];

                }
                if (m_ucDAU_List.Count > 0)
                {
                    m_ucDAU_List[0].GET_NTC_Path();
                }
            }
        }
		//-
        // ------------------------------------------------------------
        // 240122 BGH
        // ------------------------------------------------------------
        public void ConnectionTestMBT(int ch)
        {
            if (m_clsSys_Set.m_Sys_MBT == null) return;
            if (m_clsSys_Set.m_Sys_MBT.Count < 1) return;

            if (m_ucMbT_List == null) return;
            if (m_ucMbT_List.Count > ch)
            {
                if (m_ucMbT_List[ch].ControlEnabled)
                {
                    m_ucMbT_List[ch].RetryCount = 1;
                    if (m_ucMbT_List[ch].isConnected)
                    {
                        m_ucMbT_List[ch].STOPAcia();
                        m_ucMbT_List[ch].DisCoNnect();
                    }

                    // -------------------------------------------
                    // 240109 BGH
                    // 5초후에 Disconnect 할것.
                    // -------------------------------------------
                    m_ucMbT_List[ch].AutoDisconnect = true;
                    // m_ucMbT_List[ch].ConnectionChecking = true;

                    m_ucMbT_List[ch].CONnect();
                    m_timelimit[ch] = -1;
                }
            }
        }

        private void FillWorkNames(int mChCNt)
        {
            string mstr1 = "", mstr2 = "";
            for (int i = 0; i < mChCNt; i++)
            {
                string flpath = Application.StartupPath + "\\log\\Data\\CH" + (i + 1).ToString("D3") + "_Status_SNapShot.cst";
                try
                {
                    if (File.Exists(flpath))
                    {
                        using (StreamReader logchst = new StreamReader(flpath, System.Text.Encoding.UTF8))
                        {
                            string msg = logchst.ReadLine();

                            var rlist = msg.Split(',');
                            if (rlist == null) return;

                            mstr1 = rlist[rlist.Length - 2].Trim();
                            mstr2 = rlist[rlist.Length - 1].Trim();

                            if (mstr1.Length > 1 && mstr2.Length > 1)
                            {
                                sche_names[i] = mstr1;
                                work_names[i] = mstr2;
                            }
                        }
                    }

                }
                catch //(Exception ex)
                { }
            }
        }

        private void MainMenuItem_Click(object sender, EventArgs e)
        {
            ToolStripMenuItem n_MenuItem = (ToolStripMenuItem)sender;

            //+ Revision by YMJ - 241217 : 메뉴 개선
            switch (n_MenuItem.Tag)
            {
                #region Menu : File
                //+ Menu : File
                case Def_Menu.File_Captuer:
                    Export_Chart_Image();
                    break;
                case Def_Menu.File_Quit:
                    this.Close();
                    break;
                //-
                #endregion

                #region Menu : Edit
                //+ Menu : Edit
                //-
                #endregion

                #region Menu : Controls
                //+ Menu : Controls
                case Def_Menu.Control_Start:
                    //+ Revision by YMJ - 250131 : Start_Schedule Type 추가
                    Start_Schedule(0);
                    //-
                    break;
                case Def_Menu.Control_Stop:
                    Schedule_Stop();
                    break;
                case Def_Menu.Control_Reserve:
                    break;
                case Def_Menu.Control_Pause_Pause:
                    break;
                case Def_Menu.Control_Pause_StepC:
                    break;
                case Def_Menu.Control_Pause_CycC:
                    break;
                case Def_Menu.Control_Pause_IoopC:
                    break;
                case Def_Menu.Control_Pause_ETC:
                    break;
                case Def_Menu.Control_Pause_Cancel:
                    break;
                case Def_Menu.Control_Resume:
                    break;
                case Def_Menu.Control_Next:
                    Next_Step();
                    break;
                case Def_Menu.Control_Move:
                    break;
                case Def_Menu.Control_Reset:
                    break;
                case Def_Menu.Control_Schedule:
                    bt_CH_Work_Schedule_Click(null, null);
                    break;
                case Def_Menu.Control_Graph_Cycler:
                    bt_CH_Graph_RT_Cycler_Click(null, null);
                    break;
                case Def_Menu.Control_Graph_ACIA:
                    bt_CH_Graph_RT_ACIA_Click(null, null);
                    break;
                //-
                #endregion

                #region Menu : Setting
                //+ Menu - Setting
                case Def_Menu.Set_Sys:
                    frmSetting_View();
                    break;
                case Def_Menu.Set_SysLink:
                    frmSetting_Link_View();
                    break;
                case Def_Menu.Set_UserOpt:
                    break;
                case Def_Menu.Set_ChCode:
                    break;
                case Def_Menu.Set_Parallel:
                    break;
                case Def_Menu.Set_AUX:
                    frmAUX_Set_View();
                    break;
                case Def_Menu.Set_DAU:
                    frmDAU_Set_View();
                    break;
                //-
                #endregion

                #region Menu : Schedule
                //+ Menu - Schedule
                case Def_Menu.Sche_Manager:
                    frmRecipe_View();
                    break;
                case Def_Menu.Sche_Data:
                    break;
                case Def_Menu.Sche_LosData:
                    break;
                case Def_Menu.Sche_Network:
                    break;
                //-
                #endregion

                #region Menu : View
                //+ Menu - View
                case Def_Menu.View_Data:
                    if(m_iCur_CH_NO >= 0)
                    {
                        System.Diagnostics.Process.Start(Application.StartupPath + "\\Data\\" + work_names[m_iCur_CH_NO]);
                    }
                    else
                    {
                        System.Diagnostics.Process.Start(Application.StartupPath + "\\Data");
                    }
                    break;
                case Def_Menu.View_Schedule:
                    break;
                case Def_Menu.View_Work:
                    System.Diagnostics.Process.Start(Application.StartupPath + "\\log");
                    break;
                case Def_Menu.View_System:
                    System.Diagnostics.Process.Start(Application.StartupPath + "\\System");
                    break;
                case Def_Menu.View_Device:
                    System.Diagnostics.Process.Start(Application.StartupPath + "\\device");
                    break;
                case Def_Menu.View_Reserve:
                    break;
                case Def_Menu.View_Connection:
                    break;
                //-
                #endregion

                #region Menu : Language
                //+ Menu - Language
                case Def_Menu.Lang_Kor:
                    //+ Add by LBG - 230330 : 언어 변경 관련 함수 호출
                    m_SysLanguage = LanguageType.KOREAN;
                    {
                        clsLang_Conv n_clsLang_Conv = new clsLang_Conv(this, this, this.Get_StartPath + "\\Language\\Define_Language.xml");
                    }

                    m_ucBoard_Status.Set_Language();
                    m_ucChannel_Status.Set_Language();

                    m_clsAppSet.APP_LANGUAGE = m_SysLanguage;
                    m_clsAppSet.Save_App_Setting();
                    //-
                    break;
                case Def_Menu.Lang_Eng:
                    m_SysLanguage = LanguageType.ENGLISH;
                    {
                        clsLang_Conv n_clsLang_Conv = new clsLang_Conv(this, this, this.Get_StartPath + "\\Language\\Define_Language.xml");
                    }

                    m_ucBoard_Status.Set_Language();
                    m_ucChannel_Status.Set_Language();

                    m_clsAppSet.APP_LANGUAGE = m_SysLanguage;
                    m_clsAppSet.Save_App_Setting();
                    break;
                //-
                #endregion

                #region Menu : Help
                //+ Menu - Help
                case Def_Menu.Help_Folder:
                    System.Diagnostics.Process.Start(Application.StartupPath);
                    break;
                case Def_Menu.Help_About:
                    Show_About();
                    break;
                    //-
                    #endregion
            }
            //-
        }

        //+ Add By YMJ - 241217 : 화면 캡처 함수 추가
        private void Export_Chart_Image()
        {
            SaveFileDialog n_dlg = new SaveFileDialog();
            n_dlg.Filter = "Image File (*.png)|*.png";

            if (n_dlg.ShowDialog() == DialogResult.OK)
            {
                Bitmap bitmap = new Bitmap(tlp_MainBase.Width, tlp_MainBase.Height);
                tlp_MainBase.DrawToBitmap(bitmap, new Rectangle(0, 0, tlp_MainBase.Width, tlp_MainBase.Height));
                bitmap.Save(n_dlg.FileName, System.Drawing.Imaging.ImageFormat.Png);

                MessageBox.Show("The screen image has been saved successfully.", "ABTProV2", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }
        //-

        private void frmSetting_View()
        {
            //+ Revision by LBG - 230410 : frmSystem_Setting 창이 활성화 되어 있을 경우 앞으로 가져오기 추가
            //frmSystem_Setting n_frmSys_Set = new frmSystem_Setting(m_clsSys_Set, this);
            //n_frmSys_Set.WindowState = FormWindowState.Normal;
            //n_frmSys_Set.StartPosition = FormStartPosition.CenterParent;

            ////n_frmSys_Set.OnBoardInfoUpdated += ReNewBoardInformation;

            //n_frmSys_Set.ShowDialog();
            //+ Add by KGY -20241230 : 작업 중일 경우 Setting 변경 불가
            for (int ch = 0; ch < m_Tot_Ch_Count; ch++)
            {
                if (IsOnTesting[ch])
                {
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        MessageBox.Show("진행 중인 작업이 있습니다. \n설정을 변경 하시려면 작업을 정지 후 진행하여 주시길 바랍니다.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    else
                    {
                        MessageBox.Show("There is work in progress. If you want to change the settings, please stop the operation before proceeding.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    return;
                }
            }
            //-
            Form n_Form = Application.OpenForms["frmSystem_Setting"];

            if (n_Form == null)
            {
                frmSystem_Setting n_frmSys_Set = new frmSystem_Setting(m_clsSys_Set, this);
                n_frmSys_Set.WindowState = FormWindowState.Normal;
                n_frmSys_Set.StartPosition = FormStartPosition.CenterParent;

                //n_frmSys_Set.OnBoardInfoUpdated += ReNewBoardInformation;

                n_frmSys_Set.ShowDialog();
            }
            else
            {
                if (n_Form.WindowState == FormWindowState.Minimized)
                {
                    n_Form.WindowState = FormWindowState.Maximized;
                }
                n_Form.Activate();
            }
            //-
        }

        private void frmSetting_Link_View()
        {
            //+ Revision by LBG - 230410 : frmSystem_Link 창이 활성화 되어 있을 경우 앞으로 가져오기 추가
            //frmSystem_Link n_frmSys_Link = new frmSystem_Link(m_clsSys_Link, m_clsSys_Set);
            //n_frmSys_Link.WindowState = FormWindowState.Normal;
            //n_frmSys_Link.StartPosition = FormStartPosition.CenterParent;

            //n_frmSys_Link.ShowDialog();
            //+ Add by KGY -20241230 : 작업 중일 경우 Setting 변경 불가
            for (int ch = 0; ch < m_Tot_Ch_Count; ch++)
            {
                if (IsOnTesting[ch])
                {
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        MessageBox.Show("진행 중인 작업이 있습니다. \n설정을 변경 하시려면 작업을 정지 후 진행하여 주시길 바랍니다.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    else
                    {
                        MessageBox.Show("There is work in progress. If you want to change the settings, please stop the operation before proceeding.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    return;
                }
            }
            //-
            Form n_Form = Application.OpenForms["frmSystem_Link"];

            if (n_Form == null)
            {
                frmSystem_Link n_frmSys_Link = new frmSystem_Link(m_clsSys_Link, m_clsSys_Set, this);
                n_frmSys_Link.WindowState = FormWindowState.Normal;
                n_frmSys_Link.StartPosition = FormStartPosition.CenterParent;

                n_frmSys_Link.ShowDialog();
            }
            else
            {
                if (n_Form.WindowState == FormWindowState.Minimized)
                {
                    n_Form.WindowState = FormWindowState.Maximized;
                }
                n_Form.Activate();
            }
            //-
        }

        private void frmAUX_Set_View()
        {
            //+ Revision by LBG - 230410 : frmAUX_Set 창이 활성화 되어 있을 경우 앞으로 가져오기 추가
            //frmAUX_Set n_frmAUX_Set = new frmAUX_Set(this);
            //n_frmAUX_Set.WindowState = FormWindowState.Normal;
            //n_frmAUX_Set.StartPosition = FormStartPosition.CenterParent;

            //n_frmAUX_Set.ShowDialog();
            Form n_Form = Application.OpenForms["frmAUX_Set"];

            if (n_Form == null)
            {
                frmAUX_Set n_frmAUX_Set = new frmAUX_Set(this);
                n_frmAUX_Set.WindowState = FormWindowState.Normal;
                n_frmAUX_Set.StartPosition = FormStartPosition.CenterParent;

                n_frmAUX_Set.ShowDialog();
            }
            else
            {
                if (n_Form.WindowState == FormWindowState.Minimized)
                {
                    n_Form.WindowState = FormWindowState.Maximized;
                }
                n_Form.Activate();
            }
            //-
        }
        private void frmDAU_Set_View()
        {
            //+ Add by KGY -20241230 : 작업 중일 경우 Setting 변경 불가
            for (int ch = 0; ch < m_Tot_Ch_Count; ch++)
            {
                if (IsOnTesting[ch])
                {
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        MessageBox.Show("진행 중인 작업이 있습니다. \n설정을 변경 하시려면 작업을 정지 후 진행하여 주시길 바랍니다.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    else
                    {
                        MessageBox.Show("There is work in progress. If you want to change the settings, please stop the operation before proceeding.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    return;
                }
            }
            //-
            Form n_Form = Application.OpenForms["frmDAU_Set"];

            if (n_Form == null)
            {
                int n_DAULinkCNT = 0;
                for (int i = 0; i < m_clsSys_Link.m_Link_Info.Count; i++)
                {
                    Sys_Link n_Sys_Link = m_clsSys_Link.m_Link_Info[i];
                    if (n_Sys_Link.DAU_No >= 0)
                    {
                        n_DAULinkCNT++;
                        break;
                    }
                }
                int n_DAUUseCnt = 0;
                foreach(Sys_Set_DAU n_SysDau in m_clsSys_Set.m_Sys_DAU)
                {
                    if (n_SysDau.DAU_Use)
                    {
                        n_DAUUseCnt++;
                        break;
                    }
                }
                if (n_DAULinkCNT > 0 && n_DAUUseCnt > 0 && m_clsSys_Set.m_bUse_DAU)
                {
                    m_frmDAU_Set = new frmDAU_Set(this, m_clsSys_Set, m_clsSys_Link);
                    m_frmDAU_Set.WindowState = FormWindowState.Normal;
                    m_frmDAU_Set.StartPosition = FormStartPosition.CenterParent;

                    m_frmDAU_Set.ShowDialog();
                }
                else
                {
                    //+ Add by KGY - 250721 : 언어변경적용
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        MessageBox.Show("DAU 설정이 부족합니다.\n System Setting 및 Device Mapping 설정 확인 후 진행하여 주시길 바랍니다.", "ABT System", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        MessageBox.Show("DAU settings are lacking.\nPlease proceed after checking the system setting and Device Mapping settings.");
                    }
                    //-
                }

            }
            else
            {
                if (n_Form.WindowState == FormWindowState.Minimized)
                {
                    n_Form.WindowState = FormWindowState.Maximized;
                }
                n_Form.Activate();
            }
            //-
        }

        //+ Add by YMJ - 240411 : Scheduler Manage 프로그램 분할
        private void frmRecipe_View()
        {
            Process[] processList = Process.GetProcessesByName("ABT_Scheduler");
            if (processList.Length != 0)
            {
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show("이미 스케줄러 매니징 프로그램이 실행중입니다.");
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show("The scheduler management program is already running.");
                }
                
                return;
            }

            string fname = Get_StartPath + "\\ABT_Scheduler";
            string parastr = "";
            //string parastr = "\"" + csvfolder + "\" \"AUTOCON\"" + " \"" + Properties.Settings.Default.AciaIpAddress + "\"";
            //Process proc_acia = ExecuteProgram(fname, "");
            //Process.Start(fname, "");
            Trace.WriteLine(fname);
            Trace.WriteLine(System.Environment.CurrentDirectory);
            Process proc_cycler = ExecuteProgram(fname + ".exe", parastr);
            //invoke_type = false;
        }

        public Process ExecuteProgram(string filename, string parameter)
        {
            Process resProc = new Process();
            resProc.StartInfo = new ProcessStartInfo(filename, parameter);
            resProc.StartInfo.UseShellExecute = false;

            try
            {
                //resProc = Process.Start(filename, parameter);
                resProc.Start();
            }
            catch (Exception ex)
            {
                Trace.WriteLine(string.Format("{0}, {1}", ex.Message, filename));
                Trace.WriteLine(ex.StackTrace);
            }

            return resProc;
        }
        //-

        //+ Revision by YMJ - 250131 : 스케줄 시작 통일을 위해 타입을 부여하여 구분 ( 0 : Menu, 1 : Main, 2 : PopUp )
        private void Start_Schedule(int type)
        //-
        {
            
            // 만약 실행중이면,,,, 무시되어야 한다.
            WriteSystemLog("");

            //+ Revision by YMJ - 250131 : Type에 따른 동작 불가 로직 수정
            int selch = 0;
            bool rEnough = false;
            if (type == 0 || type == 1)
            {
                if(type == 0)
                {
                    WriteSystemLog(">> Start Work [Menu]");
                }
                else
                {
                    WriteSystemLog(">> Start Work [Main]");
                }
                if (m_SelCh4Schedule == null)
                {
                    WriteSystemLog(">> No SelCh4Schedule !!");
                    return;
                }

                if (IsOnTesting[m_iCur_CH_NO])
                {
                    WriteSystemLog(m_iCur_CH_NO, ">> No testing [Is not on test]", false);
                    return;
                }

                if (m_AlarmPopupList != null)
                {
                    bool bfound = false;
                    for (int i = 0; i < m_AlarmPopupList.Count; i++)
                    {
                        if (m_AlarmPopupList[i].CH_NO == (m_iCur_CH_NO + 1))
                        {
                            bfound = true;
                            break;
                        }
                    }

                    if (bfound)
                    {
                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "해당 채널의 알람 제거 후 스케줄을 시작해 주십시오.", "작업 시작", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Please remove the alarm for that channel you want to work on first.", "Start Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        }
                        WriteSystemLog(m_iCur_CH_NO, ">> No testing [Alarm exists]", false);
                        return;
                    }
                }
            }
            else if(type == 2)
            {
                WriteSystemLog(">> Start Work [PopUp]");
                rEnough = false;
                for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                {
                    selch = m_SelCh4Schedule[i];

                    if (!IsOnTesting[selch])
                    {
                        rEnough = true;
                        break;
                    }
                }
                if (!rEnough)
                {
                    WriteSystemLog(">> No running ch");
                    return;
                }

                for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                {
                    selch = m_SelCh4Schedule[i];

                    if (m_AlarmPopupList != null)
                    {
                        bool bfound = false;
                        for (int j = 0; j < m_AlarmPopupList.Count; j++)
                        {
                            if (m_AlarmPopupList[j].CH_NO == (selch + 1))
                            {
                                bfound = true;
                                break;
                            }
                        }

                        if (bfound)
                        {
                            if (SystemLanguage == LanguageType.KOREAN)
                            {
                                MessageBox.Show(new Form { TopMost = true }, "해당 채널의 알람 제거 후 스케줄을 시작해 주십시오.", "작업 시작", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            }
                            else if (SystemLanguage == LanguageType.ENGLISH)
                            {
                                MessageBox.Show(new Form { TopMost = true }, "Please remove the alarm for that channel you want to work on first.", "Start Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            }
                            WriteSystemLog(m_iCur_CH_NO, ">> No testing [Alarm exists]", false);
                            return;
                        }
                    }
                }
            }
            //-

            if (m_iCur_CH_NO >= 0)
            {
                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_iCur_CH_NO))
                {
                    WriteSystemLog(m_iCur_CH_NO, ">> Start test is Cancelled [Parallel slave channel]", true);
                    return;
                }
                //-

                //frmInput_Text n_frmInput_Text = new frmInput_Text("작업 이름을 입력하세요.");
                frmInput_Text n_frmInput_Text = null;
                string dfltWrkname = DateTime.Now.ToString("yyyyMMdd_HHmm");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    n_frmInput_Text = new frmInput_Text("작업 이름을 입력하세요.", this, dfltWrkname);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    n_frmInput_Text = new frmInput_Text("Please enter a work name.", this, dfltWrkname);
                }
                //-
                n_frmInput_Text.StartPosition = FormStartPosition.CenterParent;

                if (n_frmInput_Text.ShowDialog() == DialogResult.OK)
                {
                    frmRecipe_List n_frmRecipe_List = new frmRecipe_List(this);
                    n_frmRecipe_List.StartPosition = FormStartPosition.CenterParent;

                    n_frmRecipe_List.WORK_NAME = n_frmInput_Text.INPUT_TEXT;

                    if (n_frmRecipe_List.ShowDialog() == DialogResult.OK)
                    {
                        string n_sRecipe_Path = n_frmRecipe_List.RECIPE_PATH;

                        if (n_sRecipe_Path.Length > 0)
                        {
                            System.Text.RegularExpressions.Regex rgx = new System.Text.RegularExpressions.Regex("[^a-zA-Z0-9가-힣_]");
                            string fName = "";

                            for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                            {
                                selch = m_SelCh4Schedule[i];
                                if (!IsOnTesting[selch])
                                {
                                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                                    if (CheckParallelSlave(selch))
                                    {
                                        WriteSystemLog(selch, ">> Start test is Cancelled [Parallel slave channel]", true);
                                    }
                                    //-
                                    else
                                    {
                                        //+ Add by YMJ - 251028 : 스케줄명 및 작업명 공백 처리 추가
                                        work_names[selch] = n_frmRecipe_List.WORK_NAME.Trim();
	                                    sche_names[selch] = Path.GetFileNameWithoutExtension(n_sRecipe_Path).Trim();
                                        //-
	                                    sche_names_restart[selch] = n_sRecipe_Path;
	                                    Recipe_Files[selch] = n_sRecipe_Path;
	
	                                    //+ Add by LBG -230308 : 작업 로그명 설정 기능 추가
	                                    //SelectedStepInfoFile(m_SelCh4Schedule[i], n_sRecipe_Path, work_names[m_SelCh4Schedule[i]]);
	                                    fName = "";
	                                    if (n_frmRecipe_List.LOG_OPT_USE_WorkNm) fName += ("_" + work_names[selch]);
	                                    if (n_frmRecipe_List.LOG_OPT_USE_Schedule) fName += ("_" + sche_names[selch]);
	                                    if (n_frmRecipe_List.LOG_OPT_USE_UserInput && n_frmRecipe_List.LOG_OPT_USER_INPUT.Trim().Length > 0) fName += ("_" + n_frmRecipe_List.LOG_OPT_USER_INPUT);
	                                    if (n_frmRecipe_List.LOG_OPT_USE_Time) fName += ("_" + DateTime.Now.ToString("yyyyMMdd_HHmmss"));
	                                    m_Log_Opt_File[selch] = rgx.Replace(fName, "");
	
	                                    //+ Add By LBG - 230921 : 작업 Step 설정 기능 추가
	                                    if (m_Work_Step_Set != null && m_Work_Step_Set.ContainsKey(selch))
	                                    {
	                                        m_Work_Step_Set[selch] = n_frmRecipe_List.WORK_SET;
	                                    }
	                                    else
	                                    {
	                                        m_Work_Step_Set.Add(selch, n_frmRecipe_List.WORK_SET);
	                                    }
	                                    //-
	
	                                    SelectedStepInfoFile(selch, n_sRecipe_Path, work_names[selch]); //, m_Log_Opt_File[i]);
	                                    WriteSystemLog(selch, ">> Start test [W:" + work_names[selch] + ", S:" + sche_names[selch] + "]", true);
	                                }
								}
                                else
                                {
                                    WriteSystemLog(selch, ">> Cancel test [Is on test]", true);
                                }
                            }
                        }
                    }
                    else
                    {
                        WriteSystemLog(">> Cancel test [NO btn]");
                    }
                }
            }
            else
            {
                WriteSystemLog(">> Cancel work [Start work - No Seleched Ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "작업 시작", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Start Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
            }
        }

        private void Next_Step()
        {
            WriteSystemLog(">> Next step [Menu]");
            if (m_SelCh4Schedule == null)
            {
                WriteSystemLog(">> Cancel work[Next step - No Seleched Ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "다음 작업", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Next Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
                return;
            }

            if (m_iCur_CH_NO >= 0)
            {
                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬 사용 시 Slave 채널이면 return
                if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_iCur_CH_NO))
                {
                    WriteSystemLog(m_iCur_CH_NO, ">> Move to next is Cancelled [Parallel slave channel]", true);
                    return;
                }
                //-

                // ------------------------------------------------------------------
                string drmsg1 = "";
                string drmsg2 = "";
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                    drmsg2 = "다음 Step";
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    drmsg1 = "Do you want to proceed selected job?";
                    drmsg2 = "Next Step";
                }
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                if (dr == DialogResult.Yes)
                {
                    // -------------------------------------------
                    // Safety 처리
                    // 현 채널과 관련있는 알람들을 리스트에서 제거
                    // -------------------------------------------
                    //RemoveAlarm(m_iCur_CH_NO);
                    //EndCurrentStep(m_iCur_CH_NO, eNUM_CutOFF_Type.NONE);
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        // -------------------------------------------
                        // Safety 처리
                        // 현 채널과 관련있는 알람들을 리스트에서 제거
                        // -------------------------------------------

                        //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                        if (CheckParallelSlave(m_SelCh4Schedule[i]))
                        {
                            WriteSystemLog(m_SelCh4Schedule[i], ">> Move to Next step is Cancelled [Parallel slave channel]", true);
                        }
                        //-
                        else
                        {
	                        RemoveAlarm(m_SelCh4Schedule[i]);
	                        //EndTest2ndStep(m_SelCh4Schedule[i], true);
	                        EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER);
	
	                        WriteSystemLog(m_SelCh4Schedule[i], ">> Move to next step [Menu]", true);
						}                    
					}
                }
                else
                {
                    WriteSystemLog(">> 'NO' selected");
                }
            }
            else
            {
                WriteSystemLog(">> Cancel work[Next step - No Seleched Ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "다음 Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Next Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
            }


        }

        private void Schedule_Stop()
        {
            WriteSystemLog(">> End work [Menu]");
            if (m_SelCh4Schedule == null)
            {
                WriteSystemLog(">> Cancel [Not selected ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "작업 종료", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Stop Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
                return;
            }

            if (m_iCur_CH_NO >= 0)
            {
                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬 사용 시 Slave 채널이면 return
                if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_iCur_CH_NO))
                {
                    WriteSystemLog(m_iCur_CH_NO, ">> Stop test Cancelled [Parallel slave channel]", true);
                    return;
                }
                //-

                // ------------------------------------------------------------------
                string drmsg1 = "";
                string drmsg2 = "";
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                    //+ Revision by YMJ - 250619 : 오타 수정 다음 Step -> 작업 종료
                    drmsg2 = "작업 종료";
                    //-
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    //+ Revision by YMJ - 250619 : 오타 수정 다음 Step -> 작업 종료
                    drmsg1 = "Do you want to proceed selected work?";
                    drmsg2 = "End work";
                    //-
                }
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                if (dr == DialogResult.Yes)
                {
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        // -------------------------------------------
                        // Safety 처리
                        // 현 채널과 관련있는 알람들을 리스트에서 제거
                        // -------------------------------------------
                        // --------------------------------------
                        // 231213 BGH
                        // 병렬사용인데 마스터 채널 아니면 ...
                        // --------------------------------------
                        if (CheckParallelSlave(m_SelCh4Schedule[i]))
                        {
                            WriteSystemLog(m_SelCh4Schedule[i], ">> Stop test Cancelled [Parallel slave channel]", true);
                        }
                        else
                        {
	                        RemoveAlarm(m_SelCh4Schedule[i]);
	                        EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER, true);  // 231116
	                        EndTest2ndStep(m_SelCh4Schedule[i]);
	
	                        WriteSystemLog(m_SelCh4Schedule[i], ">> End Work [Menu]", true);
						}
                    }
                }
                else
                {
                    WriteSystemLog(">> 'NO' selected");
                }
            }
            else
            {
                WriteSystemLog(">> Cancel work[End work - No Seleched Ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "작업 종료", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Stop Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
            }
            //EndTest(m_iCur_CH_NO);
        }

        private void Show_About()
        {
            frmAbout n_frmAbout = new frmAbout(this);
            Set_Parent_Center_Location(n_frmAbout);
        }

        private void Set_Parent_Center_Location(Form n_SetForm)
        {
            Form n_Form = Application.OpenForms[n_SetForm.Name];

            Point n_MainCenter = MainForm_Center;

            if (n_Form != null)
            {
                n_Form.Location = new Point(n_MainCenter.X - (n_Form.Width / 2), n_MainCenter.Y - (n_Form.Height / 2));
                n_Form.Activate();
            }
            else
            {
                n_SetForm.StartPosition = FormStartPosition.Manual;
                n_SetForm.Location = new Point(n_MainCenter.X - (n_SetForm.Width / 2), n_MainCenter.Y - (n_SetForm.Height / 2));

                n_SetForm.Show();
            }
        }

        private void Mainframe_Shown(object sender, EventArgs e)
        {
            pn_ChannelDetail.AutoScrollPosition = new Point(0, 0);
        }


        // ------------------------------------------------
        // ghbaik
        // ------------------------------------------------
        private void SetTimer(int nid, int intv)
        {
            intv = (int)((double)intv / 100);  // 100ms --> 1 tick
            if (intv < 1) intv = 1;            // default : 100ms

            switch (nid)
            {
                case 2: t002_1000ms = new mtTimerVar(true, intv, 0); break;
                case 5: t005_30sec = new mtTimerVar(true, intv, 0); break;
            }
        }
        private void SetTimer10msTimer(int nid, int intv)
        {
            intv = (int)(intv / 10);
            if (intv < 0) intv = 1;

            switch (nid)
            {
                case 1: t001_10ms = new mtTimerVar(true, intv, 0); break;
                case 3: t003_100ms = new mtTimerVar(true, intv, 0); break;
                case 4: t004_100ms = new mtTimerVar(true, intv, 0); break;
            }
        }

        // ----------------------------------------
        // ghbaik
        // ----------------------------------------
        private void KillTimer(int nid)
        {
            switch (nid)
            {
                case 1: t001_10ms.Reset(); break;
                case 2: t002_1000ms.Reset(); break;
                case 3: t003_100ms.Reset(); break;
                case 4: t004_100ms.Reset(); break;
            }
        }

        // ----------------------------------------
        // ghbaik
        // ----------------------------------------
        //private async Task<bool> Connect_ABT(cls_devCyclerABT m_paraABT, int chcount)
        //private async void Connect_ABT(cls_devCyclerABT m_paraABT, int chcount)
        //private void Connect_ABT(cls_devCyclerABT m_paraABT)
        //{
        //    m_paraABT.CONnect();
        //}

        public void AddTickDispTime(int ch, int ms_intv)
        {
            try
            {
                int boardid = Board_Ch_Mapping[ch];
                int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
                TimeSpan ts1 = new TimeSpan(0, 0, 0, 0, 0);

                ts1 = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4disp.Add(new TimeSpan(0, 0, 0, 0, ms_intv));
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4disp = ts1;

                ts1 = m_ucStepInfo_List[ch].OGTime_Total_4disp.Add(new TimeSpan(0, 0, 0, 0, ms_intv));
                m_ucStepInfo_List[ch].OGTime_Total_4disp = ts1;
            }
            catch { }
        }

        // --------------------------------------------
        // option :
        //        0 : NO Adding
        //        1 : interval
        //        2 : Eventually (이전 기록과의 차이)
        //        3 : 이전기록과의 차이를 기본시간으로 고정
        //        4 : Pattern 시
        // --------------------------------------------
        public void AddTickStepAndTotalTime(int ch, byte option)
        {
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            int CurrentNo = 0;
            int intv = 1000;
            TimeSpan ts1 = new TimeSpan();
            TimeSpan ts2 = new TimeSpan();
			TimeSpan tsCV = new TimeSpan();

			cls_devCyclerABT.struCyclerStatus cyInfo = new cls_devCyclerABT.struCyclerStatus();
            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            
            cyInfo = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];
            CurStInfo = m_ucStepInfo_List[ch];

            if (CurStInfo.m_steplist.Count < 1)
            {
                return;
            }

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurrentNo < 0 || CurrentNo >= CurStInfo.m_steplist.Count)
            {
                return;
            }

            intv = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time;

            if (option == 0)
            {
                ts1 = cyInfo.OGTime_Step;
			}
            else if (option == 1)
            {
                ts1 = cyInfo.OGTime_Step.Add(new TimeSpan(0, 0, 0, 0, intv));
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime = DateTime.Now;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step = ts1;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_Final = ts1;

				if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isCVModeStarted)
				{
					tsCV = cyInfo.CVTime.Add(new TimeSpan(0, 0, 0, 0, intv));
					m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CVTime = tsCV;
				}

                // --------------------------------------
                // 변위 logging, 230911, BGH
                // (이부분이) 정기 logging 시간 계산하는 부분에서 처리.
                // --------------------------------------
                // 231126 주석처리함, 이유:더이상 사용하지 않음.
                //if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Volt >= 0.001)
                //{
                //    if (log_volt.Count >= log_intv_count)
                //    {
                //        log_volt.RemoveAt(0);
                //    }
                //    log_volt.Add(m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V);
                //}
                //if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Curr >= 0.001)
                //{
                //    if (log_curr.Count >= log_intv_count) { log_curr.RemoveAt(0); }
                //    log_curr.Add(m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I);
                //}
                //if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Temp >= 0.01)
                //{
                //    if (log_temp.Count >= log_intv_count) { log_temp.RemoveAt(0); }
                //    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T > -40 &&
                //        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                //    {
                //        log_temp.Add(m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T);
                //    }
                //    else
                //    {
                //        log_temp.Add(0);
                //    }
                //}


            }
            else if (option == 2)
            {
                ts1 = DateTime.Now - cyInfo.OGTime;
                ts1 = cyInfo.OGTime_Step.Add(ts1);
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_Final = ts1;
            }
            else if (option == 3)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_Final;
                ts1 = cyInfo.OGTime_Step;
            }
            //+ Add By YMJ - 240802 : 패턴 관련 로깅 옵션 추가
            else if (option == 4)
            {
                //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                ts1 = cyInfo.OGTime_Step.Add(new TimeSpan(0, 0, 0, 0, 100));
                //-
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime = DateTime.Now;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step = ts1;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_Final = ts1;

                //+ Revision By YMJ - 240911 : 패턴에 cv는 없으므로 주석처리
                /*if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isCVModeStarted)
                {
                    //+ Revision By YMJ - 240814 : 패턴 cv 로깅 옵션 수정
                    tsCV = cyInfo.CVTime.Add(new TimeSpan(0, 0, 0, 0, 100));
                    //-
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CVTime = tsCV;
                }*/
                //-
            }
            //-
            //+ Revision By YMJ - 240802 : 패턴 시 디스플레이 시간 정보 따로 처리
            if (option != 4)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4disp = ts1;
            }
            //-
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4log = ts1;

            // --------------------
            // Total
            // --------------------
            if (option == 0)
            {
                ts2 = CurStInfo.OGTime_Total;
            }
            else if (option == 1)
            {
                ts2 = CurStInfo.OGTime_Total.Add(new TimeSpan(0, 0, 0, 0, intv));
                m_ucStepInfo_List[ch].TestReStartTime = DateTime.Now;
                m_ucStepInfo_List[ch].OGTime_Total = ts2;
                m_ucStepInfo_List[ch].OGTime_Total_Final = ts2;
            }
            else if (option == 2)
            {
                ts2 = DateTime.Now - CurStInfo.TestReStartTime;
                ts2 = CurStInfo.OGTime_Total.Add(ts2);
                m_ucStepInfo_List[ch].OGTime_Total_Final = ts2;
            }
            else if (option == 3)
            {
                m_ucStepInfo_List[ch].OGTime_Total = m_ucStepInfo_List[ch].OGTime_Total_Final;
                ts2 = CurStInfo.OGTime_Total;
            }
            //+ Add By YMJ - 240802 : 패턴 관련 로깅 옵션 추가
            else if (option == 4)
            {
                //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                ts2 = CurStInfo.OGTime_Total.Add(new TimeSpan(0, 0, 0, 0, 100));
                //-
                m_ucStepInfo_List[ch].TestReStartTime = DateTime.Now;
                m_ucStepInfo_List[ch].OGTime_Total = ts2;
                m_ucStepInfo_List[ch].OGTime_Total_Final = ts2;
            }
            //-
            //+ Revision By YMJ - 240802 : 패턴 시 디스플레이 시간 정보 따로 처리
            if (option != 4)
            {
                m_ucStepInfo_List[ch].OGTime_Total_4disp = ts2;
            }
            //-
            m_ucStepInfo_List[ch].OGTime_Total_4log = ts2;
        }


        // ---------------------------------------
        // Cell V/T CutOff Checking
        // DAU, BMS에 사용
        // ---------------------------------------
        //enum CheckCUTOFFType { VOLT = 0, TEMP = 1 };
        //private bool CheckCutOffbyAUX(int m_stepnumber, float m_max, float m_min, float m_value, CheckCUTOFFType m_type)
        //{
        //    bool bret = false;



        //    return bret;
        //}

        // 231126 사용안함, BGH
        //private void TimerEvent5(object source, EventArgs e)
        //{
        //    OnTick5ms?.Invoke();
        //}

        // ---------------------------------------
        // ghbaik
        // ---------------------------------------
        private void TimerEvent10(object source, EventArgs e)
        {
            OnTick10ms?.Invoke();

            Stopwatch swatch = new System.Diagnostics.Stopwatch();
            swatch.Start();

            // -----------------------------
            // 
            // -----------------------------
            if (t001_10ms.enable)
            {
                t001_10ms.tick++;
                if (t001_10ms.tick >= t001_10ms.limit)
                {
                    t001_10ms.tick = 0;                    
                }
            }

            // --------------------------------------
            // 1. Check Safety Condition
            // 2. Check AUX Display
            // 3. Check DAU Diaplay
            // 4. Check BMS Display
            // --------------------------------------
            if (t003_100ms.enable)
            {
                t003_100ms.tick++;
                if (t003_100ms.tick >= t003_100ms.limit)
                {
                    t003_100ms.tick = 0;

                    // -----------------------------------
                    // code is here
                    // -----------------------------------
                    if (IsOnTesting != null)
                    {
                        // -------------------------------------------
                        // AUX Checking
                        // -------------------------------------------
                        if (m_clsAppSet.Enable_Set.Enable_AUX)
                        {
                            try
                            {
                                // -------------------------------------------
                                // Cut-Off 체크는 3649번 라인 쪽으로 이동
                                // 100ms 핸들러에서 처리
                                // -------------------------------------------

                                string chstr = "";
                                // -------------------------------------------
                                // AUX
                                // -------------------------------------------
                                if (m_ucAUX7019_List != null && (m_AUX_Volt != null || m_AUX_Temp != null))
                                {
                                    Display_AUX_Data dpAux = new Display_AUX_Data();
                                    List<Display_AUX_Data> lstAux = new List<Display_AUX_Data>();

                                    // int acount = m_ucAUX7019_List.Count;
                                    if (m_NumOfAUX > 0 && m_voltcount_aux.Length > 0)
                                    {                                        
                                        dpAux.AUX_Name = " AUX Max. V";
                                        dpAux.AUX_Value1 = AUX_V_max[0].ToString("F3") + "V";
                                        if (m_NumOfAUX > 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_max[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_max[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = AUX_V_max[3].ToString("F3") + "V";
                                        }
                                        else if (m_NumOfAUX == 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_max[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_max[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else if (m_NumOfAUX == 2)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_max[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else 
                                        {
                                            dpAux.AUX_Value2 = "-";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        lstAux.Add(dpAux);

                                        dpAux.AUX_Name = " AUX Min. V";
                                        dpAux.AUX_Value1 = AUX_V_min[0].ToString("F3") + "V";
                                        if (m_NumOfAUX > 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_min[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_min[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = AUX_V_min[3].ToString("F3") + "V";
                                        }
                                        else if (m_NumOfAUX == 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_min[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_min[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else if (m_NumOfAUX == 2)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_min[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else
                                        {
                                            dpAux.AUX_Value2 = "-";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        lstAux.Add(dpAux);

                                        dpAux.AUX_Name = " AUX Diff. V";
                                        dpAux.AUX_Value1 = AUX_V_diff[0].ToString("F3") + "V";
                                        if (m_NumOfAUX > 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_diff[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_diff[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = AUX_V_diff[3].ToString("F3") + "V";
                                        }
                                        else if (m_NumOfAUX == 3)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_diff[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = AUX_V_diff[2].ToString("F3") + "V";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else if (m_NumOfAUX == 2)
                                        {
                                            dpAux.AUX_Value2 = AUX_V_diff[1].ToString("F3") + "V";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        else
                                        {
                                            dpAux.AUX_Value2 = "-";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";
                                        }
                                        lstAux.Add(dpAux);


                                        // for (int iaux = 0; iaux < m_AUX_Volt.GetLength(1); iaux++)
                                        for (int iaux = 0; iaux < m_voltcount_aux[0]; iaux++)
                                        {
                                            dpAux.AUX_Name = chstr + " AUX V" + (iaux + 1).ToString("D2");
                                            dpAux.AUX_Value1 = m_AUX_Volt[0, iaux].ToString("F3") + "V";
                                            if (m_NumOfAUX > 3)
                                            {
                                                dpAux.AUX_Value2 = m_AUX_Volt[1, iaux].ToString("F3") + "V";
                                                dpAux.AUX_Value3 = m_AUX_Volt[2, iaux].ToString("F3") + "V";
                                                dpAux.AUX_Value4 = m_AUX_Volt[3, iaux].ToString("F3") + "V";
                                            }
                                            else if (m_NumOfAUX == 3)
                                            {
                                                dpAux.AUX_Value2 = m_AUX_Volt[1, iaux].ToString("F3") + "V";
                                                dpAux.AUX_Value3 = m_AUX_Volt[2, iaux].ToString("F3") + "V";
                                                dpAux.AUX_Value4 = "-";
                                            }
                                            else if (m_NumOfAUX == 2)
                                            {
                                                dpAux.AUX_Value2 = m_AUX_Volt[1, iaux].ToString("F3") + "V";
                                                dpAux.AUX_Value3 = "-";
                                                dpAux.AUX_Value4 = "-";
                                            }
                                            else
                                            {
                                                dpAux.AUX_Value2 = "-";
                                                dpAux.AUX_Value3 = "-";
                                                dpAux.AUX_Value4 = "-";
                                            }
                                            lstAux.Add(dpAux);
                                        }
                                    }

                                    if (m_NumOfAUX > 0 && m_tempcount_aux.Length > 0)
                                    {
                                        // for (int iaux = 0; iaux < m_AUX_Temp.GetLength(1); iaux++)
                                        for (int iaux = 0; iaux < m_tempcount_aux[0]; iaux++)
                                        {
                                            dpAux.AUX_Name = chstr + " AUX T" + (iaux + 1).ToString("D2");
                                            if (m_AUX_Temp[0, iaux] > -40 && m_AUX_Temp[0, iaux] < 100)
                                            {
                                                dpAux.AUX_Value1 = m_AUX_Temp[0, iaux].ToString("F1") + "℃";
                                            }
                                            else
                                            {
                                                dpAux.AUX_Value1 = "-";
                                            }

                                            dpAux.AUX_Value2 = "-";
                                            dpAux.AUX_Value3 = "-";
                                            dpAux.AUX_Value4 = "-";

                                            if (m_NumOfAUX > 1)
                                            {
                                                if (m_AUX_Temp[1, iaux] > -40 && m_AUX_Temp[1, iaux] < 100)
                                                {
                                                    dpAux.AUX_Value2 = m_AUX_Temp[1, iaux].ToString("F1") + "℃";
                                                }
                                                else
                                                {
                                                    dpAux.AUX_Value2 = "-";
                                                }
                                            }
                                            if (m_NumOfAUX > 2)
                                            {
                                                if (m_AUX_Temp[2, iaux] > -40 && m_AUX_Temp[2, iaux] < 100)
                                                {
                                                    dpAux.AUX_Value3 = m_AUX_Temp[2, iaux].ToString("F1") + "℃";
                                                }
                                                else
                                                {
                                                    dpAux.AUX_Value3 = "-";
                                                }
                                            }
                                            if (m_NumOfAUX > 3)
                                            {
                                                if (m_AUX_Temp[3, iaux] > -40 && m_AUX_Temp[3, iaux] < 100)
                                                {
                                                    dpAux.AUX_Value4 = m_AUX_Temp[3, iaux].ToString("F1") + "℃";
                                                }
                                                else
                                                {
                                                    dpAux.AUX_Value4 = "-";
                                                }
                                            }
                                            lstAux.Add(dpAux);
                                        }
                                    }

                                    m_ucChannel_Status.AUX_Volt_Count = m_voltcount_aux[0];  // add by BGH 230629
                                    m_ucChannel_Status.Disp_AUX_Val = lstAux;
                                    
                                }

                                // -------------------------------------------
                                // DAU
                                // -------------------------------------------
                                if (m_ucDAU_List != null && (m_DAU_Volt != null || m_DAU_Temp != null))
                                {
                                    List<Display_DAU_Data> lstDau = new List<Display_DAU_Data>();

                                    //+ Add And Revision by LBG - 240530 : DAU Value Diaplay 관련 기능 수정
                                    int n_iDAU_V_Max_Cnt = 0;
                                    int n_iDAU_T_Max_Cnt = 0;

                                    //+ Revision by YMJ - 241108 : DAU 평균 온도 계산 추가
                                    double[] tempSum = new double[Get_CH_Cnt];

                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        if (n_iDAU_V_Max_Cnt < m_voltcount_dau[i])
                                        {
                                            n_iDAU_V_Max_Cnt = m_voltcount_dau[i];
                                        }

                                        if (n_iDAU_T_Max_Cnt < m_tempcount_dau[i])
                                        {
                                            n_iDAU_T_Max_Cnt = m_tempcount_dau[i];
                                        }
                                        tempSum[i] = 0;
                                    }
                                    
                                    Display_DAU_Data dpDau_Max = new Display_DAU_Data();
                                    dpDau_Max.Reset();
                                    dpDau_Max.DAU_Name = " Max.Cell V";
                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        dpDau_Max.DAU_Value.Add(m_DAU_V_Max[i].ToString(Volt_Number_Digit) + "V");
                                    }
                                    lstDau.Add(dpDau_Max);

                                    Display_DAU_Data dpDau_Min = new Display_DAU_Data();
                                    dpDau_Min.Reset();
                                    dpDau_Min.DAU_Name = " Min.Cell V";
                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        dpDau_Min.DAU_Value.Add(m_DAU_V_Min[i].ToString(Volt_Number_Digit) + "V");
                                    }
                                    lstDau.Add(dpDau_Min);

                                    Display_DAU_Data dpDau_Diff = new Display_DAU_Data();
                                    dpDau_Diff.Reset();
                                    dpDau_Diff.DAU_Name = " Diff.Cell V";
                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        dpDau_Diff.DAU_Value.Add(m_DAU_V_Diff[i].ToString(Volt_Number_Digit) + "V");
                                    }
                                    lstDau.Add(dpDau_Diff);
                                    // Cell Volt Display Value Creat
                                    for (int k = 0; k < n_iDAU_V_Max_Cnt; k++)
                                    {
                                        Display_DAU_Data dpDau_V = new Display_DAU_Data();
                                        dpDau_V.Reset();
                                        dpDau_V.DAU_Name = " CellVolt. " + (k + 1).ToString("D3");

                                        for (int i = 0; i < Get_CH_Cnt; i++)
                                        {
                                            //+ Revision by KGY -250411 : 오류방지 조건 재설정
                                            if (k < m_voltcount_dau[i] && k < m_DAU_Volt[i].Count)
                                            {
                                                dpDau_V.DAU_Value.Add(m_DAU_Volt[i][k].ToString(Volt_Number_Digit) + "V");
                                            }
                                            else
                                            {
                                                dpDau_V.DAU_Value.Add("-");
                                            }
                                            //-
                                        }

                                        lstDau.Add(dpDau_V);
                                    }
                                    // Temperature Display Value Creat
                                    for (int k = 0; k < n_iDAU_T_Max_Cnt; k++)
                                    {
                                        Display_DAU_Data dpDau_T = new Display_DAU_Data();
                                        dpDau_T.Reset();
                                        dpDau_T.DAU_Name = " Temp. " + (k + 1).ToString("D3");

                                       
                                        for (int i = 0; i < Get_CH_Cnt; i++)
                                        {
                                            //+ Revision by KGY -250411 : 오류방지 조건 재설정
                                            if (k < m_tempcount_dau[i] && k < m_DAU_Temp[i].Count)
                                            {
                                                if (m_DAU_Temp[i][k] > -40 && m_DAU_Temp[i][k] < 100)
                                                {
                                                    dpDau_T.DAU_Value.Add(m_DAU_Temp[i][k].ToString("F1") + "℃");
                                                    tempSum[i] += m_DAU_Temp[i][k];
                                                }
                                                else
                                                {
                                                    dpDau_T.DAU_Value.Add("-");
                                                }
                                            }
                                            else
                                            {
                                                dpDau_T.DAU_Value.Add("-");
                                            }
                                            //-
                                        }

                                        lstDau.Add(dpDau_T);
                                    }
                                    //+ Add by YMJ - 240530 : 채널정보 UI 온도 출력 설정값이 DAU일 경우 처리
                                    if (m_temp_Collect_dev.Equals("DAU"))
                                    {
                                        for (int i = 0; i < Get_CH_Cnt; i++)
                                        {
                                            m_DAU_TempAvg[i] = tempSum[i] / m_tempcount_dau[i];
                                            int boardid = Board_Ch_Mapping[i];
                                            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(i);

                                            //+ Add by YMJ - 240530 : 오류 방지 코드 추가
                                            if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                                            {
                                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = m_DAU_TempAvg[i];
                                            }
                                            //-
                                        }
                                    }
                                    //-
                                    //-

                                    m_ucChannel_Status.AUX_Volt_Count = n_iDAU_V_Max_Cnt;
                                    m_ucChannel_Status.Disp_DAU_Val = lstDau;
                                    //-

                                    #region 기존 DAU Display
                                    //// -------------------------------------
                                    //// 일단 DAU 2개만 표시 지원
                                    //// -------------------------------------
                                    //if (m_voltcount_dau[0] > 0)
                                    //{
                                    //    dpDau.DAU_Name = " Max.Cell V";

                                    //    //+Revision by YMJ - 231124 : DAU 파라미터 변경
                                    //    dpDau.DAU_Value1 = m_DAU_V_Max[0].ToString("F4") + "V";
                                    //    //-

                                    //    //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                    //    //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                    //    if (m_NumOfDAU > 1)
                                    //    {
                                    //        //+Revision by YYMJ - 231124 : DAU 파라미터 변경
                                    //        dpDau.DAU_Value2 = m_DAU_V_Max[1].ToString("F4") + "V";
                                    //        //-
                                    //    }
                                    //    else
                                    //    {
                                    //        dpDau.DAU_Value2 = "-";
                                    //    }
                                    //    lstDau.Add(dpDau);

                                    //    dpDau.DAU_Name = " Min.Cell V";
                                    //    //+Revision by YMJ - 231124 : DAU 파라미터 변경
                                    //    dpDau.DAU_Value1 = m_DAU_V_Min[0].ToString("F4") + "V";
                                    //    //-

                                    //    //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                    //    //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                    //    if (m_NumOfDAU > 1)
                                    //    {
                                    //        //+Revision by YMJ - 231124 : DAU 파라미터 변경
                                    //        dpDau.DAU_Value2 = m_DAU_V_Min[1].ToString("F4") + "V";
                                    //        //-
                                    //    }
                                    //    else
                                    //    {
                                    //        dpDau.DAU_Value2 = "-";
                                    //    }
                                    //    lstDau.Add(dpDau);

                                    //    dpDau.DAU_Name = " Diff.Cell V";
                                    //    //+Revision by YMJ - 231124 : DAU 파라미터 변경
                                    //    dpDau.DAU_Value1 = m_DAU_V_Diff[0].ToString("F4") + "V";
                                    //    //-

                                    //    //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                    //    //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                    //    if (m_NumOfDAU > 1)
                                    //    {
                                    //        //+Revision by YMJ - 231124 : DAU 파라미터 변경
                                    //        dpDau.DAU_Value2 = m_DAU_V_Diff[1].ToString("F4") + "V";
                                    //        //-
                                    //    }
                                    //    else
                                    //    {
                                    //        dpDau.DAU_Value2 = "-";
                                    //    }
                                    //    lstDau.Add(dpDau);

                                    //    for (int iaux = 0; iaux < m_voltcount_dau[0]; iaux++)
                                    //    {
                                    //        dpDau.DAU_Name = " CellVolt. " + (iaux + 1).ToString("D3");
                                    //        //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                                    //        //dpDau.DAU_Value1 = m_DAU_Volt[0, iaux].ToString("F4") + "V";
                                    //        dpDau.DAU_Value1 = m_DAU_Volt[0, iaux].ToString(Volt_Number_Digit) + "V";
                                    //        //-

                                    //        //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                    //        //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                    //        if (m_NumOfDAU > 1)
                                    //        {
                                    //            //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                                    //            //dpDau.DAU_Value2 = m_DAU_Volt[1, iaux].ToString("F4") + "V";
                                    //            dpDau.DAU_Value2 = m_DAU_Volt[1, iaux].ToString(Volt_Number_Digit) + "V";
                                    //            //-
                                    //        }
                                    //        else
                                    //        {
                                    //            dpDau.DAU_Value2 = "-";
                                    //        }

                                    //        lstDau.Add(dpDau);
                                    //    }
                                    //}

                                    //if (m_tempcount_dau[0] > 0)
                                    //{
                                    //    for (int iaux = 0; iaux < m_tempcount_dau[0]; iaux++)
                                    //    {
                                    //        dpDau.DAU_Name = " Temp. " + (iaux + 1).ToString("D2");
                                    //        if (m_DAU_Temp[0, iaux] > -40 && m_DAU_Temp[0, iaux] < 100)
                                    //        {
                                    //            dpDau.DAU_Value1 = m_DAU_Temp[0, iaux].ToString("F1") + "℃";
                                    //        }
                                    //        else
                                    //        {
                                    //            dpDau.DAU_Value1 = "-";

                                    //        }

                                    //        //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                    //        //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                    //        if (m_NumOfDAU > 1)
                                    //        {
                                    //            if (m_DAU_Temp[1, iaux] > -40 && m_DAU_Temp[1, iaux] < 100)
                                    //            {
                                    //                dpDau.DAU_Value2 = m_DAU_Temp[1, iaux].ToString("F1") + "℃";
                                    //            }
                                    //            else
                                    //            {
                                    //                //dpDau.DAU_Value1 = "-";
                                    //                dpDau.DAU_Value2 = "-";
                                    //            }
                                    //        }
                                    //        else
                                    //        {
                                    //            // dpDau.DAU_Value1 = "-";
                                    //            dpDau.DAU_Value2 = "-";
                                    //        }

                                    //        lstDau.Add(dpDau);
                                    //    }
                                    //}

                                    //m_ucChannel_Status.AUX_Volt_Count = m_voltcount_dau[0];  // add by BGH 230629
                                    //m_ucChannel_Status.Disp_DAU_Val = lstDau;
                                    #endregion
                                }

                                // -------------------------------------------
                                // IONIQ5 & BMS
                                // -------------------------------------------
                                if (m_ucBMS_List != null && (m_BMS_Volt != null || m_BMS_Temp != null))
                                {
                                    Display_DAU_Data dpDau = new Display_DAU_Data();
                                    dpDau.Reset();
                                    List<Display_DAU_Data> lstDau = new List<Display_DAU_Data>();

                                    for (int ml = 0; ml < m_ucBMS_List.Count; ml++)
                                    {
                                        for (int i = 0; i < m_voltcount_bms[ml]; i++)
                                        {
                                            m_BMS_Volt[ml, i] = m_ucBMS_List[ml].m_Volt[i];
                                            if (i > 178) break;
                                        }

                                        for (int i = 0; i < m_tempcount_bms[ml]; i++)
                                        {
                                            m_BMS_Temp[ml, i] = m_ucBMS_List[ml].m_Temp[i];
                                            if (i > 22) break;
                                        }
                                    }

                                    // -------------------------------------
                                    // 일단 DAU 2개만 표시 지원
                                    // -------------------------------------
                                    if (m_voltcount_bms[0] > 0)
                                    {
                                        dpDau.DAU_Name = " Max.Cell V";
                                        dpDau.DAU_Value.Add(BMS_V_max[0].ToString("F4") + "V");

                                        if (m_ucBMS_List.Count > 1)
                                        {
                                            dpDau.DAU_Value.Add(BMS_V_max[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpDau.DAU_Value.Add("-");
                                        }
                                        lstDau.Add(dpDau);

                                        dpDau.DAU_Name = " Min.Cell V";
                                        dpDau.DAU_Value.Add(BMS_V_min[0].ToString("F4") + "V");
                                        if (m_ucBMS_List.Count > 1)
                                        {
                                            dpDau.DAU_Value.Add(BMS_V_min[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpDau.DAU_Value.Add("-");
                                        }
                                        lstDau.Add(dpDau);

                                        dpDau.DAU_Name = " Diff.Cell V";
                                        dpDau.DAU_Value.Add(BMS_V_diff[0].ToString("F4") + "V");
                                        if (m_ucBMS_List.Count > 1)
                                        {
                                            dpDau.DAU_Value.Add(BMS_V_diff[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpDau.DAU_Value.Add("-");
                                        }
                                        lstDau.Add(dpDau);


                                        // for (int iaux = 0; iaux < m_BMS_Volt.GetLength(1); iaux++)
                                        for (int iaux = 0; iaux < m_voltcount_bms[0] ; iaux++)
                                        {
                                            dpDau.DAU_Name = " CellVolt. " + (iaux + 1).ToString("D3");
                                            dpDau.DAU_Value.Add(m_BMS_Volt[0, iaux].ToString("F4") + "V");
                                            if (m_ucBMS_List.Count > 1)
                                            {
                                                dpDau.DAU_Value.Add(m_BMS_Volt[1, iaux].ToString("F4") + "V");
                                            }
                                            else
                                            {
                                                dpDau.DAU_Value.Add("-");
                                            }

                                            lstDau.Add(dpDau);
                                        }
                                    }

                                    if (m_tempcount_bms[0] > 0)
                                    {
                                        // for (int iaux = 0; iaux < m_BMS_Temp.GetLength(1); iaux++)
                                        for (int iaux = 0; iaux < m_tempcount_bms[0] ; iaux++)
                                        {
                                            dpDau.DAU_Name = " Temp. " + (iaux + 1).ToString("D2");
                                            if (m_BMS_Temp[0, iaux] > -40 && m_BMS_Temp[0, iaux] < 100)
                                            {
                                                dpDau.DAU_Value.Add(m_BMS_Temp[0, iaux].ToString("F1") + "℃");
                                            }
                                            else
                                            {
                                                dpDau.DAU_Value.Add("-");
                                            }
                                            if (m_NumOfBMS > 1)
                                            {
                                                if (m_BMS_Temp[1, iaux] > -40 && m_BMS_Temp[1, iaux] < 100)
                                                {
                                                    dpDau.DAU_Value.Add(m_BMS_Temp[1, iaux].ToString("F1") + "℃");
                                                }
                                                else
                                                {
                                                    //dpDau.DAU_Value1 = "-";
                                                    dpDau.DAU_Value.Add("-");
                                                }
                                            }
                                            else
                                            {
                                                // dpDau.DAU_Value1 = "-";
                                                dpDau.DAU_Value.Add("-");
                                            }

                                            lstDau.Add(dpDau);
                                        }
                                    }

                                    m_ucChannel_Status.AUX_Volt_Count = m_voltcount_bms[0];  // add by BGH 230629
                                    m_ucChannel_Status.Disp_DAU_Val = lstDau;

                                }

                                // -------------------------------------------
                                // CAN
                                // -------------------------------------------
                                if (m_ucCAN_List != null)
                                {
                                    Display_CAN_Data dpCan = new Display_CAN_Data();
                                    List<Display_CAN_Data> lstCan = new List<Display_CAN_Data>();
                                    //+ Revision by YMJ - 250218 : 선택 채널이 없을 경우 오류 보완
                                    if (m_iCur_CH_NO != -1 && m_iCur_CH_NO < m_ucCAN_List.Count)
                                    //-
                                    {
                                        if (m_ucCAN_List[m_iCur_CH_NO].isConnected && m_ucCAN_List[m_iCur_CH_NO].ControlEnabled)
                                        {
                                            List<cls_devCAN.MDBC_PARSE> m_canlist = m_ucCAN_List[m_iCur_CH_NO].CAN_List;

                                            int can_count = m_ucCAN_List[m_iCur_CH_NO].CAN_List_Count;

                                            for (int iaux = 0; iaux < can_count; iaux++)
                                            {
                                                //+ Revision by YMJ - 250725 : CAN 초기 값일 경우 하이픈으로 표기
                                                dpCan.CAN_Name = m_canlist[iaux].Name;
                                                if(m_canlist[iaux].Value == -999999)
                                                {
                                                    dpCan.CAN_Value = "-";
                                                }
                                                else
                                                {
                                                    dpCan.CAN_Value = m_canlist[iaux].Value.ToString("F3");
                                                }
                                                //-

                                                lstCan.Add(dpCan);
                                            }
                                            //+ Add by YMJ - 241028 : 표기 중인 CAN 정보의 채널 정보 필드 추가
                                            m_ucChannel_Status.Display_Can_CH = m_iCur_CH_NO;
                                            //-
                                            m_ucChannel_Status.Disp_CAN_Val = lstCan;
                                        }
                                        else
                                        {
                                            if (m_ucChannel_Status.CAN_Items_Count != 0)
                                            {
                                                lstCan = new List<Display_CAN_Data>();
                                                //+ Add by YMJ - 241028 : 표기 중인 CAN 정보의 채널 정보 필드 추가
                                                m_ucChannel_Status.Display_Can_CH = m_iCur_CH_NO;
                                                //-
                                                m_ucChannel_Status.Disp_CAN_Val = lstCan;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (m_ucChannel_Status.CAN_Items_Count != 0)
                                        {
                                            lstCan = new List<Display_CAN_Data>();
                                            //+ Add by YMJ - 241028 : 표기 중인 CAN 정보의 채널 정보 필드 추가
                                            m_ucChannel_Status.Display_Can_CH = m_iCur_CH_NO;
                                            //-
                                            m_ucChannel_Status.Disp_CAN_Val = lstCan;
                                        }
                                    }

                                }

                                // -------------------------------------------
                                // MBI
                                // -------------------------------------------
                                if (m_ucMBI_List != null && (m_MBI_Volt != null || m_MBI_Temp != null))
                                {
                                    Display_DAU_Data dpMBI = new Display_DAU_Data();
                                    dpMBI.Reset();
                                    List<Display_DAU_Data> lstMBI = new List<Display_DAU_Data>();

                                    // -------------------------------------
                                    // 일단 MBI 2개만 표시 지원
                                    // -------------------------------------
                                    if (m_voltcount_mbi[0] > 0)
                                    {
                                        dpMBI.DAU_Name = " Max.Cell V";
                                        dpMBI.DAU_Value.Add(MBI_V_max[0].ToString("F4") + "V");

                                        if (m_NumOfMBI > 1)
                                        {
                                            dpMBI.DAU_Value.Add(MBI_V_max[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpMBI.DAU_Value.Add("-");
                                        }
                                        lstMBI.Add(dpMBI);

                                        dpMBI.DAU_Value.Add(" Min.Cell V");
                                        dpMBI.DAU_Value.Add(MBI_V_min[0].ToString("F4") + "V");

                                        //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                        //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                        if (m_NumOfMBI > 1)
                                        {
                                            dpMBI.DAU_Value.Add(MBI_V_min[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpMBI.DAU_Value.Add("-");
                                        }
                                        lstMBI.Add(dpMBI);

                                        dpMBI.DAU_Name = " Diff.Cell V";
                                        dpMBI.DAU_Value.Add(MBI_V_diff[0].ToString("F4") + "V");

                                        //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                        //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                        if (m_NumOfMBI > 1)
                                        {
                                            dpMBI.DAU_Value.Add(MBI_V_diff[1].ToString("F4") + "V");
                                        }
                                        else
                                        {
                                            dpMBI.DAU_Value.Add("-");
                                        }
                                        lstMBI.Add(dpMBI);


                                        for (int iaux = 0; iaux < m_voltcount_mbi[0]; iaux++)
                                        {
                                            dpMBI.DAU_Name = " CellVolt. " + (iaux + 1).ToString("D3");
                                            dpMBI.DAU_Value.Add(m_MBI_Volt[0, iaux].ToString("F4") + "V");

                                            if (m_NumOfMBI > 1)
                                            {
                                                dpMBI.DAU_Value.Add(m_MBI_Volt[1, iaux].ToString("F4") + "V");
                                            }
                                            else
                                            {
                                                dpMBI.DAU_Value.Add("-");
                                            }

                                            lstMBI.Add(dpMBI);
                                        }
                                    }

                                    if (m_tempcount_mbi[0] > 0)
                                    {
                                        for (int iaux = 0; iaux < m_tempcount_mbi[0]; iaux++)
                                        {
                                            dpMBI.DAU_Name = " Temp. " + (iaux + 1).ToString("D2");
                                            if (m_MBI_Temp[0, iaux] > -40 && m_MBI_Temp[0, iaux] < 100)
                                            {
                                                dpMBI.DAU_Value.Add(m_MBI_Temp[0, iaux].ToString("F1") + "℃");
                                            }
                                            else
                                            {
                                                dpMBI.DAU_Value.Add("-");

                                            }

                                            //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                                            //if (m_ucDAU_List.Count > 1)  m_NumOfDAU
                                            if (m_NumOfMBI > 1)
                                            {
                                                if (m_MBI_Temp[1, iaux] > -40 && m_MBI_Temp[1, iaux] < 100)
                                                {
                                                    dpMBI.DAU_Value.Add(m_MBI_Temp[1, iaux].ToString("F1") + "℃");
                                                }
                                                else
                                                {
                                                    dpMBI.DAU_Value.Add("-");
                                                }
                                            }
                                            else
                                            {
                                                dpMBI.DAU_Value.Add("-");
                                            }

                                            lstMBI.Add(dpMBI);
                                        }
                                    }

                                    m_ucChannel_Status.AUX_Volt_Count = m_voltcount_mbi[0];
                                    m_ucChannel_Status.Disp_DAU_Val = lstMBI;

                                }

                                //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
                                //+ Add by YMJ - 241105 : CREVIS AUX 값 넣기
                                if (m_ucCREVIS_List != null && (m_CREVIS_Volt != null || m_CREVIS_Temp != null))
                                {
                                    List<Display_CREVIS_Data> lstCREVIS = new List<Display_CREVIS_Data>();

                                    Display_CREVIS_Data dpCREVIS_Max = new Display_CREVIS_Data();
                                    dpCREVIS_Max.Reset();
                                    dpCREVIS_Max.CREVIS_Name = " CREVIS Max. T";

                                    for(int i=0; i<Get_CH_Cnt; i++)
                                    {
                                        dpCREVIS_Max.CREVIS_Value.Add(m_CREVIS_T_Max[i].ToString("F4") + "℃");
                                    }

                                    lstCREVIS.Add(dpCREVIS_Max);

                                    Display_CREVIS_Data dpCREVIS_Min = new Display_CREVIS_Data();
                                    dpCREVIS_Min.Reset();
                                    dpCREVIS_Min.CREVIS_Name = " CREVIS Min. T";

                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        dpCREVIS_Min.CREVIS_Value.Add(m_CREVIS_T_Min[i].ToString("F4") + "℃");
                                    }

                                    lstCREVIS.Add(dpCREVIS_Min);

                                    Display_CREVIS_Data dpCREVIS_Diff = new Display_CREVIS_Data();
                                    dpCREVIS_Diff.Reset();
                                    dpCREVIS_Diff.CREVIS_Name = " CREVIS Diff. T";

                                    for (int i = 0; i < Get_CH_Cnt; i++)
                                    {
                                        dpCREVIS_Diff.CREVIS_Value.Add(m_CREVIS_T_Diff[i].ToString("F4") + "℃");
                                    }

                                    lstCREVIS.Add(dpCREVIS_Diff);

                                    for (int k = 0; k < m_CREVIS_DEVISION; k++)
                                    {
                                        Display_CREVIS_Data dpCREVIS_T = new Display_CREVIS_Data();
                                        dpCREVIS_T.Reset();
                                        dpCREVIS_T.CREVIS_Name = " CREVIS T. " + (k + 1).ToString("D3");

                                        for (int i = 0; i < Get_CH_Cnt; i++)
                                        {
                                            if (m_CREVIS_Temp[i, k] != -100)
                                            {
                                                dpCREVIS_T.CREVIS_Value.Add(m_CREVIS_Temp[i, k].ToString("F4") + "℃");
                                            }
                                            else
                                            {
                                                dpCREVIS_T.CREVIS_Value.Add("-");
                                            }
                                        }

                                        lstCREVIS.Add(dpCREVIS_T);
                                    }

                                    /*for (int k = 0; k < m_CREVIS_DEVISION; k++)
                                    {
                                        Display_CREVIS_Data dpCREVIS_V = new Display_CREVIS_Data();
                                        dpCREVIS_V.Reset();
                                        dpCREVIS_V.CREVIS_Name = " CREVIS V. " + (k + 1).ToString("D3");

                                        for (int i = 0; i < Get_CH_Cnt; i++)
                                        {
                                            if (k < m_voltcount_crevis[i])
                                            {
                                                dpCREVIS_V.CREVIS_Value.Add(m_CREVIS_Volt[i, k].ToString("F4") + "V");
                                            }
                                            else
                                            {
                                                dpCREVIS_V.CREVIS_Value.Add("-");
                                            }
                                        }

                                        lstCREVIS.Add(dpCREVIS_V);
                                    }*/

                                    if (m_temp_Collect_dev.Equals("CREVIS"))
                                    {
                                        int n_totalTempCnt = 0;
                                        for (int k = 0; k < Get_CH_Cnt; k++)
                                        {
                                            double n_tempSum = 0;
                                            for (int i = 0; i < m_CREVIS_DEVISION; i++)
                                            {
                                                n_tempSum += m_CREVIS_Temp[k, i];
                                            }
                                            n_tempSum = n_tempSum / m_CREVIS_DEVISION;

                                            int boardid = Board_Ch_Mapping[n_totalTempCnt];
                                            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(n_totalTempCnt);

                                            if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                                            {
                                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = n_tempSum;
                                            }
                                        }
                                    }

                                    m_ucChannel_Status.AUX_Volt_Count = m_CREVIS_DEVISION;  // add by BGH 230629
                                    m_ucChannel_Status.Disp_CREVIS_Val = lstCREVIS;
                                }
                                //-
                            }
                            catch (Exception ex)
                            {
                                Debug.WriteLine("Mainframe[TimerEvent10::3788] - " + ex.Message);
                            }
                        }
                    }
                }
            }

            // ----------------------------
            // Safety Check
            // ----------------------------
            if (t004_100ms.enable)
            {
                t004_100ms.tick++;
                if (t004_100ms.tick >= t004_100ms.limit)
                {
                    t004_100ms.tick = 0;

                    // -----------------------------------
                    // code is here
                    // -----------------------------------
                    if (IsOnTesting != null)
                    {
                        // -------------------------------------------
                        // Check STep running condition
                        // -------------------------------------------
                        if (IsOnTesting.Length > 0)
                        {
                            for (int mch = 0; mch < IsOnTesting.Length; mch++)
                            {
                                if (IsOnTesting[mch])
                                {
                                    // CheckSafetyCondition(mch);
                                }
                                else
                                {
                                    int boardid = Board_Ch_Mapping[mch];  // ghbaik
                                    //+ Revision by LBG - 250402 : 통신이 연결이 안되어 있는 상태에서 보드에 할당된 채널 번호를 가져올 시 멈추는 현상이 있어 해당 기능 변경
                                    //int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(mch);  // ghbaik2
                                    int bzch = m_clsSys_Link.Get_Board_CH(mch);
                                    if (bzch >= 0)
                                    {
                                        //_
                                        if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                                        {
                                            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode != 0)
                                            {
                                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode = 0;
                                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString = "0(OK)";

                                                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(mch);
                                                m_dispChStatus.ch_s_Exist_Alarm = false;
                                                m_ucChannel_Status.Set_Disp_CH_Status(mch, m_dispChStatus);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (swatch.IsRunning)
            {
                swatch.Stop();
                if (swatch.ElapsedMilliseconds > 10)
                {
                    Debug.WriteLine("Timer  10ms Elasped : " + swatch.ElapsedMilliseconds.ToString() + " msec");
                }
            }

        }

        private async void TimerEvent100(object source, EventArgs e)
        {
            bool bPing = false;

            // OnTick100ms?.Invoke();

            // -----------------------------
            // 
            // -----------------------------
            //Stopwatch swatch = new System.Diagnostics.Stopwatch();
            //swatch.Start();

            try
            {
                // -------------------------------------
                // 1 sec scheduler
                // -------------------------------------
                if (t002_1000ms.enable)
                {
                    t002_1000ms.tick++;
                    if (t002_1000ms.tick >= t002_1000ms.limit)
                    {
                        t002_1000ms.tick = 0;

                        // -----------------------------------
                        // code is here
                        // -----------------------------------

                        // ------------------------------------------------
                        // 1. Check cycler connection 
                        // ------------------------------------------------
                        int bdcount = m_ucBoard_Status.GetBoardCount();
                        Display_Board_Status bdstatus;

                        // ------------------------------------------------
                        // Build/Modify Board & Channel List
                        // ------------------------------------------------
                        // When Loading form
                        //bool PingisReady = false;
                        // ------------------------------------------------
                        // 3. Display Board Status
                        // ------------------------------------------------                        
                        int sch = 0;
                        int chinfo = 0;
                        string mstr = "";

                        for (int i = 0; i < bdcount; i++)
                        {
                            bdstatus = m_ucBoard_Status.GetBoardStatus(i);

                            // 10초에 한번씩 재연결 시도?
                            //if (m_ucCycler_ABT_List[i].dummycount > 10) m_ucCycler_ABT_List[i].dummycount = 0;

                            m_ucCycler_ABT_List[i].strTCPIP = m_clsSys_Set.m_Sys_BD[i].BD_IP;
                            m_ucCycler_ABT_List[i].strTCPPort = m_clsSys_Set.m_Sys_BD[i].BD_TCP_Port;


                            //PingisReady = false;
                            bPing = m_ucCycler_ABT_List[i].isSocketConnected();
                            if (!bPing && DUPExecution)
                            {
                                //for (int i2 = 0; i2 < m_ucCycler_ABT_List[i].ChannelCount; i2++)
                                //{
                                //    if (IsOnTesting.Length > (m_ucCycler_ABT_List[i].ChannelStartIndex + i2))
                                //    {
                                //        if (IsOnTesting[m_ucCycler_ABT_List[i].ChannelStartIndex + i2])
                                //        {
                                //            IsOnTesting[m_ucCycler_ABT_List[i].ChannelStartIndex + i2] = false;
                                //            EndTest(m_ucCycler_ABT_List[i].ChannelStartIndex + i2);
                                //        }
                                //    }
                                //}

                                if (m_ucCycler_ABT_List[i].isAlived && m_ucCycler_ABT_List[i].isConnected)
                                {
                                    for (int i3 = 0; i3 < m_ucCycler_ABT_List[i].ChannelCount; i3++)
                                    {
                                        m_ucCycler_ABT_List[i].m_ChStatusList[i3].AlarmCode |= (int)TypeOfSafetyViolation.EPO_COMMErr;
                                        CheckSafetyCondition(i3);
                                    }

                                }

                                m_ucCycler_ABT_List[i].isAlived = false;
                                m_ucCycler_ABT_List[i].isConnected = false;

                                // ----------------------
                                // Cycler info. Display
                                // ----------------------
                                bdstatus.bd_s_No = i + 1;
                                bdstatus.bd_s_Conected = false;
                                bdstatus.bd_s_CH_Cnt = m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt; //GHBAIK
                                                                                            //bdstatus.bd_s_CH_Cnt = 0;
                                bdstatus.bd_s_IP_Addr = m_ucCycler_ABT_List[i].strTCPIP;
                                bdstatus.bd_s_CH_Work_Cnt = 0;
                                bdstatus.bd_s_CH_Wait_Cnt = bdstatus.bd_s_CH_Cnt;

                                chinfo = sch + 1;
                                mstr = "";
                                for (int m = 0; m < bdstatus.bd_s_CH_Cnt; m++)
                                {
                                    if (m > 0)
                                    {
                                        mstr = mstr + ", " + chinfo.ToString("D3");
                                    }
                                    else
                                    {
                                        mstr = mstr + chinfo.ToString("D3");
                                    }
                                    chinfo++;
                                }

                                bdstatus.bd_s_Spec = mstr;
                                m_ucBoard_Status.Set_Disp_BD_Status(i, bdstatus);

                                sch += m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;

                                // ----------------------
                                // Check network is alive
                                // ----------------------
                                if (await m_ucCycler_ABT_List[i].PingMs(3))
                                {
                                    if (m_newtype_cycler) m_ucCycler_ABT_List[i].MakeABTSetTimePacket();  // gg
                                    m_ucCycler_ABT_List[i].CONnect();

                                    //if (m_newtype_cycler) m_ucCycler_ABT_List[i].MakeABTSetTimePacket();

                                    if (m_ucCycler_ABT_List[i].isConnected)
                                    {
                                        WriteSystemLog("// Cycler Connectivity=True[Succeed] // Module #" + (i + 1).ToString() + " // PhASE1");
                                    }
                                    else
                                    {
                                        WriteSystemLog("// Cycler Connectivity=False[Fail] // Module #" + (i + 1).ToString() + " // PhASE1");
                                    }

                                    // Safety Checking
                                    SetTimer10msTimer(4, 500);  // 500 msec
                                }

                            }
                            else
                            {

                                if (!bdstatus.bd_s_Conected)
                                {
                                    if (await m_ucCycler_ABT_List[i].PingMs(3))
                                    {
                                        if (m_newtype_cycler) m_ucCycler_ABT_List[i].MakeABTSetTimePacket();

                                        m_ucCycler_ABT_List[i].CONnect();

                                        if (m_ucCycler_ABT_List[i].isConnected)
                                        {
                                            WriteSystemLog("// Cycler Connectivity=True[Succeed] // Module #" + (i + 1).ToString() + " // PhASE2");
                                        }
                                        else
                                        {
                                            WriteSystemLog("// Cycler Connectivity=False[Fail] // Module #" + (i + 1).ToString() + " // PhASE2");
                                        }

                                        // Safety Checking
                                        SetTimer10msTimer(4, 500);  // 500 msec
                                    }
                                }


                                // ----------------------
                                // Cycler info. Display
                                // ----------------------
                                bdstatus.bd_s_No = i + 1;
                                bdstatus.bd_s_Conected = m_ucCycler_ABT_List[i].isConnected;
                                bdstatus.bd_s_CH_Cnt = m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt; //GHBAIK
                                                                                            //bdstatus.bd_s_CH_Cnt = 0;
                                bdstatus.bd_s_IP_Addr = m_ucCycler_ABT_List[i].strTCPIP;


                                // ---------------------------------
                                // WOrking Channel & Waiting Channel
                                // ---------------------------------
                                //int interch = 0;  // ghbaik2

                                mstr = "";
                                chinfo = sch + 1;
                                bdstatus.bd_s_CH_Work_Cnt = 0;
                                for (int m = 0; m < m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt; m++)
                                {
                                    // 전압이 1V보다 크다면 배터리가 연결되어 있는것으로 판단.
                                    if (m_ucCycler_ABT_List[i].m_ChStatusList != null)
                                    {
                                        //if (m_ucCycler_ABT_List[i].m_ChStatusList[m].Current_V > 0.01)  // > 1
                                        if (m_ucCycler_ABT_List[i].m_ChStatusList[m].Current_V >= 0)  // > 1
                                        {
                                            // 동작 채널수
                                            //bdstatus.bd_s_CH_Cnt++;

                                            if (m_ucCycler_ABT_List[i].m_ChStatusList[m].m_step.steptype != cls_stepInfo.enumStepType.STANDBY &&
                                                m_ucCycler_ABT_List[i].m_ChStatusList[m].m_step.steptype != cls_stepInfo.enumStepType.WORK_END)
                                            {
                                                // 사용 채널수
                                                bdstatus.bd_s_CH_Work_Cnt++;
                                            }
                                        }
                                    }

                                    
                                    if (m > 0)
                                    {
                                        mstr = mstr + ", " + chinfo.ToString("D3");
                                    }
                                    else
                                    {
                                        mstr = mstr + chinfo.ToString("D3");
                                    }
                                    chinfo++;
                                    
                                }
                                bdstatus.bd_s_Spec = mstr;

                                // sch = m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;
                                // 231215 BGH
                                sch += m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;
                                //interch += m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;
                                // -----------------------------------
                                bdstatus.bd_s_CH_Wait_Cnt = bdstatus.bd_s_CH_Cnt - bdstatus.bd_s_CH_Work_Cnt;

                                m_ucBoard_Status.Set_Disp_BD_Status(i, bdstatus);

                                // for debugging
                                //try
                                //{
                                //    Debug.WriteLine(m_ucCycler_ABT_List[i].m_ChStatusList[0].isPaused);
                                //}
                                //catch { }
                            }
                        }

                        // ------------------------------------------------
                        // 4. Mapping Boards to Channels
                        // ------------------------------------------------
                        int ch_c_idx = 0;

                        // ------------------------------------------------
                        // 5. Display Channel Status 
                        // ------------------------------------------------
                        int idx_chTotal = 0;
                        //+ Revision by _LBG - 230812 : 전체 CH Loop와 혼동이 되어 변경
                        //int mch = 0;
                        int mDisp_ch = 0;
                        //-
                        Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
                        for (int i = 0; i < bdcount; i++)
                        {
                            for (int m = 0; m < m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt; m++)
                            {
                                mDisp_ch = idx_chTotal + m;
                                m_dispChStatus = SetChannelStatus(idx_chTotal + m);
                                m_ucChannel_Status.Set_Disp_CH_Status(mDisp_ch, m_dispChStatus);
                            }

                            idx_chTotal += m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;

                            for (int m = ch_c_idx; m < idx_chTotal; m++)
                            {
                                Board_Ch_Mapping[m] = i;
                            }
                            ch_c_idx = idx_chTotal;
                        }
                        //-

                        // ------------------------------------
                        // 6. Real Time Graph (Cycler)
                        // ------------------------------------
                        if (m_bGraph_RT_Cycler) 
                            {
                                if (m_Graph_RT_Cycler != null)
                                {
                                    int boardid = Board_Ch_Mapping[m_iCur_CH_NO];  // ghbaik
                                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m_iCur_CH_NO);  // ghbaik2
                                    double vvalue = 0;
                                    double ivalue = 0;
                                    double cvalue = 0;
                                    double tvalue = 0;

                                    #region LoadValues
                                    //try
                                    //{
                                    //    if (m_Graph_RT_Cycler.FirstTime)
                                    //    {
                                    //        m_Graph_RT_Cycler.FirstTime = false;

                                    //        System.IO.FileInfo fi = new FileInfo(logCyclerPath[m_iCur_CH_NO]);
                                    //        if (fi.Exists)
                                    //        {
                                    //            string rln = "";

                                    //            FileStream fstr = new FileStream(logCyclerPath[m_iCur_CH_NO], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                                    //            using (StreamReader sr = new StreamReader(fstr, System.Text.Encoding.UTF8))
                                    //            {
                                    //                while ((rln = sr.ReadLine()) != null)
                                    //                {
                                    //                    var packetlist = rln.Split(',');
                                    //                    if (packetlist.Count() > 7)
                                    //                    {
                                    //                        if (double.TryParse(packetlist[3], out vvalue) &&
                                    //                            double.TryParse(packetlist[4], out ivalue) &&
                                    //                            double.TryParse(packetlist[5], out cvalue))
                                    //                        {
                                    //                            m_Graph_RT_Cycler.Add_Value(vvalue, ivalue, cvalue);
                                    //                        }
                                    //                    }
                                    //                }
                                    //            }
                                    //        }

                                    //    }
                                    //}
                                    //catch (Exception ex)
                                    //{
                                    //    Debug.WriteLine("File:" + ex.Message);
                                    //}
                                    #endregion

                                    try
                                    {
                                        if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                                        {
                                            vvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                                            ivalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                                            cvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q;
                                            tvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;
                                        }
                                        m_Graph_RT_Cycler.Add_Value(vvalue, ivalue, cvalue, tvalue);
                                    }
                                    catch (Exception ex)
                                    {
                                        Debug.WriteLine("Mainframe[TimerEvent100::1467] - " + ex.Message);
                                    }
                                }
                            }

                        // ------------------------------------
                        // 7. Renew Information
                        // ------------------------------------ 
                        if (m_clsAppSet.Enable_Set.Enable_AUX)
                        {
                            //+ Revision by YMJ - 231124 : DAU Min, Max, Diff 구하는 구문 주석처리
                            /*if (m_DAUEnable && m_ucDAU_List != null)
                            {
                            //+Revision by LBG - 230808 : 설정된 DAU 개수 기준 변경
                            //for (int i = 0; i < m_ucDAU_List.Count; i++)
                                for (int i = 0; i < m_NumOfDAU; i++)
                                {
                                    // + Control Enable 조건 체크 추가, 230911
                                    if (m_ucDAU_List[i].ControlEnabled) CalcAUXMinMax(i, 0);
                                }
                            //-
                            }*/
                            //-

                            if (m_BMSEnable && m_ucBMS_List != null)
                            {
                                for (int i = 0; i < m_ucBMS_List.Count; i++)
                                {
                                    // + Control Enable 조건 체크 추가, 230911
                                    if (m_ucBMS_List[i].ControlEnabled) CalcAUXMinMax(i, 2);
                                }
                            }


                            if (m_AUXEnable && m_ucAUX7019_List != null)
                            {
                                for (int i = 0; i < m_ucAUX7019_List.Count; i++)
                                {
                                    // + Control Enable 조건 체크 추가, 230911
                                    if (m_ucAUX7019_List[i].ControlEnabled) CalcAUXMinMax(i, 1);
                                }
                            }

                            //if (m_AUXEnable && m_ucAUX7019_List != null)
                            //{
                            //    for (int i = 0; i < m_ucAUX7019_List.Count; i++)
                            //    {
                            //        CalcAUXMinMax(i, 1);
                            //    }
                            //}

                            if (m_MBIEnable && m_ucMBI_List != null)
                            {
                                int idx;
                                double[] values;

                                if(m_ucMBI_List.Count == 1)
                                {

                                    if (m_ucMBI_List[0].ControlEnabled && m_ucMBI_List[0].Num_of_Volt_ch1 > 0)
                                    {
                                        values = m_ucMBI_List[0].VOLT_Ch1;
                                        if (values != null)
                                        {
                                            idx = values.Length;
                                            if (m_MBI_Volt.Length < idx) idx = m_MBI_Volt.Length;
                                            for (int k = 0; k < idx; k++)
                                            {
                                                m_MBI_Volt[0, k] = values[k];
                                            }
                                        }
                                        CalcAUXMinMax(0, 3);
                                    }

                                    if (m_ucMBI_List[0].ControlEnabled && m_ucMBI_List[0].Num_of_Volt_ch2 > 0)
                                    {
                                        values = m_ucMBI_List[0].VOLT_Ch2;
                                        if (values != null)
                                        {
                                            idx = values.Length;
                                            if (m_MBI_Volt.Length < idx) idx = m_MBI_Volt.Length;
                                            for (int k = 0; k < idx; k++)
                                            {
                                                m_MBI_Volt[1, k] = values[k];
                                            }
                                        }
                                        CalcAUXMinMax(1, 3);
                                    }

                                    if (m_ucMBI_List[0].ControlEnabled && m_ucMBI_List[0].Num_of_Temp_ch1 > 0)
                                    {
                                        //+ Revision by YMJ - 240530 : 채널정보 UI 온도 출력 설정값이 MBI일 경우 처리
                                        double tempSum = 0;
                                        values = m_ucMBI_List[0].TEMP_Ch1;
                                        if (values != null)
                                        {
                                            idx = values.Length;
                                            if (m_MBI_Temp.Length < idx) idx = m_MBI_Temp.Length;
                                            for (int k = 0; k < idx; k++)
                                            {
                                                m_MBI_Temp[0, k] = values[k];
                                                tempSum += values[k];
                                            }
                                        }

                                        double tempAvg = tempSum / values.Length;

                                        if (m_temp_Collect_dev.Equals("MBI"))
                                        {
                                            int boardid = Board_Ch_Mapping[0];
                                            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(0);

                                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = tempAvg;
                                        }
                                        //-
                                    }

                                    if (m_ucMBI_List[0].ControlEnabled && m_ucMBI_List[0].Num_of_Temp_ch2 > 0)
                                    {
                                        //+ Revision by YMJ - 240530 : 채널정보 UI 온도 출력 설정값이 MBI일 경우 처리
                                        double tempSum = 0;
                                        values = m_ucMBI_List[0].TEMP_Ch2;
                                        if (values != null)
                                        {
                                            idx = values.Length;
                                            if (m_MBI_Temp.Length < idx) idx = m_MBI_Temp.Length;
                                            for (int k = 0; k < idx; k++)
                                            {
                                                m_MBI_Temp[1, k] = values[k];
                                                tempSum += values[k];
                                            }
                                        }

                                        double tempAvg = tempSum / values.Length;

                                        if (m_temp_Collect_dev.Equals("MBI"))
                                        {
                                            int boardid = Board_Ch_Mapping[1];
                                            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(1);

                                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = tempAvg;
                                        }
                                        //-
                                    }
                                }
                            }


                            // --------------------------------------
                            // DAU Logging
                            // 231124 주석 풀음, BGH
                            // --------------------------------------
                            if (m_ucDAU_List != null)
                            {
                                if (m_ucDAU_List.Count > 0)
                                {
                                    for (int i2 = 0; i2 < m_NumOfDAU; i2++)
                                    {
                                        List<int> n_ChList = m_clsSys_Link.Get_DAU_CH(i2);

                                        if (m_ucDAU_List[i2].m_AutoLogging[i2])
                                        {
                                            string m_str = "";
                                            if (n_ChList != null && n_ChList.Count > 0)
                                            {
                                                foreach (int ch in n_ChList)
                                                {
                                                    if (m_voltcount_dau[ch] > 0)
                                                    {
                                                        for (int loop1 = 0; loop1 < m_voltcount_dau[ch]; loop1++)
                                                        {
                                                            //+ Revision by KGY -250411 : 오류방지 조건 재설정
                                                            if (loop1 < m_DAU_Volt[ch].Count)
                                                            {
                                                                if (loop1 < (m_voltcount_dau[ch] - 1)) m_str += (m_DAU_Volt[ch][loop1].ToString("F3") + ",");
                                                                else m_str += (m_DAU_Volt[ch][loop1].ToString("F3"));
                                                            }
                                                            else
                                                            {
                                                                m_str += ",";
                                                            }
                                                            //-
                                                        }

                                                    }
                                                }
                                            }
                                            if (n_ChList != null && n_ChList.Count > 0)
                                            {
                                                foreach (int ch in n_ChList)
                                                {
                                                    if (m_tempcount_dau[ch] > 0)
                                                    {
                                                        if (m_voltcount_dau[ch] != 0)
                                                        {
                                                            m_str += ",";
                                                        }
                                                    }

                                                    for (int loop1 = 0; loop1 < m_tempcount_dau[ch]; loop1++)
                                                    {
                                                        //+ Revision by KGY -250411 : 오류방지 조건 재설정
                                                        if (loop1 < m_DAU_Temp[ch].Count)
                                                        {
                                                            if (loop1 < (m_tempcount_dau[ch] - 1)) m_str += (m_DAU_Temp[ch][loop1].ToString("F3") + ",");
                                                            else m_str += (m_DAU_Temp[ch][loop1].ToString("F3"));
                                                        }
                                                        else
                                                        {
                                                            m_str += ",";
                                                        }
                                                        //-
                                                    }
                                                }
                                            } 
                                            m_ucDAU_List[i2].WriteLog(i2, m_str);
                                        }
                                    }
                                }
                            }
                        }

                        bool anyChTesting = false;

                        for (int i = 0; i < idx_chTotal; i++)
                        {
                            // ---------------------
                            // Finalization
                            // ---------------------
                            // 긴급정지버튼 시험관련으로, 일단 주석 처리 230905
                            //if (IsActivateEnding[i] > 0) IsActivateEnding[i]++;
                            //if (IsActivateEnding[i] > 1)
                            //{
                            //    IsActivateEnding[i] = 0;
                            //    EndTest2ndStep(i, false);
                            //}

                            // ---------------------
                            // Renew Ch information
                            // ---------------------
                            //+ Revision by LBG - 231201 : 채널 상세 정보 업데이트 일시 막음
                            //ReNewChDispInformation(i);
                            //-

                            if (m_timelimit[i] > 0)
                            {
                                m_timelimit[i]--;
                                if (m_timelimit[i] == 0)
                                {
                                    int curno = m_ucStepInfo_List[i].m_currentStepNo;
                                    if (curno >= 0)
                                    {
                                        if (m_ucStepInfo_List[i].m_steplist[curno].acia_status == cls_stepInfo.StepACIA.MBT_ON ||
                                            m_ucStepInfo_List[i].m_steplist[curno].acia_status == cls_stepInfo.StepACIA.MBT_ON_W_CYCLER)
                                        {
                                            m_ucMbT_List[i].STOPAcia();
                                            m_ucMbT_List[i].DisCoNnect();
                                        }
                                        else
                                        {
                                            //+ Revisioin by YMJ - 250213 : MxZ 중단 및 연결 종료 수정
                                            m_ucMcz_List[i].StopACIR();
                                            m_ucMcz_List[i].DisConnect();
                                            //-
                                        }

                                        EndCurrentStep(i, eNUM_CutOFF_Type.TIME);
                                        //EndTest(i);
                                    }
                                }
                            }

                            if (m_timelimitSUB[i] > 0)
                            {
                                m_timelimitSUB[i]--;
                                if (m_timelimitSUB[i] == 0)
                                {
                                    int curno = m_ucStepInfo_List[i].m_currentStepNo;
                                    if (curno >= 0)
                                    {
                                        if (m_ucStepInfo_List[i].m_steplist[curno].acia_status == cls_stepInfo.StepACIA.MBT_ON ||
                                        m_ucStepInfo_List[i].m_steplist[curno].acia_status == cls_stepInfo.StepACIA.MBT_ON_W_CYCLER)
                                        {
                                            m_ucMbT_List[i].STOPAcia();
                                            m_ucMbT_List[i].DisCoNnect();
                                        }
                                        else
                                        {
                                            //+ Revisioin by YMJ - 250213 : MxZ 중단 및 연결 종료 수정
                                            m_ucMcz_List[i].StopACIR();
                                            m_ucMcz_List[i].DisConnect();
                                            //-
                                        }
                                    }
                                }
                            }


                            // ---------------------------------------------------------
                            // Balancing 조건이 맞으면 할것.
                            // 현재는 AUX에만 밸런싱 걸어놓았는데, 나중에 DAU로도 확장할것.
                            // ---------------------------------------------------------
                            if (m_clsAppSet.Enable_Set.Enable_AUX && m_AUX_Volt != null)
                            {
                                try { DoBalacing(i); }
                                catch { }
                            }

                            if (IsOnTesting[i])
                            {
                                anyChTesting = true;
                                CheckSafetyCondition(i);
                            }
                            // -------------------------------------------
                            // TEST중이 아닐때 전압 검사
                            // 230921, BGH
                            // -------------------------------------------
                            else
                            {
                                CheckVoltSafetyCondition(i);
                            }
                        }

                        if (m_tVOCEnable && ((anyChTesting==false) || m_ucChamber.EnableFlag == false || m_ucChamber.isConnected==false))
                        {
                            DisptVOCValue(0);
                        }

                        // -----------------------------------
                        // ghbaik
                        // --------
                        // channel error array
                        // -----------------------------------
                        if (m_error == null)
                        {
                            m_error = new int[idx_chTotal];
                            for (int i2 = 0; i2 < idx_chTotal; i2++) m_error[i2] = 0;
                        }
                        else if (m_error.Length != idx_chTotal)
                        {
                            m_error = new int[idx_chTotal];
                            for (int i2 = 0; i2 < idx_chTotal; i2++) m_error[i2] = 0;
                        }

                        // ------------------------------------
                        // 
                        // ------------------------------------
                        DispSafetyWindow();

                        if (m_syslog_list.Count() > 0)
                        {
                            for (int ml = 0; ml < m_syslog_list.Count(); ml++)
                            {
                                logSystem.WriteLine(m_syslog_list[ml]);
                            }
                            logSystem.Flush();
                            m_syslog_list.Clear();
                        }


                        // ---------------------------------------
                        // Reservation
                        // 231003, BGH
                        // ---------------------------------------
                        for (int i = 0; i < idx_chTotal; i++)
                        {
                            if (m_Work_Step_Set != null)
                            {
                                if ((!IsOnTesting[i]) && m_Work_Step_Set.Count > i)
                                {
                                    // -----------------------------------
                                    // 2022년부터 예약 가능함.
                                    // -----------------------------------
                                    if (m_Work_Step_Set[i].Work_Reserve_Use && m_Work_Step_Set[i].Work_Reserve_Time.Year > 2022)
                                    {
                                        DateTime time_start = m_Work_Step_Set[i].Work_Reserve_Time;
                                        DateTime time_now = DateTime.Now;
                                        DateTime time_end = m_Work_Step_Set[i].Work_Reserve_Time.AddSeconds(1);
                                        if (time_start <= time_now && time_now < time_end)
                                        {
                                            // 
                                        }
                                    }
                                }
                            }
                        }

                        DUPExecution = true;
                    }

                    
                }


                // --------------------------------------
                // logging
                // --------------------------------------
                for (int chidx = 0; chidx < IsOnTesting.Length; chidx++)
                {
                    if (IsOnTesting[chidx] && logCond != null)
                    {
                        // --------------------------------------------------
                        // log 10ns --> 100ms 로 이동, bbb
                        // 230822, BGH
                        // --------------------------------------------------
                        // TEST22
                        //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " ----- timer");
                        try
                        {
                            // 231028 BGH
                            int boardid = Board_Ch_Mapping[chidx];  // ghbaik
                            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);  // ghbaik2
                            bool isCellCVStarting = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isCellCVSet;

                            // if ((m_ucStepInfo_List[chidx].isTempPaused) || (m_ucStepInfo_List[chidx].isSafetyTrying) || (m_ucStepInfo_List[chidx].isFirstCC0A) || (!m_ucStepInfo_List[chidx].isRised))
                            if ((m_ucStepInfo_List[chidx].isTempPaused) || (m_ucStepInfo_List[chidx].isSafetyTrying) || 
                                (m_ucStepInfo_List[chidx].isFirstCC0A)  || (!m_ucStepInfo_List[chidx].isRised) ||
                                isCellCVStarting)
                            {                              
                                // --------------------------------------------
                                // 일시정지 상태에서는 data logging 하지 않는다. 
                                // -----------------------------------------------------------
                                // Safety 조건 설정시에는 ACK 올때까지 data logging하지 않는다.
                                // -----------------------------------------------------------
                                // CellCV 전류가 올라가는 중에도 로깅 중지
                                // 231028
                                // -----------------------------------------------------------
                                logBuff[chidx] = logCond[chidx];
                            }
                            else
                            {
                                //+ Revision By YMJ - 240802 : 패턴 로깅 처리 및 디스플레이 시간 관리 수정
                                int stepno = m_ucStepInfo_List[chidx].m_currentStepNo;
                                if (stepno >= 0)
                                {
                                    if (m_ucStepInfo_List[chidx].m_steplist[stepno].steptype == cls_stepInfo.enumStepType.Pattern)
                                    {
                                        //+ Revision by YMJ - 240823 : 패턴 변환 시 riseup 여부 판단하여 작업 진행할 수 있도록 변경
                                        bool riseUpChk = false;
                                        cls_devCyclerABT.struCyclerStatus cyInfo = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];
                                        switch (m_ucUDDS_List[chidx].PatternInfos.type)
                                        {
                                            case 0:
                                                if (Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 0.99 <= Math.Abs(cyInfo.Current_I) && Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 1.01 >= Math.Abs(cyInfo.Current_I))
                                                {
                                                    riseUpChk = true;
                                                }
                                                break;
                                            case 1:
                                                if (Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 0.99 <= Math.Abs(cyInfo.Current_P) && Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 1.01 >= Math.Abs(cyInfo.Current_P))
                                                {
                                                    riseUpChk = true;
                                                }
                                                break;
                                            case 2:
                                                if (Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 0.99 <= cyInfo.Current_V / Math.Abs(cyInfo.Current_I) && Math.Abs(m_ucUDDS_List[chidx].PatternInfos.value) * 1.01 >= cyInfo.Current_V / Math.Abs(cyInfo.Current_I))
                                                {
                                                    riseUpChk = true;
                                                }
                                                break;
                                        }
                                        if (riseUpChk)
                                        {
                                            logBuff[chidx]++;
                                            patternBuff[chidx]++;
                                            //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                                            if (logBuff[chidx] > 1)
                                            //-
                                            {
                                                // ------------------------------------------------
                                                // log 기록간격이 1초 이상일때 Display 처리
                                                // 231024, BGH
                                                // ------------------------------------------------
                                                if (((logBuff[chidx] - 1) % 10) == 0)
                                                {
                                                    AddTickDispTime(chidx, 1000);
                                                    //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " - " + logBuff[chidx].ToString() + " (" + m_ucStepInfo_List[chidx].OGTime_Total_4disp.TotalMilliseconds.ToString() + ")" );                                        
                                                }
                                            }

                                            //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                                            if (doPatternLog[chidx] != 1 && ((logBuff[chidx] - 1) % logCond[chidx]) == 0)
                                            {
                                                WriteBasicLog(chidx, "", eNUM_CutOFF_Type.NONE, false);
                                            }

                                            if (doPatternLog[chidx] == 1)
                                            {
                                                if (m_ucUDDS_List[chidx].FetchNumber != 1)
                                                {
                                                    WriteBasicLog(chidx, "", eNUM_CutOFF_Type.NONE, false);
                                                }
                                                if (logopt[chidx] == 0) { logopt[chidx] = 1; }
                                                //logBuff[chidx] += m_ucUDDS_List[chidx].NextFetchTime / 100;
                                                //logBuff[chidx] = logCond[chidx];

                                                // ----------------------------------------------
                                                // dvlog 
                                                // ----------------------------------------------
                                                // 231126 주석처리함, 이유 : 더이상 사용하지 않음.
                                                #region
                                                //double value1 = 0, value2 = 0;
                                                //if (log_intv_count == log_volt.Count)
                                                //{
                                                //    value1 = Math.Abs(m_ucStepInfo_List[chidx].m_steplist[stepno].wIntv.wCond_Volt); // mV
                                                //    value2 = Math.Abs((log_volt[log_intv_count - 1] - log_volt[0]) * 1000.0);        // V -> mV

                                                //    if (value2 >= value1)
                                                //    {
                                                //        WriteBasicLog(chidx, "delta-V", eNUM_CutOFF_Type.NONE, false);
                                                //    }
                                                //}
                                                //if (log_intv_count == log_curr.Count)
                                                //{
                                                //    value1 = Math.Abs(m_ucStepInfo_List[chidx].m_steplist[stepno].wIntv.wCond_Curr); // mA
                                                //    value2 = Math.Abs((log_curr[log_intv_count - 1] - log_curr[0]) * 1000.0);        // A -> mA

                                                //    if (value2 >= value1)
                                                //    {
                                                //        WriteBasicLog(chidx, "delta-I", eNUM_CutOFF_Type.NONE, false);
                                                //    }
                                                //}
                                                //if (log_intv_count == log_temp.Count)
                                                //{
                                                //    value1 = Math.Abs(m_ucStepInfo_List[chidx].m_steplist[stepno].wIntv.wCond_Temp);
                                                //    value2 = Math.Abs(log_temp[log_intv_count - 1] - log_temp[0]);

                                                //    if (value2 >= value1)
                                                //    {
                                                //        WriteBasicLog(chidx, "delta-T", eNUM_CutOFF_Type.NONE, false);
                                                //    }
                                                //}
                                                #endregion

                                                // -------------------------------------------------
                                                // Pattern Patch
                                                // -------------------------------------------------
                                                doPatternLog[chidx] = 0;
                                                if (chidx < m_ucUDDS_List.Count())
                                                {
                                                    m_ucUDDS_List[chidx].SetNextFetchtime();
                                                    patternBuff[chidx] = 0;
                                                }
                                            }

                                            AddTickStepAndTotalTime(chidx, 4);
                                            //-
                                        }
                                        //-
                                    }
                                    else
                                    {
                                        if (logBuff[chidx] > 1)
                                        {
                                            // ------------------------------------------------
                                            // log 기록간격이 1초 이상일때 Display 처리
                                            // 231024, BGH
                                            // ------------------------------------------------
                                            if (((logBuff[chidx] - 1) % 10) == 0)
                                            {
                                                AddTickDispTime(chidx, 1000);
                                                //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " - " + logBuff[chidx].ToString() + " (" + m_ucStepInfo_List[chidx].OGTime_Total_4disp.TotalMilliseconds.ToString() + ")" );                                        
                                            }
                                            logBuff[chidx]--;
                                        }
                                        else
                                        {
                                            AddTickStepAndTotalTime(chidx, logopt[chidx]);
                                            WriteBasicLog(chidx, "", eNUM_CutOFF_Type.NONE, false);

                                            if (logopt[chidx] == 0) { logopt[chidx] = 1; }
                                            logBuff[chidx] = logCond[chidx];
                                        }
                                    }
                                }
                                //-
                            }

                        }
                        catch { }
                    }
                }

                // ------------------------------------
                // Generate Timer Event
                // 맨위에서 여기로 이동, 0628 BGH
                // ------------------------------------
                OnTick100ms?.Invoke();

                // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)"));

                // ---------------------------------------------------
                // Check AUX/DAU/BMS직결 Cut-Off 처리
                // 1초에서 여기로 이동. 100ms마다 검사하기 위함.
                // ---------------------------------------------------
                // CutOff 조건을 하나라도 만족하면 더 이상 할 필요 없음.
                // ---------------------------------------------------
                string vconv = "";  // 231211
                string fmats = "F3";

                // 231112
                if (Volt_Number_Digit == "F4") fmats = "F4";
                else fmats = "F3";

                for (int chidx = 0; chidx < IsOnTesting.Length; chidx++)
                {
                    if (IsOnTesting[chidx])
                    {
                        // ----------------------------------------------------
                        // AUX에 의한 Cut-Off 검사
                        // ----------------------------------------------------
                        try
                        {
                            bool boolStepEnd = false;
                            // --------------------------------------------------
                            // 231002, BGH
                            // --------------------------------------------------
                            bool boolCVexecuted = false;
                            bool boolCVDUPcheck = false;

                            // ---------------------------------------
                            // 밖으로 빼냄, 231101 BGH
                            // ---------------------------------------
                            // +
                            cls_stepInfo mCurStInfo = new cls_stepInfo(this);
                            int m_cstep = 0;

                            mCurStInfo = m_ucStepInfo_List[chidx];
                            m_cstep = mCurStInfo.m_currentStepNo;
                            // -

                            if (m_clsAppSet.Enable_Set.Enable_AUX)
                            {                                
                                AUX_Volt_Recipe mAxVrecp = new AUX_Volt_Recipe();
                                AUX_Temp_Recipe mAxTrecp = new AUX_Temp_Recipe();

                                int midx = 0;  // index
                                double valueL = 0;  // Lower
                                double valueM = 0;  // Measured
                                double valueH = 0;  // Higher

                                // --------------------------------------------------
                                // 231002, BGH
                                // --------------------------------------------------
                                int smode = 0; // 1 : charge, 2:discharge, 3: pattern
                                bool cv_use = false;

                                // -------------------------------------------
                                // AUX
                                // -------------------------------------------
                                // ------------------------------------
                                // Checking AUX CutOff Condition
                                // ------------------------------------                                                                                

                                // -----------------------------------------------------------------------------
                                // Cell CV용 flah set
                                // 231002, BGH
                                // -----------------------------------------------------------------------------
                                int boardid = Board_Ch_Mapping[chidx];  // ghbaik
                                int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);  // ghbaik2
                                 double curr = 0, volt = 0;
                                //bool isCVstarted = false;

                                boolCVexecuted = false;                         // 현 timer 처리에서 cell cv 실행?
                                boolCVDUPcheck = mCurStInfo.isCellCVexecuted;   // 현재 스텝에서 cell cv 실행한적 있는지
                                cv_use = false;

                                // --------------------------------------------------
                                // 5줄 위로 이동함. 그게 여기
                                // BGH 231105
                                // --------------------------------------------------
                                smode = 0;
                                if (mCurStInfo.m_steplist[m_cstep].steptype == cls_stepInfo.enumStepType.Charge) smode = 1;
                                if (mCurStInfo.m_steplist[m_cstep].steptype == cls_stepInfo.enumStepType.Discharge) smode = 2;
                                if (mCurStInfo.m_steplist[m_cstep].steptype == cls_stepInfo.enumStepType.Pattern) smode = 3;

                                // --------------------------------------------------
                                // CV 조건검사
                                // --------------------------------------------------
                                if (mCurStInfo.m_steplist[m_cstep].stepmode == cls_stepInfo.enumStepMode.CCCV ||
                                    mCurStInfo.m_steplist[m_cstep].stepmode == cls_stepInfo.enumStepMode.CPCV_CP ||
                                    mCurStInfo.m_steplist[m_cstep].stepmode == cls_stepInfo.enumStepMode.CV)
                                {
                                    curr = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                                    volt = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;

                                    // ------------------------------------------------------
                                    // 전류 : 10mA 이상,
                                    // 전압 : 10mV 이상
                                    // ------------------------------------------------------
                                    if (Math.Abs(curr) > 0.01 && volt > 0.01)
                                    {
                                        cv_use = true;
                                    }
                                }

                                // -
                                // -----------------------------------------------------------------------------

                                // ------------------------------------
                                // 채널과 연결된 AUX만 검사하면 된다.
                                // ------------------------------------
                                //if (m_ucAUX7019_List != null)
                                if (m_ucAUX7019_List.Count > 0 && m_AUXEnable && m_ucAUX7019_List != null)
                                {
                                    //for (int i = 0; i < m_ucAUX7019_List.Count; i++)
                                    
                                    boolStepEnd = false;

                                    // 끊어진 연결은 재연결
                                    //if (!m_ucAUX7019_List[chidx].isConnected)
                                    if (!m_ucAUX7019_List[chidx].isConnected && m_ucAUX7019_List[chidx].ControlEnabled)
                                    {
                                        m_ucAUX7019_List[chidx].StartSerial();
                                        WriteSystemLog("// AUX #" + (chidx + 1).ToString() + " Re-Connect // Connectivity=" + m_ucAUX7019_List[chidx].isConnected.ToString() + " // Start " + m_ucAUX7019_List[chidx].SerialPort);
                                    }

                                    if (m_ucAUX7019_List[chidx].ControlEnabled)
                                    {
                                        // --------------------
                                        // Voltage
                                        // --------------------
                                        if (mCurStInfo.m_steplist[m_cstep].lstAUXVolt != null)
                                        {
                                            for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXVolt.Count(); arcp++)
                                            {
                                                mAxVrecp = mCurStInfo.m_steplist[m_cstep].lstAUXVolt[arcp];
                                                if (mAxVrecp.AUX_V_Recipe_Use)
                                                {
                                                    midx = mAxVrecp.AUX_V_Recipe_Idx;  // base 0
                                                    valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                    if (midx <= m_voltcount_aux[chidx])
                                                    {
                                                        valueM = m_AUX_Volt[chidx, midx];
                                                    }

                                                    valueL = mAxVrecp.AUX_V_Recipe_Lower; // + 0.0005; // 0.0001;
                                                    valueH = mAxVrecp.AUX_V_Recipe_Upper; // - 0.0005; // 0.0001;

                                                    // ------------------------------------
                                                    // 231112 BGH
                                                    // ------------------------------------
                                                    vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                    vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                    vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                    if ((valueM > -100.0f) && ((smode == 2 && valueM <= valueL) || (smode == 1 && valueM >= valueH) || (smode == 3 && (valueM >= valueH || valueM <= valueL))))
                                                    {
                                                        // ------------------------------
                                                        // CutOff 조건 만족
                                                        // -------------------------------------
                                                        // 충방전에 따라 방향성 가지고 조건 비교
                                                        // 231102 BGH
                                                        // -------------------------------------
                                                        // +
                                                        m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                        EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_VOLTAGE);
                                                        boolStepEnd = true;
                                                        // -
                                                        break;
                                                    }
                                                }

                                                // -------------------------------------------------------
                                                // CV
                                                // 231002, BGH
                                                // -------------------------------------------------------
                                                if ((!boolCVexecuted) && (!boolCVDUPcheck) && mAxVrecp.AUX_V_CV_Use && cv_use)
                                                {                                                       
                                                    valueM = mAxVrecp.AUX_V_CV_Val;
                                                    if (AUX_V_max != null && AUX_V_min != null && valueM > 0)
                                                    {
                                                        if (AUX_V_min.Length > chidx && AUX_V_max.Length > chidx)
                                                        {
                                                            if (AUX_V_min[chidx] > 0 && AUX_V_max[chidx] > 0)
                                                            {

                                                                valueL = AUX_V_min[chidx]; // - 0.0005;
                                                                valueH = AUX_V_max[chidx]; // + 0.0005;

                                                                // ------------------------------------
                                                                // 231112 BGH
                                                                // ------------------------------------
                                                                vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                                vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                                vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                                if ((smode == 1 && valueH >= valueM) || (smode == 2 && valueL <= valueM))
                                                                {
                                                                    // ------------------------------
                                                                    // cell CV 조건 만족
                                                                    // ------------------------------
                                                                    boolCVexecuted = true;              // 중복검사 방지 in timer

                                                                    mCurStInfo.isCellCVexecuted = true; // 중복실행 방지 in Step
                                                                    m_ucStepInfo_List[chidx] = mCurStInfo;

                                                                    // ---------------------------------------
                                                                    // chstatus 저장
                                                                    // ---------------------------------------
                                                                    m_ucCycler_ABT_List[boardid].SetCVStart(bzch);

                                                                    if (smode == 1)
                                                                    {
                                                                        if (volt < 0) volt *= (-1);
                                                                        if (curr < 0) curr *= (-1);
                                                                    }
                                                                    else
                                                                    {
                                                                        if (volt > 0) volt *= (-1);
                                                                        if (curr > 0) curr *= (-1);
                                                                    }
                                                                    m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, volt, curr);

                                                                    AddTickStepAndTotalTime(chidx, 2);
                                                                    WriteBasicLog(chidx, "CV Cell V [AUX]", eNUM_CutOFF_Type.NONE, false);
                                                                    WriteSystemLog(chidx, ">> CV by Cell V [AUX] : V=" + volt.ToString("F3") + " // I=" + curr.ToString("F3"), true);
                                                                    break;
                                                                }

                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        // --------------------
                                        // Temperature
                                        // --------------------
                                        if (!boolStepEnd && mCurStInfo.m_steplist[m_cstep].lstAUXTemp != null)
                                        {
                                            for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXTemp.Count(); arcp++)
                                            {
                                                mAxTrecp = mCurStInfo.m_steplist[m_cstep].lstAUXTemp[arcp];
                                                if (mAxTrecp.AUX_T_Recipe_Use)
                                                {
                                                    midx = mAxTrecp.AUX_T_Recipe_Idx;  // base 0
                                                    valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                    // if (midx <= m_AUX_Temp.GetLength(1))
                                                    if (midx <= m_tempcount_aux[chidx])
                                                    {
                                                        valueM = m_AUX_Temp[chidx, midx];
                                                    }

                                                    valueL = mAxTrecp.AUX_T_Recipe_Lower + 0.0005; // 0.0001;
                                                    valueH = mAxTrecp.AUX_T_Recipe_Upper - 0.0005; // 0.0001;

                                                    if ((valueM > -100.0f) && (valueM < 100.0f) && (valueM <= valueL || valueM >= valueH))
                                                    {
                                                        // ------------------------------
                                                        // CutOff 조건 만족
                                                        // ------------------------------
                                                        m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                        //EndCurrentStep(chidx, eNUM_CutOFF_Type.TEMPERATURE);
                                                        //+ Revision by KGY -250421: 온도 종료 AUX온도 종료로 변경
                                                        EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_TEMP);
                                                        //-
                                                        boolStepEnd = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                // -------------------------------------------
                                // DAU
                                // -------------------------------------------
                                if (!boolStepEnd && m_ucDAU_List != null && m_DAUEnable)
                                {
                                    // ------------------------------------
                                    // 채널과 연결된 AUX만 검사하면 된다.
                                    // Loop 돌리면 안됨. 
                                    // 나중에 수정할것. 
                                    // 현재 상태는 채널별로 분리가 안되는 형태임.
                                    // ------------------------------------

                                    // + Control Enable 조건 체크 추가, 230911
                                    int dauIndex = m_clsSys_Link.Get_DAU_Index(chidx);

                                    if (dauIndex != -1 && m_ucDAU_List[0].m_CtrlEnabled[dauIndex])
                                    {

                                        // --------------------
                                        // Voltage
                                        // --------------------
                                        if (mCurStInfo.m_steplist[m_cstep].lstAUXVolt != null)
                                        {
                                            for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXVolt.Count(); arcp++)
                                            {
                                                mAxVrecp = mCurStInfo.m_steplist[m_cstep].lstAUXVolt[arcp];
                                                if (mAxVrecp.AUX_V_Recipe_Use)
                                                {
                                                    midx = mAxVrecp.AUX_V_Recipe_Idx;  // base 0
                                                    valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                    // if (midx <= m_DAU_Volt.GetLength(1))
                                                    if (midx <= m_DAU_Volt[chidx].Count)
                                                    {
                                                        valueM = m_DAU_Volt[chidx][midx];
                                                    }

                                                    valueL = mAxVrecp.AUX_V_Recipe_Lower; // + 0.0005; // 0.0001;
                                                    valueH = mAxVrecp.AUX_V_Recipe_Upper; // - 0.0005; // 0.0001;

                                                        
                                                    // ------------------------------------
                                                    // 231112 BGH
                                                    // ------------------------------------
                                                    vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                    vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                    vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                    if ((valueM > -100.0f) && ((smode == 2 && valueM <= valueL) || (smode == 1 && valueM >= valueH) || (smode == 3 && (valueM >= valueH || valueM <= valueL))))
                                                    {
                                                        // ------------------------------
                                                        // CutOff 조건 만족
                                                        // -------------------------------------
                                                        // 충방전에 따라 방향성 가지고 조건 비교
                                                        // 231102 BGH
                                                        // -------------------------------------
                                                        // +
                                                        m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                        EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_VOLTAGE);
                                                        boolStepEnd = true;
                                                        // -
                                                        break;
                                                    }
                                                }

                                                // -------------------------------------------------------
                                                // CV
                                                // 231002, BGH
                                                // -------------------------------------------------------
                                                if ((!boolCVexecuted) && (!boolCVDUPcheck) && mAxVrecp.AUX_V_CV_Use && cv_use)
                                                // --------------------------------------------------------------------------------------
                                                // !boolCVexecuted : 현재 Timer에서 Cell CV가 실행되지 않았음
                                                // !boolCVDUPcheck : 현재 Step에서 Cell CV가 실행되지 않았음
                                                // mAxVrecp.AUX_V_CV_Use : Cell CV 사용이 Enabled
                                                // cv_use : Cell CV를 적용할 조건 (CCCV/CPCV/CV 모드이고 전류 및 전압값이 1mA/1mV보다 클것등)
                                                // --------------------------------------------------------------------------------------
                                                {
                                                    //+ Revision by KGY - 2025.04.25 : 각 Cell에 맞는 Target CV값 적용
                                                    //valueM = mAxVrecp.AUX_V_CV_Val;
                                                    double n_valueT = mAxVrecp.AUX_V_CV_Val;
                                                    midx = mAxVrecp.AUX_V_Recipe_Idx;
                                                    //+ Revision by YMJ - 231124 : Min, Max 비교 파라미터 변경
                                                    //if (m_DAU_V_Max != null && m_DAU_V_Min != null && valueM > 0)
                                                    if (chidx < m_DAU_Volt.Count() && midx < m_DAU_Volt[chidx].Count)
                                                    {
                                                        double n_valueC = m_DAU_Volt[chidx][midx];
                                                        //if (m_DAU_V_Min.Length > chidx && m_DAU_V_Max.Length > chidx)
                                                        {
                                                            if (n_valueC > 0)
                                                            //if (m_DAU_V_Min[chidx] > 0 && m_DAU_V_Max[chidx] > 0)
                                                            {
                                                                //valueL = DAU_V_min[chidx]; // - 0.0005;
                                                                //valueH = DAU_V_max[chidx]; // + 0.0005;
                                                                //valueL = m_DAU_V_Min[chidx]; // - 0.0005;
                                                                //valueH = m_DAU_V_Max[chidx]; // + 0.0005;
                                                                //-

                                                                // ------------------------------------
                                                                // 231112 BGH
                                                                // ------------------------------------
                                                                //vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                                //vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                                //vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);
                                                                vconv = n_valueT.ToString(fmats); double.TryParse(vconv, out n_valueT);
                                                                vconv = n_valueC.ToString(fmats); double.TryParse(vconv, out n_valueC);

                                                                if ((smode == 1 && n_valueC >= n_valueT) || (smode == 2 && n_valueC <= n_valueT))
                                                                {
                                                                    // ------------------------------
                                                                    // cell CV 조건 만족
                                                                    // ------------------------------
                                                                    boolCVexecuted = true;              // 중복검사 방지 in timer

                                                                    mCurStInfo.isCellCVexecuted = true; // 중복실행 방지 in Step
                                                                    m_ucStepInfo_List[chidx] = mCurStInfo;
                                                                       
                                                                    // ---------------------------------------
                                                                    // chstatus 저장
                                                                    // ---------------------------------------
                                                                    m_ucCycler_ABT_List[boardid].SetCVStart(bzch);
                                                                    if (smode == 1)
                                                                    {
                                                                        if (volt < 0) volt *= (-1);
                                                                        if (curr < 0) curr *= (-1);
                                                                    }
                                                                    else
                                                                    {
                                                                        if (volt > 0) volt *= (-1);
                                                                        if (curr > 0) curr *= (-1);
                                                                    }
                                                                    m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, volt, curr);
                                                                    //+ Revision by KGY - 2025.04.28 : RiseUP 도중에 Cell CV 값에 도달 할 경우 Step이 시작 안함
                                                                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[chidx].isRisedUp)
                                                                    {
                                                                        AddTickStepAndTotalTime(chidx, 2);
                                                                    }
                                                                    else
                                                                    {
                                                                        m_ucCycler_ABT_List[boardid].m_ChStatusList[chidx].isCellCVRiseUP = true;
                                                                    }
                                                                    //-
                                                                    WriteBasicLog(chidx, "CV Cell V [DAU]", eNUM_CutOFF_Type.NONE, false);
                                                                    WriteSystemLog(chidx, ">> CV by Cell V [DAU] : V=" + volt.ToString("F3") + " // I=" + curr.ToString("F3"), true);

                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    //-
                                                }
                                            }
                                        }

                                        // --------------------
                                        // Temperature
                                        // --------------------
                                        if (!boolStepEnd && mCurStInfo.m_steplist[m_cstep].lstAUXTemp != null)
                                        {
                                            for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXTemp.Count(); arcp++)
                                            {
                                                mAxTrecp = mCurStInfo.m_steplist[m_cstep].lstAUXTemp[arcp];
                                                if (mAxTrecp.AUX_T_Recipe_Use)
                                                {
                                                    midx = mAxTrecp.AUX_T_Recipe_Idx;  // base 0
                                                    valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                    // if (midx <= m_DAU_Temp.GetLength(1))
                                                    if (midx <= m_tempcount_dau[chidx])
                                                    {
                                                        valueM = m_DAU_Temp[chidx][midx];
                                                    }

                                                    valueL = mAxTrecp.AUX_T_Recipe_Lower + 0.0005; // 0.0001;
                                                    valueH = mAxTrecp.AUX_T_Recipe_Upper - 0.0005; // 0.0001;

                                                    if ((valueM > -100.0f) && (valueM < 100.0f) && (valueM <= valueL || valueM >= valueH))
                                                    {
                                                        // ------------------------------
                                                        // CutOff 조건 만족
                                                        // ------------------------------
                                                        m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                        //EndCurrentStep(chidx, eNUM_CutOFF_Type.TEMPERATURE);
                                                        //+ Revision by KGY -250421: 온도 종료 AUX온도 종료로 변경
                                                        EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_TEMP);
                                                        //-
                                                        boolStepEnd = true;
                                                        break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                    
                                }

                                // -------------------------------------------
                                // IONIQ5 & BMS
                                // -------------------------------------------
                                if (!boolStepEnd && m_ucBMS_List != null && m_BMSEnable)
                                {
                                    // 재연결 관련 Safety등 고려할것.

                                    // for (int i = 0; i < m_ucBMS_List.Count; i++)
                                    if (m_ucBMS_List.Count > chidx)
                                    {
                                        // + Control Enable 조건 체크 추가, 230911
                                        if (m_ucBMS_List[chidx].ControlEnabled)
                                        {
                                            // --------------------
                                            // Voltage
                                            // --------------------
                                            if (mCurStInfo.m_steplist[mCurStInfo.m_currentStepNo].lstAUXVolt != null)
                                            {
                                                // int iloop = m_ucBMS_List[i].m_ListIdx;
                                                for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXVolt.Count(); arcp++)
                                                {
                                                    mAxVrecp = mCurStInfo.m_steplist[m_cstep].lstAUXVolt[arcp];
                                                    if (mAxVrecp.AUX_V_Recipe_Use)
                                                    {
                                                        midx = mAxVrecp.AUX_V_Recipe_Idx;  // base 0
                                                        valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                        // if (midx <= m_BMS_Volt.GetLength(1))
                                                        if (midx <= m_voltcount_bms[chidx])
                                                        {
                                                            valueM = m_BMS_Volt[chidx, midx];
                                                        }

                                                        valueL = mAxVrecp.AUX_V_Recipe_Lower; // + 0.0005; // 0.0001;
                                                        valueH = mAxVrecp.AUX_V_Recipe_Upper; // - 0.0005; // 0.0001;

                                                        // ------------------------------------
                                                        // 231112 BGH
                                                        // ------------------------------------
                                                        vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                        vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                        vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                        if ((valueM > -100.0f) && ((smode == 2 && valueM <= valueL) || (smode == 1 && valueM >= valueH) || (smode == 3 && (valueM >= valueH || valueM <= valueL))))
                                                        {
                                                            // ------------------------------
                                                            // CutOff 조건 만족
                                                            // -------------------------------------
                                                            // 충방전에 따라 방향성 가지고 조건 비교
                                                            // 231102 BGH
                                                            // -------------------------------------
                                                            // +
                                                            m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_VOLTAGE);
                                                            boolStepEnd = true;
                                                            // -
                                                            break;
                                                        }
                                                    }

                                                    // -------------------------------------------------------
                                                    // CV
                                                    // 231002, BGH
                                                    // -------------------------------------------------------
                                                    if ((!boolCVexecuted) && (!boolCVDUPcheck) && mAxVrecp.AUX_V_CV_Use && cv_use)
                                                    {
                                                        valueM = mAxVrecp.AUX_V_CV_Val;
                                                        if (BMS_V_max != null && BMS_V_min != null && valueM > 0)
                                                        {
                                                            if (BMS_V_min.Length > chidx && BMS_V_max.Length > chidx)
                                                            {
                                                                if (BMS_V_min[chidx] > 0 && BMS_V_max[chidx] > 0)
                                                                {
                                                                    valueL = BMS_V_min[chidx]; // - 0.0005;
                                                                    valueH = BMS_V_max[chidx]; // + 0.0005;

                                                                    // ------------------------------------
                                                                    // 231112 BGH
                                                                    // ------------------------------------
                                                                    vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                                    vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                                    vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                                    if ((smode == 1 && valueH >= valueM) || (smode == 2 && valueL <= valueM))
                                                                    {
                                                                        // ------------------------------
                                                                        // cell CV 조건 만족
                                                                        // ------------------------------
                                                                        boolCVexecuted = true;              // 중복검사 방지 in timer

                                                                        mCurStInfo.isCellCVexecuted = true; // 중복실행 방지 in Step
                                                                        m_ucStepInfo_List[chidx] = mCurStInfo;

                                                                        // ---------------------------------------
                                                                        // chstatus 저장
                                                                        // ---------------------------------------
                                                                        m_ucCycler_ABT_List[boardid].SetCVStart(bzch);
                                                                        if (smode == 1)
                                                                        {
                                                                            if (volt < 0) volt *= (-1);
                                                                            if (curr < 0) curr *= (-1);
                                                                        }
                                                                        else
                                                                        {
                                                                            if (volt > 0) volt *= (-1);
                                                                            if (curr > 0) curr *= (-1);
                                                                        }
                                                                        m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, volt, curr);

                                                                        AddTickStepAndTotalTime(chidx, 2);
                                                                        WriteBasicLog(chidx, "CV Cell V [BMS]", eNUM_CutOFF_Type.NONE, false);
                                                                        WriteSystemLog(chidx, ">> CV by Cell V [BMS] : V=" + volt.ToString("F3") + " // I=" + curr.ToString("F3"), true);
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // --------------------
                                            // Temperature
                                            // --------------------
                                            if (!boolStepEnd && mCurStInfo.m_steplist[m_cstep].lstAUXTemp != null)
                                            {
                                                for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXTemp.Count(); arcp++)
                                                {
                                                    mAxTrecp = mCurStInfo.m_steplist[m_cstep].lstAUXTemp[arcp];
                                                    if (mAxTrecp.AUX_T_Recipe_Use)
                                                    {
                                                        midx = mAxTrecp.AUX_T_Recipe_Idx;  // base 0
                                                        valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                        // if (midx <= m_DAU_Temp.GetLength(1))
                                                        if (midx <= m_tempcount_bms[chidx])
                                                        {
                                                            valueM = m_BMS_Temp[chidx, midx];
                                                        }

                                                        valueL = mAxTrecp.AUX_T_Recipe_Lower + 0.0005; // 0.0001;
                                                        valueH = mAxTrecp.AUX_T_Recipe_Upper - 0.0005; // 0.0001;

                                                        if ((valueM > -100.0f) && (valueM < 100.0f) && (valueM <= valueL || valueM >= valueH))
                                                        {
                                                            // ------------------------------
                                                            // CutOff 조건 만족
                                                            // ------------------------------
                                                            m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                            //EndCurrentStep(chidx, eNUM_CutOFF_Type.TEMPERATURE);
                                                            //+ Revision by KGY -250421: 온도 종료 AUX온도 종료로 변경
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_TEMP);
                                                            //-
                                                            boolStepEnd = true;
                                                            break;
                                                        }
                                                    }
                                                }

                                            }
                                        }
                                    }
                                }

                                // -------------------------------------------
                                // MBI
                                // -------------------------------------------
                                if (!boolStepEnd && m_ucMBI_List != null && m_MBIEnable)
                                {
                                    // ------------------------------------
                                    // 채널과 연결된 AUX만 검사하면 된다.
                                    // Loop 돌리면 안됨. 
                                    // 나중에 수정할것. 
                                    // 현재 상태는 채널별로 분리가 안되는 형태임.
                                    // ------------------------------------
                                    // for (int i = 0; i < m_ucDAU_List.Count; i++)
                                    if (m_NumOfMBI > chidx)
                                    {
                                        // + Control Enable 조건 체크 추가, 230911
                                        if (m_ucMBI_List[chidx/2].ControlEnabled)
                                        {
                                            // --------------------
                                            // Voltage
                                            // --------------------
                                            if (mCurStInfo.m_steplist[m_cstep].lstAUXVolt != null)
                                            {
                                                for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXVolt.Count(); arcp++)
                                                {
                                                    mAxVrecp = mCurStInfo.m_steplist[m_cstep].lstAUXVolt[arcp];
                                                    if (mAxVrecp.AUX_V_Recipe_Use)
                                                    {
                                                        midx = mAxVrecp.AUX_V_Recipe_Idx;  // base 0
                                                        valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                        if (midx <= m_voltcount_mbi[chidx])
                                                        {
                                                            valueM = m_MBI_Volt[chidx, midx];
                                                        }

                                                        valueL = mAxVrecp.AUX_V_Recipe_Lower; // + 0.0005; // 0.0001;
                                                        valueH = mAxVrecp.AUX_V_Recipe_Upper; // - 0.0005; // 0.0001;

                                                        // ------------------------------------
                                                        // 231112 BGH
                                                        // ------------------------------------
                                                        vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                        vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                        vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                        if ((valueM > -100.0f) && ((smode == 2 && valueM <= valueL) || (smode == 1 && valueM >= valueH) || (smode == 3 && (valueM >= valueH || valueM <= valueL))))
                                                        {
                                                            // ------------------------------
                                                            // CutOff 조건 만족
                                                            // -------------------------------------
                                                            // 충방전에 따라 방향성 가지고 조건 비교
                                                            // 231102 BGH
                                                            // -------------------------------------
                                                            // +
                                                            m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_VOLTAGE);
                                                            boolStepEnd = true;
                                                            // -
                                                            break;
                                                        }
                                                    }

                                                    // -------------------------------------------------------
                                                    // CV
                                                    // 231002, BGH
                                                    // -------------------------------------------------------
                                                    if ((!boolCVexecuted) && (!boolCVDUPcheck) && mAxVrecp.AUX_V_CV_Use && cv_use)
                                                    {
                                                        valueM = mAxVrecp.AUX_V_CV_Val;
                                                        if (MBI_V_max != null && MBI_V_min != null && valueM > 0)
                                                        {
                                                            if (MBI_V_min.Length > chidx && MBI_V_max.Length > chidx)
                                                            {
                                                                if (MBI_V_min[chidx] > 0 && MBI_V_max[chidx] > 0)
                                                                {
                                                                    valueL = MBI_V_min[chidx] - 0.0005;
                                                                    valueH = MBI_V_max[chidx] + 0.0005;

                                                                    // ------------------------------------
                                                                    // 231112 BGH
                                                                    // ------------------------------------
                                                                    vconv = valueM.ToString(fmats); double.TryParse(vconv, out valueM);
                                                                    vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                                                                    vconv = valueH.ToString(fmats); double.TryParse(vconv, out valueH);

                                                                    if ((smode == 1 && valueH >= valueM) || (smode == 2 && valueL <= valueM))
                                                                    {
                                                                        // ------------------------------
                                                                        // cell CV 조건 만족
                                                                        // ------------------------------
                                                                        boolCVexecuted = true;              // 중복검사 방지 in timer

                                                                        mCurStInfo.isCellCVexecuted = true; // 중복실행 방지 in Step
                                                                        m_ucStepInfo_List[chidx] = mCurStInfo;

                                                                        // ---------------------------------------
                                                                        // chstatus 저장
                                                                        // ---------------------------------------
                                                                        m_ucCycler_ABT_List[boardid].SetCVStart(bzch);
                                                                        if (smode == 1)
                                                                        {
                                                                            if (volt < 0) volt *= (-1);
                                                                            if (curr < 0) curr *= (-1);
                                                                        }
                                                                        else
                                                                        {
                                                                            if (volt > 0) volt *= (-1);
                                                                            if (curr > 0) curr *= (-1);
                                                                        }
                                                                        m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, volt, curr);

                                                                        AddTickStepAndTotalTime(chidx, 2);
                                                                        WriteBasicLog(chidx, "CV Cell V [MBI]", eNUM_CutOFF_Type.NONE, false);
                                                                        WriteSystemLog(chidx, ">> CV by Cell V [MBI] : V=" + volt.ToString("F3") + " // I=" + curr.ToString("F3"), true);
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // --------------------
                                            // Temperature
                                            // --------------------
                                            if (!boolStepEnd && mCurStInfo.m_steplist[m_cstep].lstAUXTemp != null)
                                            {
                                                for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXTemp.Count(); arcp++)
                                                {
                                                    mAxTrecp = mCurStInfo.m_steplist[m_cstep].lstAUXTemp[arcp];
                                                    if (mAxTrecp.AUX_T_Recipe_Use)
                                                    {
                                                        midx = mAxTrecp.AUX_T_Recipe_Idx;  // base 0
                                                        valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                        if (midx <= m_tempcount_mbi[chidx])
                                                        {
                                                            valueM = m_MBI_Temp[chidx, midx];
                                                        }

                                                        valueL = mAxTrecp.AUX_T_Recipe_Lower + 0.0005; // 0.0001;
                                                        valueH = mAxTrecp.AUX_T_Recipe_Upper - 0.0005; // 0.0001;

                                                        if ((valueM > -100.0f) && (valueM < 100.0f) && (valueM <= valueL || valueM >= valueH))
                                                        {
                                                            // ------------------------------
                                                            // CutOff 조건 만족
                                                            // ------------------------------
                                                            m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                            //EndCurrentStep(chidx, eNUM_CutOFF_Type.TEMPERATURE);
                                                            //+ Revision by KGY -250421: 온도 종료 AUX온도 종료로 변경
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_TEMP);
                                                            //-
                                                            boolStepEnd = true;
                                                            break;
                                                        }
                                                    }
                                                }

                                            }
                                        }
                                    }
                                }

                                //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위), CUTOFF 채널별 연결된 센서 단위로 가능
                                //+ Add by YMJ - 241115 : CREVIS 장비 CutOff 기능 추가(채널별 온도센서 1:1매칭)
                                if (!boolStepEnd && m_ucCREVIS_List != null && m_ucCREVIS_List.Count > 0 && m_CREVISEnable)
                                {
                                    for (int i = 0; i < m_NumOfCREVIS; i++)
                                    {
                                        if (!m_ucCREVIS_List[i].isConnected && m_ucCREVIS_List[i].ControlEnabled)
                                        {
                                            m_ucCREVIS_List[i].StartTCP();
                                            WriteSystemLog("// CREVIS #" + (i + 1).ToString() + " Re-Connect // Connectivity=" + m_ucCREVIS_List[i].isConnected.ToString() + " // Start " + m_ucCREVIS_List[i].IP_Address + ":" + m_ucCREVIS_List[i].IP_Port);
                                        }

                                        if (m_ucCREVIS_List[i].ControlEnabled)
                                        {
                                            if (!boolStepEnd && mCurStInfo.m_steplist[m_cstep].lstAUXTemp != null)
                                            {
                                                for (int arcp = 0; arcp < mCurStInfo.m_steplist[m_cstep].lstAUXTemp.Count(); arcp++)
                                                {
                                                    mAxTrecp = mCurStInfo.m_steplist[m_cstep].lstAUXTemp[arcp];
                                                    if (mAxTrecp.AUX_T_Recipe_Use)
                                                    {
                                                        midx = mAxTrecp.AUX_T_Recipe_Idx;  // base 0
                                                        valueM = -2000;   // 초기값으로 말도 않되는 값 부여해서 값이 계측되는지 확인

                                                        if (midx <= m_CREVIS_DEVISION)
                                                        {
                                                            valueM = m_CREVIS_Temp[chidx, midx];
                                                        }

                                                        valueL = mAxTrecp.AUX_T_Recipe_Lower + 0.0005; // 0.0001;
                                                        valueH = mAxTrecp.AUX_T_Recipe_Upper - 0.0005; // 0.0001;

                                                        if ((valueM > -100.0f) && (valueM < 100.0f) && (valueM <= valueL || valueM >= valueH))
                                                        {
                                                            // ------------------------------
                                                            // CutOff 조건 만족
                                                            // ------------------------------
                                                            m_AuxEndStepNumber[chidx] = mAxVrecp.AUX_V_Recipe_Step;
                                                            if (m_temp_Collect_dev.Equals("CREVIS"))
                                                            {
                                                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = valueM;
                                                            }
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.AUX_TEMP);
                                                            boolStepEnd = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                //-
                                //-
                            }

                            // ------------------------------------------------------------------
                            // CAN Cut-Off (로깅은?)
                            // ------------------------------------------------------------------
                            if (!boolStepEnd && m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable)
                            {
                                double valueL = 0;  // Lower
                                double valueM = 0;  // Measured
                                double valueH = 0;  // Higher

                                if (m_ucCAN_List != null && mCurStInfo != null && m_cstep > 0)
                                {
                                    if (m_cstep < mCurStInfo.m_steplist.Count())
                                    {
                                        // + Control Enable 조건 체크 추가, 230911
                                        if (m_ucCAN_List[chidx].isConnected && m_ucCAN_List[chidx].ControlEnabled)
                                        {
                                            List<cls_devCAN.MDBC_PARSE> mdbc_list = m_ucCAN_List[chidx].CAN_List;
                                            if (mdbc_list != null)
                                            {
                                                for (int i3 = 0; i3 < mdbc_list.Count; i3++)
                                                {
                                                    //+ Revision by YMJ - 250723 : CAN CutOff 모든 Step Mode에서 동작하도록, 미사용 값인 -999999에서는 적용되지 않도록 변경
                                                    //+ Revision by YMJ - 241028 : CutOff 조건이 0일 수도 있으므로 수정, value 값도 0일 수 있으므로 수정
                                                    if (mdbc_list[i3].CutOffCheck && mdbc_list[i3].Value != -999999)
                                                    //-
                                                    {
                                                        valueM = mdbc_list[i3].Value;
                                                        valueL = mdbc_list[i3].CutOff_L;
                                                        valueH = mdbc_list[i3].CutOff_H;

                                                        if (valueM <= valueL && valueL != -999999)
                                                        {
                                                            m_AuxEndStepNumber[chidx] = mdbc_list[i3].moveStep; // mAxVrecp.AUX_V_Recipe_Step;
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.CAN);
                                                            boolStepEnd = true;
                                                            // -                                                            
                                                            break;
                                                        }
                                                        if(valueM >= valueH && valueH != -999999)
                                                        {
                                                            m_AuxEndStepNumber[chidx] = mdbc_list[i3].moveStep; // mAxVrecp.AUX_V_Recipe_Step;
                                                            EndCurrentStep(chidx, eNUM_CutOFF_Type.CAN);
                                                            boolStepEnd = true;
                                                            // -                                                            
                                                            break;
                                                        }
                                                    }
                                                    //-
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch { }


                        // ------------------------------------------------
                        // 231126, delta
                        // BGH
                        // +
                        // ------------------------------------------------
                        try
                        {
                            // ----------------------------------------
                            // 231126 BGH
                            // 아래에서 여기로 이동
                            // ----------------------------------------
                            int boardid = 0;
                            int bzch = 0;
                            double curr = 0, volt = 0, temp = 0;
                            bool isrisedup = false;
                            try
                            {
                                boardid = Board_Ch_Mapping[chidx];
                                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);

                                volt = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                                curr = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                                temp = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;
                                if (temp < -40 || temp > 100) temp = -50;

                                isrisedup |= m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isRisedUp;
                                isrisedup |= m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isRisedUpPattern;
                            }
                            catch { }

                            try
                            {
                                if (m_ucStepInfo_List[chidx].isRised && isrisedup)
                                {
                                    // ----------------------------------------------
                                    // dvlog 
                                    // ----------------------------------------------
                                    #region
                                    if (log_volt_delta[chidx] >= 0.001 && log_volt_backup[chidx] >= 0.01)
                                    {
                                        if ((log_volt_backup[chidx] - volt) >= log_volt_delta[chidx])
                                        {
                                            AddTickStepAndTotalTime(chidx, 2);
                                            WriteBasicLog(chidx, "delta-V", eNUM_CutOFF_Type.deltaVoltage, false);
                                            log_volt_backup[chidx] = volt;
                                        }
                                    }
                                    if (log_curr_delta[chidx] >= 0.001 && log_curr_backup[chidx] >= 0.001)
                                    {
                                        if ((Math.Abs(log_curr_backup[chidx]) - Math.Abs(curr)) >= Math.Abs(log_curr_delta[chidx]))
                                        {
                                            AddTickStepAndTotalTime(chidx, 2);
                                            WriteBasicLog(chidx, "delta-I", eNUM_CutOFF_Type.deltaCurrent, false);
                                            log_curr_backup[chidx] = curr;
                                        }
                                    }
                                    if (log_temp_delta[chidx] >= 0.1 && temp > -40 && log_temp_backup[chidx] > -50)
                                    {
                                        if ((Math.Abs(log_temp_backup[chidx] - Math.Abs(temp)) >= Math.Abs(log_temp_delta[chidx])))
                                        {
                                            AddTickStepAndTotalTime(chidx, 2);
                                            WriteBasicLog(chidx, "delta-T", eNUM_CutOFF_Type.deltaTemp, false);
                                            log_temp_backup[chidx] = temp;
                                        }
                                    }
                                    #endregion
                                }
                            }
                            catch { }
                        }
                        catch { }
                        // -
                        // ----------------------------------------------

                        // ----------------------------------------------------------------
                        // Chamber Temperature
                        // 230917, cls_devCyclerABT.cs에서 이곳으로 이동
                        // 챔버 연동시 개별 채널 제어에서 대표 채널 운용으로 변경
                        //----------------------------------------------------------------
                        try
                        {
                            if (m_ucChamber.isConnected && SetChamberMaintainUsage && ChlistMaintain.Count > 0)
                            {

                                // --------------------------------------------------------------------------
                                // 231203 BGH
                                // 챔버 변경만 날리고 스텝 전개하는 경우, 목표 온도 도달하면 이경우는 무시해야 한다.
                                // --------------------------------------------------------------------------
                                cls_stepInfo mCurStInfo = new cls_stepInfo(this);
                                int m_cstep = 0;
                                if (m_ucStepInfo_List != null && m_ucStepInfo_List.Count > chidx)
                                {
                                    mCurStInfo = m_ucStepInfo_List[chidx];
                                    m_cstep = mCurStInfo.m_currentStepNo;
                                }

                                // if (ChlistMaintain[0] == chidx)
                                // 231204 BGH
                                if (ChlistMaintain[0] == chidx && m_cstep > 0 && mCurStInfo.m_steplist[m_cstep].Chamber_MaintainUse)
                                {
                                    
                                    int boardid = Board_Ch_Mapping[chidx];  // ghbaik
                                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);  // ghbaik2
                                    bool bfound = false;
                                    double setSP = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_SP;
                                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                                    double setH_SP = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_Humidity_S;
                                    
                                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step.TotalMinutes >= 240) bfound = true;

                                    //+ Revision by LBG - 250821 : Simpac, TEMI2500의 경우 습도도 Wait 조건으로 추가
                                    //if (Math.Abs(setSP - mPV_Limit) < 0.1)
                                    if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC || m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                                    {
                                        if (Math.Abs(setSP - mPV_Limit) < 0.1 && Math.Abs(setH_SP - m_H_PV) < 0.1)
                                        {
                                            bfound = true;
                                        }
                                    }
                                    else
                                    {
                                        if (Math.Abs(setSP - mPV_Limit) < 0.1)
                                        {
                                            bfound = true;
                                        }
                                    }
                                    //-
                                    //-

                                    if (bfound)
                                    {
                                        // -----------------------
                                        // 이곳 재방문 금지
                                        // -----------------------
                                        ChamberWait_cyclerABT();
                                    }
                                }
                            }
                        }
                        catch { }
                        // -----------------------------------------------------------------
                        // Chamber Waiting 중 Cut-Off 조건이 발생하면??
                        // BGH 230909
                        // -----------------------------------------------------------------
                    }
                }

                // --------------------------
                // 30 sec
                // --------------------------
                if (t005_30sec.enable)
                {
                    t005_30sec.tick++;
                    if (t005_30sec.tick >= t005_30sec.limit)
                    {
                        t005_30sec.tick = 0;
                        for (int chidx = 0; chidx < IsOnTesting.Length; chidx++)
                        {
                            if (IsOnTesting[chidx])
                            {
                                if (!tos_iswritting)
                                {
                                    WriteTOSLog(chidx);
                                    // 231227 주석처리함 BGH 
                                    // 쓸데없이 로깅함
                                    // WriteSystemLog("// Write TOS");
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[TimerEvent100::1532] - " + ex.Message);
            }

            //if (swatch.IsRunning)
            //{
            //    swatch.Stop();
            //    if (swatch.ElapsedMilliseconds > 100)
            //    {
            //        Debug.WriteLine("Timer 100ms Elasped : " + swatch.ElapsedMilliseconds.ToString() + " msec");
            //    }
            //}
        }

        // ------------------------------------
        //
        // ------------------------------------
        //private async void LoadRTGraph(int c_ch)
        //{
        //    int boardid = Board_Ch_Mapping[m_iCur_CH_NO];  // ghbaik
        //    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m_iCur_CH_NO);  // ghbaik2
        //    double vvalue = 0;
        //    double ivalue = 0;
        //    double cvalue = 0;

        //    try
        //    {
        //        if (m_Graph_RT_Cycler.FirstTime)
        //        {
        //            m_Graph_RT_Cycler.FirstTime = false;

        //            System.IO.FileInfo fi = new FileInfo(logCyclerPath[m_iCur_CH_NO]);
        //            if (fi.Exists)
        //            {
        //                string rln = "";

        //                FileStream fstr = new FileStream(logCyclerPath[m_iCur_CH_NO], FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        //                using (StreamReader sr = new StreamReader(fstr, System.Text.Encoding.UTF8))
        //                {
        //                    while ((rln = sr.ReadLine()) != null)
        //                    {
        //                        var packetlist = rln.Split(',');
        //                        if (packetlist.Count() > 7)
        //                        {
        //                            if (double.TryParse(packetlist[3], out vvalue) &&
        //                                double.TryParse(packetlist[4], out ivalue) &&
        //                                double.TryParse(packetlist[5], out cvalue))
        //                            {
        //                                m_Graph_RT_Cycler.Add_Value(vvalue, ivalue, cvalue);
        //                            }
        //                        }
        //                    }
        //                }
        //            }

        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        Debug.WriteLine("File:" + ex.Message);
        //    }
        //}

        // ------------------------------------
        // ghbaik
        // chidx : 0~ (base 0)
        // ------------------------------------
        //private void ReNewChInfo4Pattern(int chidx)
        //{
        //    if ((m_iCur_CH_NO >= 0) && (m_iCur_CH_NO == chidx))
        //    {
        //        Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
        //        m_dispChStatus = SetChannelStatus(chidx);
        //        m_ucChannel_Status.Set_Disp_CH_Status(chidx, m_dispChStatus);
        //        m_ucChannel_Status.Display_Data_ChOnly(chidx);

        //        ReNewChDispInformation(chidx);
        //    }

        //}


        // ------------------------------------
        // ghbaik
        // ------------------------------------

        private void ReNewChDispInformation(int chidx)
        {
            Set_Group_Ch_No(chidx);

            if (chidx >= 0)
            {
                //STEP_TYPE sttype = STEP_TYPE.NONE;
                //int rchno = 0;
                int m_cstepidx = 0;

                int boardid = Board_Ch_Mapping[chidx];  // ghbaik
                int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);  // ghbaik2

                if (!IsOnTesting[chidx])
                {
                    //+ Revision by LBG - 231124 : Timer에서 Delay 발생으로 채널 정보를 별도로 표시하는 기능 추가
                    //if (chidx == m_iCur_CH_NO)
                    //{
                    //    Disp_Chanel_InitInfo(chidx);  // ghbaik
                    //}
                    //-
                    return;
                }

                try
                {
                    // rchno = chidx - m_ucCycler_ABT_List[boardid].ChannelStartIndex;
                    m_cstepidx = m_ucStepInfo_List[chidx].m_currentStepNo;

                    //Debug.WriteLine("1779 ----->>> rchno=" + rchno.ToString() + " ,chidx=" + chidx.ToString() + ", m_Cur_BD_idx=" + boardid.ToString() + ", m_ucCycler_ABT_List[m_Cur_BD_idx].ChannelStartIndex=" + m_ucCycler_ABT_List[m_Cur_BD_idx].ChannelStartIndex);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("Mainframe[RenewChDisp::1783] - " + ex.Message);
                }

                // -------------------------------------------------------
                //public int CH_NO;               // 호출된 CH 번호
                // -------------------------------------------------------
                m_CurChStatusInfo.CH_NO = chidx + 1;

                // -------------------------------------------------------
                //public STEP_TYPE CH_StepType;   // 작업 Type
                // -------------------------------------------------------
                try
                {
                    m_CurChStatusInfo.CH_isChamberWarming = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming;
                    // -------------------------------------------------------
                    // Paused?
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_isPaused = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused;

                    m_CurChStatusInfo.CH_STepMode = STEP_MODE.NONE;
                    switch (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype)
                    //switch (m_ucStepInfo_List[chidx].m_steplist[m_cstepidx].steptype)
                    {
                        case cls_stepInfo.enumStepType.CYCLE_START: m_CurChStatusInfo.CH_StepType = STEP_TYPE.CYCLE_START; break;
                        case cls_stepInfo.enumStepType.CYCLE_END: m_CurChStatusInfo.CH_StepType = STEP_TYPE.CYCLE_END; break;

                        case cls_stepInfo.enumStepType.Charge:
                            //case cls_stepInfo.enumStepType.UDDS_CHARGE:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.CHARGE;
                            switch (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode)
                            {
                                case cls_stepInfo.enumStepMode.CC: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CC; break;
                                case cls_stepInfo.enumStepMode.CV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CV; break;
                                case cls_stepInfo.enumStepMode.CP: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CP; break;
                                case cls_stepInfo.enumStepMode.CR: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CR; break;
                                case cls_stepInfo.enumStepMode.CCCV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CCCV; break;
                                case cls_stepInfo.enumStepMode.CPCV_CP: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CPCV; break;
                                case cls_stepInfo.enumStepMode.CPCV_CV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CPCV; break;
                            }
                            break;

                        case cls_stepInfo.enumStepType.Discharge:
                            //case cls_stepInfo.enumStepType.UDDS_DISCHARGE:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.DISCHARGE;
                            switch (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode)
                            {
                                case cls_stepInfo.enumStepMode.CC: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CC; break;
                                case cls_stepInfo.enumStepMode.CV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CV; break;
                                case cls_stepInfo.enumStepMode.CP: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CP; break;
                                case cls_stepInfo.enumStepMode.CR: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CR; break;
                                case cls_stepInfo.enumStepMode.CCCV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CCCV; break;
                                case cls_stepInfo.enumStepMode.CPCV_CP: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CPCV; break;
                                case cls_stepInfo.enumStepMode.CPCV_CV: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CPCV; break;
                            }
                            break;

                        // ghbaik
                        case cls_stepInfo.enumStepType.Pattern:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.PATTERN;
                            switch (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode)
                            {
                                case cls_stepInfo.enumStepMode.CC: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CC; break;
                                case cls_stepInfo.enumStepMode.CP: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CP; break;
                                case cls_stepInfo.enumStepMode.CR: m_CurChStatusInfo.CH_STepMode = STEP_MODE.CR; break;
                                default: m_CurChStatusInfo.CH_STepMode = STEP_MODE.NONE; break;
                            }
                            break;

                        case cls_stepInfo.enumStepType.Rest:
                            //case cls_stepInfo.enumStepType.UDDS_REST:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.REST; break;

                        case cls_stepInfo.enumStepType.MBT:
                        case cls_stepInfo.enumStepType.MCZ:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.ACIA; break;

                        case cls_stepInfo.enumStepType.STANDBY:
                        case cls_stepInfo.enumStepType.STANDBY_wALARM:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.NONE; break;

                        case cls_stepInfo.enumStepType.OCV:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.OCV; break;  // ghbaik

                        case cls_stepInfo.enumStepType.InsulationTest:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.INSULATE; break;

                        case cls_stepInfo.enumStepType.Pause:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.PAUSE; break;

                        case cls_stepInfo.enumStepType.Ready:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.READY; break;

                        case cls_stepInfo.enumStepType.Wait_Charge:
                        case cls_stepInfo.enumStepType.Wait_Discharge:
                        case cls_stepInfo.enumStepType.Wait_InsulTest:
                        case cls_stepInfo.enumStepType.Wait_MBT:
                        case cls_stepInfo.enumStepType.Wait_MCZ:
                        case cls_stepInfo.enumStepType.Wait_OCV:
                        case cls_stepInfo.enumStepType.Wait_Pattern:
                        case cls_stepInfo.enumStepType.Wait_Rest:
                        case cls_stepInfo.enumStepType.Wait_Pause:
                        case cls_stepInfo.enumStepType.Wait_Ready:
                            m_CurChStatusInfo.CH_StepType = STEP_TYPE.WAIT; break;
                    }
                }
                catch { }

                // -------------------------------------------------------
                //public string CH_Code;          // 동작 Code
                // -------------------------------------------------------
                try
                {
                    m_CurChStatusInfo.CH_Code = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString;

                    //if (m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].StatusCode == 0)
                    //{
                    //    // m_CurChStatusInfo.CH_Code = m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].StatusCode.ToString() + "(정상)";
                    //    m_CurChStatusInfo.CH_Code = m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].StatusCode.ToString() + "(OK)";
                    //}
                    //else
                    //{
                    //    m_CurChStatusInfo.CH_Code = m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].StatusCode.ToString();
                    //}
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("Mainframe[RenewChDisp::1903] - " + ex.Message);
                    // Debug.WriteLine("1888      >>> rchno=" + bzch.ToString() + " ,chidx=" + chidx.ToString() + ", boardidx=" + boardid.ToString());
                }

                // -------------------------------------------------------
                // public DateTime CH_Total_Time;      // 공정 진행 시간
                // -------------------------------------------------------
                // totaltime은 검사시작할때 처음 기록하고 업데이트 하지 않는다. --

                try
                {
                    //Display_Channel_Status dcs = new Display_Channel_Status();
                    //dcs = m_ucChannel_Status.Get_Disp_CH_Status(chidx);

                    // -------------------------------------------------------
                    //public DateTime CH_Step_Time;       // Step 진행 시간
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Spent_Time = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4disp;
                    m_CurChStatusInfo.CH_TotSpent_Time = m_ucStepInfo_List[chidx].OGTime_Total_4disp;



                    // -------------------------------------------
                    // 대기표시 위해 추가, 230902 BGH
                    // -------------------------------------------
                    m_CurChStatusInfo.CH_isWarmup = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isRisedUp;


                    // -------------------------------------------------------
                    //public int CH_Total_Cycle;
                    // -------------------------------------------------------
                    // ghbaik
                    //int m_curidx = m_ucStepInfo_List[chidx].m_depthCycle - 1;
                    //if (m_curidx < 0) m_curidx = 0;

                    m_CurChStatusInfo.CH_Total_Cycle = m_ucStepInfo_List[chidx].m_totCycle;

                    // -------------------------------------------------------
                    //public int CH_Cur_Cycle;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Cur_Cycle = m_ucStepInfo_List[chidx].m_curCycle; // m_cstepidx + 1;

                    // -------------------------------------------------------
                    //public int CH_Total_Step;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Total_Step = m_ucStepInfo_List[chidx].m_steplist.Count();

                    // -------------------------------------------------------
                    //public int CH_Cur_Step;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Cur_Step = m_cstepidx + 1;

                    // -------------------------------------------------------
                    //public int CH_Volt;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Volt = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;

                    // -------------------------------------------------------
                    //public int CH_Curr;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Curr = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;

                    // -------------------------------------------------------
                    //public int CH_Capa;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Capa = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q; // .Current_Q;

                    // -------------------------------------------------------
                    //public int CH_Char_Capa;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Char_Capa = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentCha_Q;

                    // -------------------------------------------------------
                    //public int CH_Disc_Capa;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Disc_Capa = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentDisch_Q;

                    // -------------------------------------------------------
                    //public int CH_Energy;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Energy = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_E; //.Current_E;

                    // -------------------------------------------------------
                    //public int CH_Charge_wh;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Charge_wh = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentCha_E;

                    // -------------------------------------------------------
                    //public int CH_Discharge_wh;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Discharge_wh = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentDischa_E;

                    // -------------------------------------------------------
                    //public int CH_Power;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Power = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_P;


                    // -------------------------------------------------------
                    //public int CH_Temperature;
                    // -------------------------------------------------------
                    m_CurChStatusInfo.CH_Temperature = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;

                    // -------------------------------------------------------
                    //public int CH_Frequency;
                    // -------------------------------------------------------
                    if (typelistacir[chidx] == 1) m_CurChStatusInfo.CH_Frequency = m_ucMbT_List[chidx].MeasureData.freq;
                    else if (typelistacir[chidx] == 2) m_CurChStatusInfo.CH_Frequency = m_ucMcz_List[chidx].MeasureData.freq;
                    else m_CurChStatusInfo.CH_Frequency = -1;

                    // -------------------------------------------------------
                    //public int CH_IM;
                    // -------------------------------------------------------
                    if (typelistacir[chidx] == 1) m_CurChStatusInfo.CH_IM = m_ucMbT_List[chidx].MeasureData.IM * 1000.0;
                    else if (typelistacir[chidx] == 2) m_CurChStatusInfo.CH_IM = m_ucMcz_List[chidx].MeasureData.IM * 1000.0;
                    else m_CurChStatusInfo.CH_IM = 0; // -1;
                    //m_CurChStatusInfo.CH_IM = m_ucMbT_List[chidx].MeasureData.IM; // m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].Acia_Im;

                    // -------------------------------------------------------
                    //public int CH_RE;
                    // -------------------------------------------------------
                    if (typelistacir[chidx] == 1) m_CurChStatusInfo.CH_RE = m_ucMbT_List[chidx].MeasureData.RE * 1000.0;
                    else if (typelistacir[chidx] == 2) m_CurChStatusInfo.CH_RE = m_ucMcz_List[chidx].MeasureData.RE * 1000.0;
                    else m_CurChStatusInfo.CH_RE = 0; // -1;
                    //m_CurChStatusInfo.CH_RE = m_ucMbT_List[chidx].MeasureData.RE; // m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].Acia_Re;

                    // -------------------------------------------------------
                    //public int CH_RS;
                    // -------------------------------------------------------
                    if (typelistacir[chidx] == 1) m_CurChStatusInfo.CH_RS = m_ucMbT_List[chidx].MeasureData.Rs * 1000.0;
                    else if (typelistacir[chidx] == 2) m_CurChStatusInfo.CH_RS = m_ucMcz_List[chidx].MeasureData.Rs * 1000.0;
                    else m_CurChStatusInfo.CH_RS = 0; // -1;
                    //m_CurChStatusInfo.CH_RS = m_ucMbT_List[chidx].MeasureData.Rs; // m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].Acia_Rs;

                    // -------------------------------------------------------
                    //public int CH_RCT;
                    // -------------------------------------------------------
                    if (typelistacir[chidx] == 1) m_CurChStatusInfo.CH_RCT = m_ucMbT_List[chidx].MeasureData.Rct * 1000.0;
                    else if (typelistacir[chidx] == 2) m_CurChStatusInfo.CH_RCT = m_ucMcz_List[chidx].MeasureData.Rct * 1000.0;
                    else m_CurChStatusInfo.CH_RCT = 0; // -1;
                    //m_CurChStatusInfo.CH_RCT = m_ucMbT_List[chidx].MeasureData.Rct; // m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rchno].Acia_Rct;

                    // --------------------------------------------
                    // 231029 BGH
                    // --------------------------------------------
                    if (m_ITDevEnable)
                    {
                        if (m_ucIT_List.Count > chidx)
                        {
                            if (m_ucIT_List[chidx].m_Result1stPhase != null)
                            {
                                if (m_ucIT_List[chidx].m_Result1stPhase.Length > 0) m_CurChStatusInfo.CH_INSUL_1 = m_ucIT_List[chidx].m_Result1stPhase;
                                else m_CurChStatusInfo.CH_INSUL_1 = "0";
                            }
                            else
                            {
                                m_CurChStatusInfo.CH_INSUL_1 = "0";
                            }

                            if (m_ucIT_List[chidx].m_Result2ndPhase != null)
                            {
                                if (m_ucIT_List[chidx].m_Result2ndPhase.Length > 0) m_CurChStatusInfo.CH_INSUL_2 = m_ucIT_List[chidx].m_Result2ndPhase;
                                else m_CurChStatusInfo.CH_INSUL_2 = "0";
                            }
                            else
                            {
                                m_CurChStatusInfo.CH_INSUL_2 = "0";
                            }
                        }
                        else
                        {
                            m_CurChStatusInfo.CH_INSUL_1 = "";
                            m_CurChStatusInfo.CH_INSUL_2 = "";
                        }
                    }
                    else
                    {
                        m_CurChStatusInfo.CH_INSUL_1 = "";
                        m_CurChStatusInfo.CH_INSUL_2 = "";
                    }

                    m_CurChStatusInfo.Work_Name = work_names[chidx];
                    // m_CurChStatusInfo.Schedule_Name = sche_names[chidx];
                    m_CurChStatusInfo.Schedule_Name = Path.GetFileNameWithoutExtension(sche_names[chidx]);
                    //m_CurChStatusInfo.Schedule_Path = Recipe_Files[chidx];

                    // -------------------------------------------------------
                    //public string Schedule_Name;
                    // -------------------------------------------------------
                    // 시험 시작시에 초기화하고, 건들지 않는다.
                    //+ Revision by LBG - 231124 : Timer에서 Delay 발생으로 해당 부분을 별도 Thread Timer로 처리
                    //if (chidx == m_iCur_CH_NO)
                    //{
                    //    Disp_Chanel_Info(m_CurChStatusInfo);
                    //}
                    //-
                    //else
                    //{
                    //    //Disp_Chanel_InitInfo(chidx);
                    //}
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("Mainframe[RenewChDisp::2058] - " + ex.Message);
                    //Debug.WriteLine("2037      >>> rchno=" + rchno.ToString() + " ,chidx=" + chidx.ToString() + ", m_Cur_BD_idx=" + m_Cur_BD_idx.ToString() + ", m_ucCycler_ABT_List[m_Cur_BD_idx].ChannelStartIndex ?");
                }
            }
        }


        // ------------------------------------
        // ghbaik
        // ------------------------------------       
        private void ReNewBoardInformation()
        {
            // ------------------------------------------------
            // 1. Check cycler connection 
            // ------------------------------------------------
            int bdcount = m_ucBoard_Status.GetBoardCount();
            cls_devCyclerABT instABT;

            // ------------------------------------------------
            // Build/Modify Board & Channel List
            // ------------------------------------------------
            m_Tot_Ch_Count = 0;
            if (m_ucCycler_ABT_List != null)
            {
                m_ucCycler_ABT_List.Clear();
            }            
            m_ucCycler_ABT_List = new List<cls_devCyclerABT>();
            //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
            //cls_IniUtil inifile = new cls_IniUtil(Application.StartupPath + "\\ABTProV2.ini");
            //string str_ccut = inifile.GetIniValue("SYSTEM_SETTING", "CURRENT_THRESHOLD", "0.03");
            //double curcut = 0.03;
            //double.TryParse(str_ccut, out curcut);
            double curcut = m_clsAppSet.Option_Set.Current_ThresHold;
            //-
            for (int i = 0; i < bdcount; i++)
            {
                // instABT = new cls_devCyclerABT(this, i);
                instABT = new cls_devCyclerABT(this, i, cyclog_intv);

                instABT.datalog_path = Application.StartupPath + "\\device";

                try
                {
                    instABT.CurrentThreshold = curcut;  // GBH, 2023-08-06
                    instABT.ChannelStartIndex = m_Tot_Ch_Count;
                    instABT.ChannelCount = m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;
                    m_Tot_Ch_Count += m_clsSys_Set.m_Sys_BD[i].BD_CH_Cnt;

                    instABT.NewCyclerUsed = m_newtype_cycler;

                    instABT.OnConnected += Connected_cyclerABT;
                    instABT.OnDisconnected += Disconnected_cyclerABT;
                    instABT.OnStepEnd += StepEnd_cyclerABT;
                    instABT.On1stSafetyProcEnd += SafetyProcEnd_cyclerABT;
                    // instABT.On2ndSafetyProcEnd += Safety1stCC0A_cyclerABT;

                    instABT.OnUDDSCurrentRisedUp += UDDS_NextPatternPatch;

                    //ghbaik
                    instABT.OnAlarm += CheckSafetyCondition; // Cycler_AlarmABT;
                    instABT.OnAlarmDesc += DevAlarmDescription;  // Device alarm description

                    instABT.OnWriteRegLog += WriteRegLog;
                    //instABT.hMiliSecondFactor = hmilfactor;
                    //instABT.OnChamberReady += ChamberWait_cyclerABT;  // Chamber 온도 상승대기
                    instABT.CurrentCalibrationEnable = m_currautocal;  // 전류 자동 보정기능, 20230719 BGH
                    instABT.Enable0ACurrentLogging = m_enable_real_rest_current_logging;  // 230920 BGH _
                    instABT.RestOptionStandby = m_RestOptionStandby;  // REST mode에서 Standby 처리. (false이면 CC0A)

                    // 231127 BGH
                    instABT.VoltDigit = Volt_Number_Digit;
                    //+ Revision by KGY -20241209 : 설정 옵션 로드 변경 (ini -> AppSetting)
                    //+ Add by YMJ - 240130 : Cycler Debug 옵션 설정 기능 추가
                    //string n_useDebugStr = inifile.GetIniValue("DEBUG_SETTING", "CYCLER_ENABLE", "FALSE");
                    //bool n_useDebugBool = false;
                    //bool.TryParse(n_useDebugStr, out n_useDebugBool);
                    bool n_useDebugBool = m_clsAppSet.Option_Set.CYCLER_Debug_Enable;
                    instABT.m_useDebugOption = n_useDebugBool;
                    //-
                    //-

                    m_ucCycler_ABT_List.Add(instABT);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("Mainframe[RenewBoard::1893] - " + ex.Message);
                }

            }

            if (m_Tot_Ch_Count > 0)
            {
                Board_Ch_Mapping = new int[m_Tot_Ch_Count];

                // --------------------------
                // ghbaik
                // --------------------------
                typelistacir = new byte[m_Tot_Ch_Count];
                for (int i = 0; i < m_Tot_Ch_Count; i++)
                {
                    typelistacir[i] = 0; // not used - default
                }

                // --------------------
                // work_names
                // --------------------
                Array.Resize(ref work_names, m_Tot_Ch_Count);

                // --------------------
                // schedule_names
                // --------------------
                Array.Resize(ref sche_names, m_Tot_Ch_Count);
                //
                Array.Resize(ref sche_names_restart, m_Tot_Ch_Count);

                //+ Add by LBG : Recipe 파일 경로 저장 배열 초기화
                Array.Resize(ref Recipe_Files, m_Tot_Ch_Count);
                //-

                //+ Add by LBG - 230308 : 작업 로그명 설정 기능 추가
                //Array.Resize(ref m_Log_Opt_Chk_Work, m_Tot_Ch_Count);
                //Array.Resize(ref m_Log_Opt_Chk_File, m_Tot_Ch_Count);
                //Array.Resize(ref m_Log_Opt_Chk_Time, m_Tot_Ch_Count);
                Array.Resize(ref m_Log_Opt_File, m_Tot_Ch_Count);
                //-
            }
        }

        #region ReNewBoardInformation(int boardid)
        
        // ------------------------------------
        // ghbaik
        // ------------------------------------
        #endregion


        // -----------------------------
        // Pattern 첫번째 로그
        // -----------------------------
        public void Write1stPatternLog(int m_ch)
        {
            //AddTickStepAndTotalTime(m_ch, 0); 
            //logopt[m_ch] = 1;
            //WriteBasicLog(m_ch, "", eNUM_CutOFF_Type.NONE, false);
        }

        // ----------------------------------------------------------
        // 전류가 일정 양 이상 인가되었을때 스텝 시작함
        // ----------------------------------------------------------
        public void WriteRegLog(int m_ch, bool Makeup, bool cccv_cutoff, bool isPternStrt)
        {
            // --------------------------------
            // 정지 후 이어하기, 로그처리 위해
            // 231009, BGH
            // --------------------------------
            try
            {
                cls_stepInfo CurStInfo = m_ucStepInfo_List[m_ch];
                CurStInfo.isTempPaused = false;
                m_ucStepInfo_List[m_ch] = CurStInfo;
            }
            catch { }

            if (isPternStrt)
            {
                

                AddTickStepAndTotalTime(m_ch, 0);
                logopt[m_ch] = 1;
                m_ucStepInfo_List[m_ch].isRised = true;
                WriteBasicLog(m_ch, "", eNUM_CutOFF_Type.NONE, false);


                // ----------------------------------------------
                // 패턴 첫번째 아이템 로그 기록 후 본격 Timer 가동
                // ----------------------------------------------
                if (m_ucUDDS_List != null)
                {
                    if (m_ucUDDS_List.Count > m_ch)
                    {
                        m_ucUDDS_List[m_ch].EnableTimer = true;
                        
                    }
                }
            }
            else
            {
                // WriteBasicLog(mch, "Curr:" + rcvf.ToString("F3"));
                // 한번 부르면 100이나 1000등 interval부터 시작한다. base를 0부터 시작해야 한다.
                // 즉, 최초 한번은 거를것.
                if (Makeup)
                {
                    // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + "[Ch=" + (m_ch + 1).ToString() + "] Start Log");
                    AddTickStepAndTotalTime(m_ch, 0);  // 모드 시작하고 최초 , 예를들어, 전압 인가하고 최초의 로그
                    logopt[m_ch] = 1;
                }
                else
                {
                    // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + "[Ch=" + (m_ch + 1).ToString() + "] Event Log");
                    AddTickStepAndTotalTime(m_ch, 1);  // Pause 후에 이어서 실행하는 경우
                }

                m_ucStepInfo_List[m_ch].isRised = true;
                // 230103, BGH
                WriteBasicLog(m_ch, "", eNUM_CutOFF_Type.NONE, false);

                // ----------------------------------------------
                // 첫번째 로그 쓰자마자, 종료하는 옵션 처리 
                // ----------------------------------------------
                if ((!CCCV_V_DoAlarm) && cccv_cutoff)
                {
                    EndCurrentStep(m_ch, eNUM_CutOFF_Type.VOLTAGE);
                }
            }
        }

        // ------------------------------------------
        //
        // ------------------------------------------
        private void Connected_cyclerABT(int boardid)
        {
            try
            {
                Display_Board_Status bdstatus = m_ucBoard_Status.GetBoardStatus(boardid);
                bdstatus.bd_s_No = boardid + 1;
                bdstatus.bd_s_Conected = true;
                bdstatus.bd_s_CH_Cnt = m_clsSys_Set.m_Sys_BD[boardid].BD_CH_Cnt;
                bdstatus.bd_s_IP_Addr = m_ucCycler_ABT_List[boardid].strTCPIP;

                WriteSystemLog("// Event : Cycler Connected // Module #" + (boardid + 1));

                m_ucBoard_Status.Set_Disp_BD_Status(boardid, bdstatus);

                ///+ Revision by YMJ - 240130 : OpenLog() 위치 변경
                //m_ucCycler_ABT_List[boardid].OpenLog();
                //-

                // ReNewBoardInformation();
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[Connected_cyclerABT::2007] - " + ex.Message);
            }
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void Disconnected_cyclerABT(int boardid)
        {
            try
            {
                if (m_ucCycler_ABT_List != null)
                {
                    if (m_ucCycler_ABT_List.Count() > boardid)
                    {
                        Display_Board_Status bdstatus = m_ucBoard_Status.GetBoardStatus(boardid);
                        bdstatus.bd_s_No = boardid + 1;
                        bdstatus.bd_s_Conected = false;
                        bdstatus.bd_s_CH_Cnt = 0;
                        bdstatus.bd_s_IP_Addr = m_ucCycler_ABT_List[boardid].strTCPIP;

                        WriteSystemLog("// Event : Cycler Disonnected // Module #" + (boardid + 1));

                        m_ucBoard_Status.Set_Disp_BD_Status(boardid, bdstatus);
                        m_ucCycler_ABT_List[boardid].CloseLog();

                        //+ Add by YMJ - 240130 : 통신 기록 로그 닫기 추가
                        if (m_ucCycler_ABT_List[boardid].m_useDebugOption)
                        {
                            m_ucCycler_ABT_List[boardid].CloseCommunicationLog();
                        }
                        //-
                    }
                }
                //m_ucCycler_ABT_List[boardidx].dummycount = 0;
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[DisConnected_cyclerABT::2031] - " + ex.Message);
            }
        }


        // ------------------------------------------
        // MBI Disconnected 
        // ----------------------------------------- 
        private void Disconnected_MBI()
        {
            if (m_voltcount_mbi.Length == 1)
            {
                if (IsOnTesting[0])
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(0, TypeOfSafetyViolation.CAN_COMMErr, "[MBI001]MBI Comm. Error.");
                    //-

                    SafetyCurrentStep(0, "MBIErr");

                    Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(0);
                    m_dispChStatus.ch_s_Code = "MBIErr";
                    m_dispChStatus.ch_s_Exist_Alarm = true;
                    m_ucChannel_Status.Set_Disp_CH_Status(0, m_dispChStatus);
                }
            }
            else if (m_voltcount_mbi.Length == 2)
            {
                if (IsOnTesting[0])
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(0, TypeOfSafetyViolation.CAN_COMMErr, "[MBI001]MBI Comm. Error.");
                    //-

                    SafetyCurrentStep(0, "MBIErr");

                    Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(0);
                    m_dispChStatus.ch_s_Code = "MBIErr";
                    m_dispChStatus.ch_s_Exist_Alarm = true;
                    m_ucChannel_Status.Set_Disp_CH_Status(0, m_dispChStatus);
                }
                if (IsOnTesting[1])
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(1, TypeOfSafetyViolation.CAN_COMMErr, "[MBI001]MBI Comm. Error.");
                    //-

                    SafetyCurrentStep(1, "MBIErr");

                    Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(1);
                    m_dispChStatus.ch_s_Code = "MBIErr";
                    m_dispChStatus.ch_s_Exist_Alarm = true;
                    m_ucChannel_Status.Set_Disp_CH_Status(1, m_dispChStatus);
                }
            }
        }

        // ------------------------------------------
        // CAN Disconnected 
        // ----------------------------------------- 
        private void Disconnected_CAN(int ch)
        {
            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
            AddAlarm(ch, TypeOfSafetyViolation.CAN_COMMErr, "[CAN001]CAN Comm. Error.");
            //-

            SafetyCurrentStep(ch, "CANErr");

            Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_Code = "CANErr";
            m_dispChStatus.ch_s_Exist_Alarm = true;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
        }

        //+ Add by YMJ - 250716 : CAN 통신 실패 응답 알람 처리 추가
        private void FailCommunication_CAN(int ch)
        {
            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가  
            AddAlarm(ch, TypeOfSafetyViolation.CAN_COMMErr, "[CAN011]CAN Data Send Fail");
            //-

            SafetyCurrentStep(ch, "CANFailErr");

            Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_Code = "CANFailErr";
            m_dispChStatus.ch_s_Exist_Alarm = true;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
        }
        //-

        // ------------------------------------------
        // AUX Disconnected 
        // ----------------------------------------- 
        private void Disconnected_AUX(int ch)
        {
            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
            AddAlarm(ch, TypeOfSafetyViolation.AUX_COMMErr, "[AUX001]AUX Comm. Error.");
            //-

            SafetyCurrentStep(ch, "AUXErr");

            Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_Code = "AUXErr";
            m_dispChStatus.ch_s_Exist_Alarm = true;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
        }

        //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
        //+ Add by YMJ - 241105 : CREVIS AUX 값 읽어오기
        private void OnReadCREVIS(int index, float[] rvalue)
        {
            int useTempCnt = 0;
            for(int i=0;i<m_NumOfCREVIS;i++)
            {
                if(i < index)
                {
                    useTempCnt += m_tempcount_crevis[i];
                }
            }

            int ch = useTempCnt / m_CREVIS_DEVISION;
            int idx = useTempCnt % m_CREVIS_DEVISION;

            int start = 0;
            int end = m_tempcount_crevis[index];

            try
            {
                if (rvalue != null && rvalue.Length >= end)
                {
                    for (int i = start; i < end; i++)
                    {
                        if (idx == 0)
                        {
                            m_CREVIS_T_Max[ch] = rvalue[i];
                            m_CREVIS_T_Min[ch] = rvalue[i];
                        }
                        else
                        {
                            if (m_CREVIS_T_Max[ch] < rvalue[i])
                            {
                                m_CREVIS_T_Max[ch] = rvalue[i];
                            }
                            if (m_CREVIS_T_Min[ch] > rvalue[i])
                            {
                                m_CREVIS_T_Min[ch] = rvalue[i];
                            }
                        }
                        m_CREVIS_Temp[ch, idx] = rvalue[i];

                        idx++;
                        if (idx == m_CREVIS_DEVISION)
                        {
                            idx = 0;
                            m_CREVIS_T_Diff[ch] = m_CREVIS_T_Max[ch] - m_CREVIS_T_Min[ch];
                            ch++;
                        }
                    }
                }
            }
            catch { }
        }
        //-
        //-

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        //private void Cycler_AlarmABT(int chidx)
        //{
        //    // ------------------------------------
        //    // ghbaik
        //    // ------------------------------------
        //    Display_Channel_Status dcl = m_ucChannel_Status.Get_Disp_CH_Status(chidx);
        //    dcl.ch_s_Exist_Alarm = true;
        //    //dcl.ch_s_Backup_Alarm = true;
        //    m_ucChannel_Status.Set_Disp_CH_Status(chidx, dcl);
        //}

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void ChamberWait_cyclerABT()
        {
            int boardid = 0;
            int bzch = 0;
            int ch = 0;

            SetChamberMaintainUsage = false;
            for (int i = 0; i < ChlistMaintain.Count; i++)
            {
                ch = ChlistMaintain[i];
                boardid = Board_Ch_Mapping[ch];
                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch); 

                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_Enable = false;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_MaintainUse = false;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = false;

                WriteSystemLog(ch, ">> Chamber Waiting End [start step]", false);

                // 240102, BGH
                // if (StartCurrentStep(ch, false))
                if (StartCurrentStep(ch, false, false))
                {
                    m_timelimit[ch] = -1;
                    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
                }
            }

            ResetChamberMaintainSetting();
        }

        // ----------------------------------------
        // 
        // ----------------------------------------
        private void UDDS_NextPatternPatch(int chidx)
        {
            if (chidx < m_ucUDDS_List.Count())
            {
                doPatternLog[chidx] = 1;
            }
        }


        // ---------------------------------------------------
        // 스케쥴 시작시 STep Skip
        // ---------------------------------------------------
        public bool SkipStartSteps(int ch)
        {
            int CurrentNo; 
            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            WriteSystemLog(ch, ">> Skip Step", false);
            
            try
            {
                if (m_ucStepInfo_List == null) { return false; }
                if (m_ucStepInfo_List.Count <= ch) { return false; }
            }
            catch { }

            CurStInfo = m_ucStepInfo_List[ch];
            try
            {
                if (CurStInfo == null) { return false; }
                if (CurStInfo.m_currentStepNo < 0) { return false; }
            }
            catch { }           

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            m_AuxEndStepNumber[ch] = 0;

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { return false; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { return false; }


            WriteSystemLog(ch, ">> Skip Step No = " + CurStInfo.m_currentStepNo.ToString() + " // Step = " + CurStInfo.m_steplist[CurrentNo].steptype.ToString(), false);
            logopt[ch] = 0;

            // ------
            // display status
            // -----
            #region
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            // ----------------------------------------------------
            // 231101, BGH
            // ----------------------------------------------------
            m_dispChStatus.ch_s_Step_No = CurrentNo + 1;
            m_dispChStatus.ch_s_CutOffType = eNUM_CutOFF_Type.NONE; // ghbaik
            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.NONE; // ghbaik

            m_dispChStatus.SafetyWarmingUp = false;  // Safety 설정이 끝났음. 즉, 정식 Step 실행

            m_dispChStatus.isTesting = true;
            m_dispChStatus.ch_s_isPaused = false;
            m_dispChStatus.ch_s_Step_Time = DateTime.Now;
            m_dispChStatus.ch_s_Spent_Time = new TimeSpan(0, 0, 0, 0, 0);
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            #endregion

            m_timelimit[ch] = -1;

            switch (CurStInfo.m_steplist[CurrentNo].steptype)
            {
                case cls_stepInfo.enumStepType.CYCLE_START:
                    #region
                    // -------- gw123---------------------
                    // Cycle Start는 아무일 안하고 다음 Step으로 이동한다.
                    // -----------------------------------
                    CurStInfo.START_CYCLE();
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.CYCLE_END:
                    #region
                    // ---------------------------------------------
                    // 현재 카운트 정리
                    // ---------------------------------------------                    
                    int m_count = CurStInfo.m_steplist[CurrentNo].operaCondition.mValue - 1;
                    int stepidx = -1;  // p3p

                    CurStInfo.m_totCycle++;
                    cls_stepInfo.struStep m2_step = CurStInfo.m_steplist[CurrentNo];
                    m2_step.operaCondition.mValue = m_count;

                    if (m_count > 0)
                    {
                        // CYCLE START로 이동. 
                        CurStInfo.m_islooping = false;
                        for (int i = 0; i < CST_CyclingSize; i++)
                        {
                            if (cycling[ch, i, 1] == CurrentNo)
                            {
                                stepidx = cycling[ch, i, 0];
                                CurStInfo.m_islooping = true;
                                break;
                            }
                        }

                        if (stepidx != -1)
                        {
                            CurStInfo.m_currentStepNo = stepidx;
                            m_currentStep[ch] = stepidx;
                        }

                    }
                    else
                    {
                        CurStInfo.m_islooping = false;
                        for (int i = 0; i < CST_CyclingSize; i++)
                        {
                            if (cycling[ch, i, 1] == CurrentNo)
                            {
                                m2_step.operaCondition.mValue = cycling[ch, i, 2];
                                break;
                            }
                        }
                    }
                    CurStInfo.m_steplist[CurrentNo] = m2_step;

                    CurStInfo.END_CYCLE();
                    m_ucStepInfo_List[ch] = CurStInfo;

                    #endregion
                    break;

                //case cls_stepInfo.enumStepType.MBT:
                //    break;

                //case cls_stepInfo.enumStepType.MCZ:
                //    break;

                //case cls_stepInfo.enumStepType.Pattern:
                //    break;

                //case cls_stepInfo.enumStepType.Charge:
                //case cls_stepInfo.enumStepType.Discharge:
                //case cls_stepInfo.enumStepType.Rest:
                //case cls_stepInfo.enumStepType.OCV:  // ghbaik
                //    break;

                //// ghbaik
                //case cls_stepInfo.enumStepType.WORK_END:
                //    break;

                //case cls_stepInfo.enumStepType.InsulationTest:
                //    break;

                //case cls_stepInfo.enumStepType.Pause:
                //    break;

                //case cls_stepInfo.enumStepType.Ready:
                //    break;

                default:
                    break;
            }

            CurStInfo.m_currentStepNo++;
            CurStInfo.m_curCycle = CurStInfo.m_cyccount[CurStInfo.m_cycidx];
            CurStInfo.isRised = false;

            m_ucStepInfo_List[ch] = CurStInfo;
            
            logCond[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time / 100;  // 10ms 단위
            if (logCond[ch] < 1) logCond[ch] = 1;
            logBuff[ch] = logCond[ch];

            return true;

        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void SafetyProcEnd_cyclerABT(int ch)
        {

            //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + " Safety Setting End [Ch = " + (ch+1).ToString());

            // ------------------------------------------------------------
            // isSafetyTrying 상태를 False로 변경
            // ------------------------------------------------------------
            m_ucStepInfo_List[ch].isSafetyTrying = false;
            m_ucStepInfo_List[ch].isFirstCC0A = false;

            // ------------------------------------------------------------
            // Test 시작
            // 시작 스텝 지정 기능 추가, 230924
            // BGH
            // ------------------------------------------------------------
            if (m_Work_Step_Set[ch].Start_Step_Use && m_Work_Step_Set[ch].Start_Step_Idx > 0)
            {
                // ------------------------------------------------------------
                // Skip Steps
                // ------------------------------------------------------------
                WriteSystemLog(ch, ">> Start Schedule from Step No " + m_Work_Step_Set[ch].Start_Step_Idx.ToString(), false);

                for (int istep = 0; istep < m_Work_Step_Set[ch].Start_Step_Idx; istep++)
                {
                    // ---------------------------------------------
                    // Skip Process 중 에러 생기면 break
                    // ---------------------------------------------
                    if (!SkipStartSteps(ch))
                    {
                        break;
                    }
                }

                // ------------------------------------------------------------
                // Test 시작
                // ------------------------------------------------------------
                m_ChamberReact[ch] = false;
                // 240102, BGH
                // if (StartCurrentStep(ch, false))
                if (StartCurrentStep(ch, false, false))
                {
                    m_timelimit[ch] = -1;
                    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
                }
            }
            else
            {
                // ------------------------------------------------------------
                // Test 시작
                // ------------------------------------------------------------
                m_ChamberReact[ch] = false;
                // 240102, BGH
                // if (StartCurrentStep(ch, false))
                if (StartCurrentStep(ch, false, false))
                {
                    m_timelimit[ch] = -1;
                    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
                }
            }
        }


        // ------------------------------------
        // ghbaik
        // ------------------------------------
        // 231116 BGH
        // private void StepEnd_cyclerABT(int chidx, ABT.eNUM_CutOFF_Type cotype, double Cumm_Qh, double Cumm_Wh, bool isCPCV_CP_Step)
        private void StepEnd_cyclerABT(int chidx, ABT.eNUM_CutOFF_Type cotype, bool isCPCV_CP_Step)
        {
            if (isCPCV_CP_Step)
            {
                EndCurrentCPCV_CP_Step(chidx);
            }
            else
            {
                // -----------------------------------------------------
                // EndCurrentStep 으로 이동함
                // Cycler에 의한 Cut-Off가 아닐경우에도 용량 처리 하기 위함
                // 231116 BGH
                // -----------------------------------------------------
                //try
                //{
                //    cls_stepInfo CurStInfo = new cls_stepInfo(this);
                //    CurStInfo = m_ucStepInfo_List[chidx];
                //    cls_stepInfo.struStep ssstep = m_ucStepInfo_List[chidx].m_steplist[CurStInfo.m_currentStepNo];

                //    ssstep.cmmu_Qh = Cumm_Qh;
                //    ssstep.cmmu_Wh = Cumm_Wh;

                //    m_ucStepInfo_List[chidx].m_steplist[CurStInfo.m_currentStepNo] = ssstep;
                //}
                //catch (Exception ex)
                //{
                //    Debug.WriteLine("Mainframe.cs[StepEnd_cyclerABT::2051] - " + ex.Message);
                //}

                EndCurrentStep(chidx, cotype);
            }
        }


        // ------------------------------------
        // ghbaik
        // ------------------------------------
        //private void Connected_MBT(int chidx, bool isCheckingConn)
        private void Connected_MBT(int chidx)
        {
            // -------------------------------------------------
            // 240102, BGH
            // 연결시험중일때는 무시한다.
            // -------------------------------------------------
            //m_ucMbT_List[chidx].ConnectionChecking = false;
            //if (isCheckingConn) return;
            if (m_ucStepInfo_List[chidx].m_steplist == null)
            {
                return;
            }
            if (m_ucStepInfo_List[chidx].m_steplist.Count < 1)
            {
                return;
            }

            int cno = m_ucStepInfo_List[chidx].m_currentStepNo;

            double m1_sfreq = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mbtFreqStart;
            double m1_efreq = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mbtFreqEnd;
            int m1_density = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mbtDensity;
            cls_stepInfo.CurrentRange m1_Irange = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mbtIRange;
            int m1_scycle = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mbtSkipCycle;
            //int m1_delay = 12; // m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mzxDelayTime;

            WriteSystemLog("// Event : MBT Connected // Channel #" + (chidx + 1));

            //+ Add by LBG - 240306 : MBT 결과 파일 생성 시 파일명에 Step 번호를 입력하기 위하여 추가
            m_ucMbT_List[chidx].Set_Step_No = cno;
            //-

            // Start
            m_ucMbT_List[chidx].StartACIR(m1_sfreq, m1_efreq, m1_density, m1_Irange, m1_scycle, m1_density, m_isMBTKONA);

            // --------------------------------------------------
            // 스텝 시간 표시를 위해
            // 231024, BGH
            // --------------------------------------------------
            m_ucStepInfo_List[chidx].isRised = true;
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void IsNotConnected_MBT(int chidx, int retrycount)
        {
            WriteSystemLog("// Event : MBT Connection = Failed // Channel #" + (chidx + 1));

            if (retrycount < 4)
            {
                WriteSystemLog("// Event : Re-Connect MBT [" + retrycount.ToString() + "] // Channel #" + (chidx + 1));
                DoConnect_MBT(chidx);
            }
            else
            {
                // 240102, BGH
                // EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                AddAlarm(chidx, ABT.TypeOfSafetyViolation.MBT_COMMErr, "[MBT001]MBT Connection Error");
                //-
                SuspendCurrentStep(chidx, "MBT Connection Error");
                // -
            }
        }

        // ------------------------------------
        // BGH, 20230827
        // 한번에 연결 안되는 경우 있어서, retry를 위해 
        // MBT Connect 부분을 분리함.
        // ------------------------------------
        private void DoConnect_MBT(int chidx)
        {
            Thread.Sleep(1);
            if (m_ucMbT_List[chidx].isConnected)
            {
                m_ucMbT_List[chidx].STOPAcia();
                m_ucMbT_List[chidx].DisCoNnect();
            }
            m_ucMbT_List[chidx].CONnect();

            // 240102,BGH
            // m_timelimit[chidx] = 240;  // 4 min, 240 sec
            m_timelimit[chidx] = -1;

        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void StepEnd_MBT(int chidx)
        {
            int curno = 0;
            try
            {
                curno = m_ucStepInfo_List[chidx].m_currentStepNo;

                if (m_ucMbT_List[chidx].isConnected)
                {
                    m_ucMbT_List[chidx].STOPAcia();
                }
            }
            catch { }

            if (m_ucStepInfo_List[chidx].m_steplist[curno].acia_status != cls_stepInfo.StepACIA.MBT_ON_W_CYCLER)
            {
                EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
            }
        }

        //+ Add by YMJ - 240531 : MBT 측정 종료 시 MBT 측정 온도 초기화
        public void Reset_T_MBT(int chidx)
        {
            int boardid = Board_Ch_Mapping[chidx];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = 999.99;
        }
        //-

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void Connected_MCZ(int chidx)
        {
            int cno = m_ucStepInfo_List[chidx].m_currentStepNo;

            //+ Revisioin by YMJ - 250213 : MxZ 연결 방식 변경
            double m1_sfreq = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczFreqStart;
            double m1_efreq = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczFreqEnd;
            int m1_density = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczDensity;
            //+ Add by YMJ - 250520 : MCZ CURRENT 범위 수정
            cls_stepInfo.MczCurrentRange m1_Irange = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczIRange;
            //-
            int m1_delay = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczDelayTime;
            int m1_scycle = m_ucStepInfo_List[chidx].m_steplist[cno].operaCondition.mczSkipCycle;
            WriteSystemLog("// Event : MCZ Connected // Channel #" + (chidx + 1));

            m_ucMcz_List[chidx].Set_Step_No = cno;

            // Start
            m_ucMcz_List[chidx].StartACIR(m1_sfreq, m1_efreq, m1_density, m1_Irange, m1_scycle, m1_delay);

            // --------------------------------------------------
            // 스텝 시간 표시를 위해
            // 231024, BGH
            // --------------------------------------------------
            m_ucStepInfo_List[chidx].isRised = true;
            //-
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void IsNotConnected_MCZ(int chidx, int retrycount)
        {
            //+ Revisioin by YMJ - 250213 : MxZ 재연결 방식 수정
            WriteSystemLog("// Event : MxZ Connection = Failed // Channel #" + (chidx + 1));

            if (retrycount < 4)
            {
                WriteSystemLog("// Event : Re-Connect MxZ [" + retrycount.ToString() + "] // Channel #" + (chidx + 1));
                DoConnect_MCZ(chidx);
            }
            else
            {
                EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
            }
            //-
        }

        //+ Add by YMJ - 250213 : MxZ 연결 함수 추가
        private void DoConnect_MCZ(int chidx)
        {
            Thread.Sleep(1);
            if (m_ucMcz_List[chidx].isConnected)
            {
                m_ucMcz_List[chidx].StopACIR();
                m_ucMcz_List[chidx].DisConnect();
            }
            m_ucMcz_List[chidx].Connect();
            m_timelimit[chidx] = -1;
        }
        //-

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void StepEnd_MCZ(int chidx)
        {
            //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " :: STepEnd_MCZ");

            int curno = 0;
            try
            {
                curno = m_ucStepInfo_List[chidx].m_currentStepNo;

                //+ Revisioin by YMJ - 250213 : MxZ 정지 방식 변경
                if (m_ucMcz_List[chidx].isConnected)
                {
                    m_ucMcz_List[chidx].StopACIR();
                }
                //-
            }
            catch { }

            if (m_ucStepInfo_List[chidx].m_steplist[curno].acia_status != cls_stepInfo.StepACIA.MXZ_ON_W_CYCLER)
            {
                //Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " :: End Step");
                EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
            }
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void StepEnd_UDDS(int chidx)
        {
            int curno = 0;
            try
            {
                curno = m_ucStepInfo_List[chidx].m_currentStepNo;
            }
            catch { }

            EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
        }


        // --------------------------------------------------
        // 231027, BGH
        // --------------------------------------------------
        private void Connected_IT(int chidx)
        {
            if (m_ucIT_List == null)
            {
                EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
                return;
            }
            if (m_ucIT_List.Count <= chidx)
            {
                EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
                return;
            }
            m_ucIT_List[chidx].InsTestStart();

            // --------------------------------------------------
            // 스텝 시간 표시를 위해
            // 231024, BGH
            // --------------------------------------------------
            m_ucStepInfo_List[chidx].isRised = true;
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void IsNotConnected_IT(int chidx)
        {
            EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
        }

        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void StepEnd_IT(int chidx)
        {
            try
            {
                //+ Revision by YMJ - 240613 : 절연저항기 class 수정
                //if (m_ucIT_List[chidx].m_IsMeasuring)
                if (m_ucIT_List[chidx].IsMeasuring)
                {
                    m_ucIT_List[chidx].InsTestStop(); 
                }

                //if (m_ucIT_List[chidx].m_IsConnected)
                if (m_ucIT_List[chidx].IsConnected)
                {
                    m_ucIT_List[chidx].InsDisConnected();
                }
                //-
            }
            catch { }

            EndCurrentStep(chidx, eNUM_CutOFF_Type.NONE);
        }


        //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
        // ------------------------------------
        // Return :
        //   Slave - true
        //   Master, 또는 병렬아닐때 - false
        // ------------------------------------
        private bool CheckParallelSlave(int ch)
        {
            bool ret = false;
            if (m_paramode == null) return false;
            if (m_paramode.Length > ch)
            {
                if (m_paramode[ch].use && (!m_paramode[ch].ismaster))
                {
                    ret = true;
                }
            }
            return ret;
        }
        //-


        // ------------------------------------
        // ghbaik
        // ------------------------------------
        private void SelectedStepInfoFile(int chidx, string xmlpath, string m_workpath) //, string logFname)
        {
            if (m_ucStepInfo_List == null) return;
            if (chidx < 0 || chidx > m_ucStepInfo_List.Count) return;

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(chidx))
            {
                WriteSystemLog(chidx, ">> Start test Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            int bstart = m_ucStepInfo_List[chidx].BuildStepCondition(xmlpath);

            // --------------------------------------
            // Start STep 
            // --------------------------------------
            if (bstart == OK)
            {
                // start

                m_CurChStatusInfo.Work_Name = m_workpath;
                m_CurChStatusInfo.Schedule_Name = xmlpath;
                
                // ----------------------------------------------------
                // 240102, BGH
                // ---------------------------------------------------=
                //if (m_ucMbT_List != null && m_ucMbT_List.Count >= chidx)
                //{
                //    // ---------------------------------------------------------
                //    // 연결 점검이 아닌 실제 측정이므로, 이제부터는 이벤트 수신함
                //    // ---------------------------------------------------------
                //    m_ucMbT_List[chidx].ConnectionChecking = false;
                //}
                                    
                StartTest(chidx);
            }
        }

        private bool isChannelAlived(int chidx)
        {
            bool bret = false;
            int boardid = Board_Ch_Mapping[chidx];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(chidx);  // ghbaik2
            if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
            {
                // if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V > 1)
                // ------------------------------------------------------
                // 셀의 종류에 따라, 1V 이하로 내려갈 수 있으모르
                // Limit값을 1에서 0.01로 변경, BGH 230710
                // ------------------------------------------------------
                // if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V > 0.01)
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V >= 0)
                {
                    bret = true;
                }
            }
            return bret;
        }


        private delegate void Delegate_ClearStatusFlag(int chno);
        public void ClearStatusFlag(int chno)
        {
            if (this.InvokeRequired)
            {
                var d = new Delegate_ClearStatusFlag(ClearStatusFlag);
                this.Invoke(d, new object[] { chno });
                return;
            }

            int boardno = 0;
            int realchno = 0;
            for (int i = 1; i < m_clsSys_Set.m_Sys_BD.Count; i++)
            {
                if (chno < m_ucCycler_ABT_List[i].ChannelStartIndex) break;
                boardno = i;
            }
            realchno = chno - m_ucCycler_ABT_List[boardno].ChannelStartIndex;

            m_ucCycler_ABT_List[boardno].ClearStatusFlag(realchno);
        }

        // ------------------------------------
        // ghbaik
        // chno : base 0, display할때만 +1해서 표시!!
        // ------------------------------------
        //private delegate Display_Channel_Status Delegate_Set_Ch_Status(int chno);
        // 231027 BGH
        // 종료 후 모드를 종료로 표시하기 위해
        // ------------------------------------
        private Display_Channel_Status SetChannelStatus(int chno)
        {

            //if (this.InvokeRequired)
            //{
            //    var d = new Delegate_Set_Ch_Status(SetChannelStatus);
            //    this.Invoke(d, new object[] { chno });
            //    return null;
            //}
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();

            int boardno = 0;
            int bzch = 0;
            for (int i = 1; i < m_clsSys_Set.m_Sys_BD.Count; i++)
            {
                if (chno < m_ucCycler_ABT_List[i].ChannelStartIndex) break;
                boardno = i;
            }

            if (m_ucCycler_ABT_List[boardno].isConnected)
            {
                bzch = chno - m_ucCycler_ABT_List[boardno].ChannelStartIndex;

                // -----------------------------------------
                // ghbaik2
                // -----------------------------------------
                m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(chno);


                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬처리
                try
                {
                    m_dispChStatus.ch_s_parause = m_paramode[chno].use;
                    m_dispChStatus.ch_s_ismaster = m_paramode[chno].ismaster;
                    m_dispChStatus.ch_s_master_ch = m_paramode[chno].master_ch;
                }
                catch
                {
                    m_dispChStatus.ch_s_parause = false;
                    m_dispChStatus.ch_s_ismaster = false;
                    m_dispChStatus.ch_s_master_ch = 0;
                }
                //-


                // ghbaik
                m_dispChStatus.ch_s_Code = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].StatusCodeString;

                // -
                // 230511
                // -
                m_dispChStatus.isChamberWarming = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].m_ChamberWarming;

                switch (m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].m_step.steptype)
                {
                    case cls_stepInfo.enumStepType.STANDBY:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.NONE;
                        break;
                    case cls_stepInfo.enumStepType.CYCLE_START:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CYCLE_START;
                        break;
                    case cls_stepInfo.enumStepType.Charge:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CHARGE;
                        break;
                    case cls_stepInfo.enumStepType.Discharge:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.DISCHARGE;
                        break;
                    case cls_stepInfo.enumStepType.Rest:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.REST;
                        break;
                    case cls_stepInfo.enumStepType.OCV:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.OCV;
                        break;
                    case cls_stepInfo.enumStepType.MBT:
                    case cls_stepInfo.enumStepType.MCZ:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.ACIA;
                        break;
                    case cls_stepInfo.enumStepType.InsulationTest:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.INSULATE;
                        break;
                    case cls_stepInfo.enumStepType.CYCLE_END:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CYCLE_END;
                        break;

                    case cls_stepInfo.enumStepType.Pause:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PAUSE;
                        break;

                    case cls_stepInfo.enumStepType.Ready:
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.READY;
                        break;

                    case cls_stepInfo.enumStepType.Pattern:
                        // -------------------------------
                        // 패턴모드는 충방전 표시 안함
                        // -------------------------------
                        m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PATTERN;
                        //if (m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].m_step.operaCondition.fltCurrent < 0) m_dispChStatus.ch_s_Step_Type = STEP_TYPE.DISCHARGE;
                        //else m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CHARGE;
                        break;

                    case cls_stepInfo.enumStepType.Wait_Charge:
                    case cls_stepInfo.enumStepType.Wait_Discharge:
                    case cls_stepInfo.enumStepType.Wait_InsulTest:
                    case cls_stepInfo.enumStepType.Wait_MBT:
                    case cls_stepInfo.enumStepType.Wait_MCZ:
                    case cls_stepInfo.enumStepType.Wait_OCV:
                    case cls_stepInfo.enumStepType.Wait_Pattern:
                    case cls_stepInfo.enumStepType.Wait_Rest:
                    case cls_stepInfo.enumStepType.Wait_Pause:
                    case cls_stepInfo.enumStepType.Wait_Ready:
                        if (m_dispChStatus.ch_s_Step_Type != STEP_TYPE.WORK_END)
                        {
                            m_dispChStatus.ch_s_Step_Type = STEP_TYPE.WAIT;
                        }
                        break;
                }

                //+ Add By LBG - 22.11.18 : Step Mode 추가
                switch (m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].m_step.stepmode)
                {
                    case cls_stepInfo.enumStepMode.CCCV: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CCCV; break;
                    case cls_stepInfo.enumStepMode.CC: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CC; break;
                    case cls_stepInfo.enumStepMode.CP: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CP; break;
                    case cls_stepInfo.enumStepMode.CR: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CR; break;
                    case cls_stepInfo.enumStepMode.CV: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CV; break;
                    case cls_stepInfo.enumStepMode.CPCV_CP:
                    case cls_stepInfo.enumStepMode.CPCV_CV:
                        m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CPCV; break;
                    default: m_dispChStatus.ch_s_Step_Mode = STEP_MODE.NONE; break;
                }
                //-

                // ---------------------------------
                // 대기표시 하기 위해, 230902 BGH
                // ---------------------------------
                m_dispChStatus.ch_s_Warmup = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].isRisedUp;
                
                // -
                // 
                // -
                m_dispChStatus.ch_s_Spent_Time = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].OGTime_Step_4disp;
                m_dispChStatus.ch_s_TotSpent_Time = m_ucStepInfo_List[chno].OGTime_Total_4disp;
                m_dispChStatus.ch_s_CV_Time = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].CVTime;
                
                //m_dispChStatus.isTesting = true;
                //m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

                m_dispChStatus.ch_s_Curr = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].Current_I;
                m_dispChStatus.ch_s_Volt = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].Current_V;

                //
                m_dispChStatus.ch_s_Capa = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].CurStep_Q; //  .Current_Q;
                m_dispChStatus.ch_s_Energy = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].CurStep_E; //.Current_E;
                m_dispChStatus.ch_s_Power = m_ucCycler_ABT_List[boardno].m_ChStatusList[bzch].Current_P;

                m_dispChStatus.ch_s_Sche_Name = sche_names[chno]; // m_CurChStatusInfo.Schedule_Name;
                m_dispChStatus.ch_s_Work_Name = work_names[chno]; // m_CurChStatusInfo.Work_Name;

                //+ Add By LBG - 22.11.18 : Alarm Status 표시 추가를 위한 Flag
                // Alarm이 있을 경우 하단 Flag 값에 넣어 주세요...
                //m_dispChStatus.ch_s_Exist_Alarm;
                //-
            }
            else
            {
                m_dispChStatus.ch_s_CH_No = chno + 1;
                m_dispChStatus.ch_s_Code = ""; // 0; // ghbaik
                m_dispChStatus.ch_s_Step_Type = STEP_TYPE.NONE;
                //+ Add By LBG - 22.11.18 : Step Mode 추가
                m_dispChStatus.ch_s_Step_Mode = STEP_MODE.NONE;

                // ----------
                // 230902
                // ----------
                //m_dispChStatus.ch_s_Warmup = false;

                //-
                //m_dispChStatus.ch_s_Status      = "Waiting"; // "N/A (Not Connected)";
                m_dispChStatus.ch_s_Curr = 0;
                m_dispChStatus.ch_s_Volt = 0;

                m_dispChStatus.ch_s_Capa = 0;
                m_dispChStatus.ch_s_Energy = 0;
                m_dispChStatus.ch_s_Power = 0;

                try
                {
                    m_dispChStatus.ch_s_Sche_Name = sche_names[chno]; // m_CurChStatusInfo.Schedule_Name;
                    m_dispChStatus.ch_s_Work_Name = work_names[chno]; // m_CurChStatusInfo.Work_Name;
                }
                catch
                {
                    m_dispChStatus.ch_s_Work_Name = "";
                    m_dispChStatus.ch_s_Sche_Name = "";
                }
            }
            return m_dispChStatus;
        }

        private void Mainframe_FormClosing(object sender, FormClosingEventArgs e)
        {
            string n_sMsg = string.Empty;

            if(SystemLanguage == LanguageType.KOREAN)
            {
                n_sMsg = "프로그램을 종료 하시겠습니까?";
            }
            else if (SystemLanguage == LanguageType.ENGLISH)
            {
                n_sMsg = "Are you sure you want to exit the program?";
            }

            if (MessageBox.Show(new Form { TopMost = true }, n_sMsg, "ABT System", MessageBoxButtons.OKCancel, MessageBoxIcon.Question) == DialogResult.OK)
            {
                KillTimer(1);
                KillTimer(2);


                Timer10ms.Stop();
                Timer100ms.Stop();

                //+ Add by YMJ - 250410 : 프로그램 종료 시 UDP 통신 종료
                if (m_udpClient != null)
                {
                    m_udpClientSend = false;
                    m_udpClient?.Close();
                }
                //-

                if (m_ucCycler_ABT_List != null)
                {
                    for (int i = 0; i < m_ucCycler_ABT_List.Count; i++)
                    {
                        m_ucCycler_ABT_List[i].DisCoNnect();
                    }
                    m_ucCycler_ABT_List.Clear();
                }

                // +
                if (m_ucDAU_List != null)
                {
                    for (int i = 0; i < m_ucDAU_List.Count; i++)
                    {
                        m_ucDAU_List[i].StopTCP();
                    }
                    m_ucDAU_List.Clear();
                }
                // -

                if (m_ucStepInfo_List != null)
                {
                    m_ucStepInfo_List.Clear();
                }

                if (m_ucMbT_List != null)
                {
                    m_ucMbT_List.Clear();
                }

                if (m_ucBalancer_List != null)
                {
                    for (int i = 0; i < m_ucBalancer_List.Count; i++)
                    {
                        if (m_ucBalancer_List[i].isConnected)
                        {
                            m_ucBalancer_List[i].ClosePortForced();
                            m_ucBalancer_List[i].StopSerial();
                        }
                    }
                }

                if (m_ucChamber.EnableFlag)
                {
                    m_ucChamber.StopAction();
                    m_ucChamber.SP = 999.99; // 999.99f;
                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                    m_ucChamber.HUMIDITY_S = 0;
                    //-
                    //+ Revision by KGY -20250109 : StopSerial 매개 변수 추가(MainForm 닫는 경우에만 CloseLog)
                    m_ucChamber.StopSerial(true);
                    //-
                    m_ucChamber.DoesWorking = false;
                }

                if (m_ucChamberDIO.EnableFlag)
                {
                    m_ucChamberDIO.StopSerial();
                }

                //+ Add by KGY -250113 : 절연저항기 측정 중일경우 종료 처리 추가
                if (m_ucIT_List != null && m_ucIT_List.Count > 0)
                {
                    for(int i = 0; i < m_ucIT_List.Count; i++)
                    {
                        if (m_ucIT_List[i].IsMeasuring)
                        {
                            m_ucIT_List[i].InsTestStop();
                        }

                        m_ucIT_List[i].InsDisConnected();
                    }
                }
                //-

				if (m_ucTVocSOCList != null && m_ucTVocSOCList.Count > 0)
				{
					for (int i = 0; i < m_ucTVocSOCList.Count; i++)
					{
						if (m_ucTVocSOCList[i].IsConnected) m_ucTVocSOCList[i].Stop_tVOC();
					}
				}

                //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
                if (m_ucChiller != null && m_ucChiller.Count > 0)
                {
                    if (m_bChiller_Use)
                    {
                        for (int i = 0; i < m_ucChiller.Count; i++)
                        {
                            if (m_ucChiller.ContainsKey(i) && m_ucChiller[i].EnableFlag)
                            {
                                m_ucChiller[i].StopAction();
                                Thread.Sleep(100);
                                m_ucChiller[i].SP = 999.99; // 999.99f;
                                m_ucChiller[i].Flow_SP = 0;

                                m_ucChiller[i].StopSerial();
                                m_ucChiller[i].DoesWorking = false;
                            }
                        }
                    }
                }
                //-
                //-

                CloseAlarmLog();
                CloseSystemLog();

                // 231124
                if (m_Tmr_Channel_Disp_Detail != null)
                {
                    m_Tmr_Channel_Disp_Detail.Change(sysTimeout.Infinite, sysTimeout.Infinite);
                }

                //+ Add by LBG - 240411 : 프로그램 종료 시 Scheduler 프로그램도 종료
                Process[] processes = Process.GetProcessesByName("ABT_Scheduler");
                foreach (Process process in processes)
                {
                    process.Kill();
                }
                //-
            }
            else
            {
                e.Cancel = true;
            }
        }

        #region LBG
        /// <summary>
        /// LBG : 사용자가 EMG 버튼을 클릭 하였을 시 Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_EMG_Click(object sender, EventArgs e)
        {
            //+ Add by LBG - 230822 : Cycler와 통신 연결이 되지 않았을 경우 해당 기능 막기
            bool n_bIs_BD_Connected = false;
            if (m_ucBoard_Status != null)
            {
                n_bIs_BD_Connected = m_ucBoard_Status.GetBoardConnectivity(0);
            }
            //-

            if (n_bIs_BD_Connected)
            {
                frmEMG_Msg n_Dlg = new frmEMG_Msg(this);
                n_Dlg.StartPosition = FormStartPosition.CenterParent;

                if (n_Dlg.ShowDialog() == DialogResult.OK)
                {
                    // 비상정지를 할 경우 코드 입력
                    try
                    {
                        WriteSystemLog("// Emergency Stop [S/W EPO] //");

                        for (int i = 0; i < m_Tot_Ch_Count; i++)
                        {
                            //EndTest(i);
                            EndTest2ndStep(i);
                        }
                    }
                    catch { }
                }
            }
        }

        // -----------------------------------
        // ghbaik
        // -----------------------------------
        //private delegate void SetLabelText_delegate(Label ctrl_lbl, string msg);
        //public void SetLabelText(Label ctrl_lbl, string msg)
        //{
        //    if (this.InvokeRequired)
        //    {
        //        SetLabelText_delegate d = new SetLabelText_delegate(SetLabelText);
        //        this.Invoke(d, new object[] { ctrl_lbl, msg });
        //        return;
        //    }

        //    if (ctrl_lbl == null || msg == null) return;
        //    if (ctrl_lbl.Text == msg)
        //    {
        //        ctrl_lbl.ForeColor = Color.Black;
        //    }
        //    else
        //    {
        //        ctrl_lbl.Text = msg;
        //        ctrl_lbl.ForeColor = Color.IndianRed;
        //    }

        //}

        //+ Add By LBG - 231204 : Channel Display Data 처리 부분 한쪽으로 통합
        private void m_Tmr_Channel_Disp_Detail_Tick(object n_State)
        {
            //+ Revision By YMJ - 241217 : 선택 시에만 동작하도록 변경
            if (m_iCur_CH_NO >= 0)
            {
                if (IsOnTesting[m_iCur_CH_NO])
                {
                    ReNewChDispInformation(m_iCur_CH_NO);
                    Disp_Chanel_Info(m_CurChStatusInfo);
                }
                else
                {
                    Disp_Chanel_InitInfo(m_iCur_CH_NO);
                }
            }
            //-
        }
        //-

        /// <summary>
        /// LBG : Cross Threading 방지 Delegate 선언
        /// </summary>
        /// <param name="n_Info"></param>
        private delegate void Delegate_Disp_Chanel_Info(Channel_Info n_Info);
        /// <summary>
        /// LBG : 채널 상세 정보 출력을 위한 Display 함수
        /// </summary>
        /// <param name="n_Info"></param>
        public void Disp_Chanel_Info(Channel_Info n_Info)
        {
            if (this.InvokeRequired)
            {
                var d = new Delegate_Disp_Chanel_Info(Disp_Chanel_Info);
                this.Invoke(d, new object[] { n_Info });
                return;
            }

            int mych = n_Info.CH_NO - 1;
            if (mych < 0) mych = 0;

            //+ 공정 진행 정보
            //+ Add by LBG - 230403 : 언어 변경 적용
            if (this.SystemLanguage == LanguageType.KOREAN)
            {
                grp_Ch_Info.Text = " 채널 공정 정보 [채널 " + n_Info.CH_NO.ToString("D2") + "]";
                // ghbaik
                //grp_Ch_Info.Text = " Channel status [CH-" + n_Info.CH_NO.ToString("D2") + "]";
            }
            else if (this.SystemLanguage == LanguageType.ENGLISH)
            {
                grp_Ch_Info.Text = " Channel Running Information [CH " + n_Info.CH_NO.ToString("D2") + "]";
            }
            //-

            // -----------------------
            // ghbaik
            // -----------------------
            string mstr = "-";
            switch (n_Info.CH_StepType)
            {
                case STEP_TYPE.PAUSE: mstr = "PAUSE"; break;
                case STEP_TYPE.READY: mstr = "READY"; break;

                case STEP_TYPE.CYCLE_START: mstr = "CYCLE START"; break;

                case STEP_TYPE.CHARGE: 
                    //if (n_Info.CH_isWarmup)
                    //{
                        mstr = "CHARGE";
                        switch (n_Info.CH_STepMode)
                        {
                            case STEP_MODE.CC: mstr = mstr + "(CC)"; break;
                            case STEP_MODE.CV: mstr = mstr + "(CV)"; break;
                            case STEP_MODE.CCCV: mstr = mstr + "(CC/CV)"; break;
                            case STEP_MODE.CP: mstr = mstr + "(CP)"; break;
                            case STEP_MODE.CR: mstr = mstr + "(CR)"; break;
                            case STEP_MODE.CPCV: mstr = mstr + "(CP/CV)"; break;
                            default:
                                mstr = mstr + "(??)"; break;
                        }
                    //}
                    //else
                    //{
                    //    mstr = "READY_CHARGE";
                    //}
                    break;

                case STEP_TYPE.DISCHARGE: 
                    //if (n_Info.CH_isWarmup)
                    //{
                        mstr = "DISCHARGE";
                        switch (n_Info.CH_STepMode)
                        {
                            case STEP_MODE.CC: mstr = mstr + "(CC)"; break;
                            case STEP_MODE.CV: mstr = mstr + "(CV)"; break;
                            case STEP_MODE.CCCV: mstr = mstr + "(CC/CV)"; break;
                            case STEP_MODE.CP: mstr = mstr + "(CP)"; break;
                            case STEP_MODE.CR: mstr = mstr + "(CR)"; break;
                            case STEP_MODE.CPCV: mstr = mstr + "(CP/CV)"; break;
                            default:
                                mstr = mstr + "(??)"; break;
                        }
                    //}
                    //else
                    //{
                    //    mstr = "READY_DISCHARGE";
                    //}
                    break;

                case STEP_TYPE.PATTERN: mstr = "PATTERN"; break;  // ghbaik

                case STEP_TYPE.REST: mstr = "REST"; break;
                case STEP_TYPE.ACIA: mstr = "ACIA"; break;
                case STEP_TYPE.INSULATE: mstr = "INSULATE"; break;
                case STEP_TYPE.CYCLE_END: mstr = "CYCLE END"; break;
                case STEP_TYPE.WORK_END: mstr = "WORK END"; break;
                case STEP_TYPE.NONE: mstr = "STANDBY"; break;
                case STEP_TYPE.OCV: mstr = "OCV"; break;

                case STEP_TYPE.WAIT:
                    mstr = "PAUSE";
                    //if (n_Info.CH_isPaused) mstr = "Pause";
                    //else mstr = "Wait";
                    break;
            }

            if (n_Info.CH_isChamberWarming)
            {
                mstr = "CHAMBER WAIT..";
            }

            //SetLabelText(lb_V_CH_Type, mstr);
            lb_V_CH_Type.Text = mstr;
            lb_V_CH_Code.Text = n_Info.CH_Code;

            if (IsOnTesting[mych])
            {
                TimeSpan tdiff = new TimeSpan(0, 0, 0, 0, 0);

                // -------------
                // Total
                // -------------
                //tdiff = DateTime. Now - n_Info. CH_Total_Time;
                //if (!n_Info.CH_isPaused)
                //{
                //    tdiff = DateTime.Now - n_Info.CH_Total_Time;                    
                //}
                //tdiff = tdiff.Add(n_Info.CH_TotSpent_Time);

                tdiff = n_Info.CH_TotSpent_Time;
                if (tdiff.Days > 0)
                {
                    mstr = tdiff.Days.ToString("D2") + " " + tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2");
                }
                else
                {
                    mstr = tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2");
                }
                lb_V_CH_T_Time.Text = mstr; // 

                // --------------------
                // Step
                // -------------------
                //tdiff = new TimeSpan(0, 0, 0, 0);
                //if (!n_Info.CH_isPaused)
                //{
                //    tdiff = DateTime.Now - n_Info.CH_Step_Time;
                //}
                //tdiff = tdiff.Add(n_Info.CH_Spent_Time);
                tdiff = n_Info.CH_Spent_Time;
                if (tdiff.Days > 0)
                {
                    mstr = tdiff.Days.ToString("D2") + " " + tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2");
                }
                else
                {
                    mstr = tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2");
                }
                lb_V_CH_S_Time.Text = mstr; // SetLabelText(lb_V_CH_S_Time, mstr);
            }

            lb_V_CH_T_Cycle.Text = n_Info.CH_Total_Cycle.ToString();  //SetLabelText(lb_V_CH_T_Cycle, n_Info.CH_Total_Cycle.ToString()); //
            lb_V_CH_C_Cycle.Text = n_Info.CH_Cur_Cycle.ToString();  //SetLabelText(lb_V_CH_C_Cycle, n_Info.CH_Cur_Cycle.ToString()); //
            lb_V_CH_T_Step.Text = n_Info.CH_Total_Step.ToString();  //SetLabelText(lb_V_CH_T_Step, n_Info.CH_Total_Step.ToString()); //
            lb_V_CH_C_Step.Text = n_Info.CH_Cur_Step.ToString();  //SetLabelText(lb_V_CH_C_Step, n_Info.CH_Cur_Step.ToString()); //

            //+ Add by LBG - 230403 : 언어 변경 적용
            if (SystemLanguage == LanguageType.KOREAN)
            {
                lb_V_CH_Schedule.Text = "스케쥴명 : " + Path.GetFileNameWithoutExtension(n_Info.Schedule_Name); //lb_V_CH_Schedule.Text   = n_Info.Schedule_Name;
            }
            else if (SystemLanguage == LanguageType.ENGLISH)
            {
                lb_V_CH_Schedule.Text = "Sche. Name : " + Path.GetFileNameWithoutExtension(n_Info.Schedule_Name); //lb_V_CH_Schedule.Text   = n_Info.Schedule_Name;
            }

            //+ Add By LBG - 230103 : 백이사님 요청, Work Name 표시 추가
            if (SystemLanguage == LanguageType.KOREAN)
            {
                lb_V_CH_WorkName.Text = "작업명 : " + n_Info.Work_Name; //lb_V_CH_Schedule.Text   = n_Info.Schedule_Name;
            }
            else if (SystemLanguage == LanguageType.ENGLISH)
            {
                lb_V_CH_WorkName.Text = "Work Name : " + n_Info.Work_Name; //lb_V_CH_Schedule.Text   = n_Info.Schedule_Name;
            }
            //-
            //-

            //+ 동작 정보
            // lb_V_CH_Volt.Text = n_Info.CH_Volt.ToString("0.000");  // SetLabelText(lb_V_CH_Volt, n_Info.CH_Volt.ToString("0.000")); //
            lb_V_CH_Volt.Text = n_Info.CH_Volt.ToString(Volt_Number_Digit);  // SetLabelText(lb_V_CH_Volt, n_Info.CH_Volt.ToString("0.000")); //
            lb_V_CH_Curr.Text = n_Info.CH_Curr.ToString("0.000");  //SetLabelText(lb_V_CH_Curr, n_Info.CH_Curr.ToString("0.000")); //
            lb_V_CH_Capa.Text = n_Info.CH_Capa.ToString("0.000");  // SetLabelText(lb_V_CH_Capa, n_Info.CH_Capa.ToString("0.000")); //
            lb_V_CH_C_Capa.Text = n_Info.CH_Char_Capa.ToString("0.000");  //SetLabelText(lb_V_CH_C_Capa, n_Info.CH_Char_Capa.ToString("0.000")); //
            lb_V_CH_D_Capa.Text = n_Info.CH_Disc_Capa.ToString("0.000");  // SetLabelText(lb_V_CH_D_Capa, n_Info.CH_Disc_Capa.ToString("0.000")); //
            lb_V_CH_Energy.Text = n_Info.CH_Energy.ToString("0.000");  // SetLabelText(lb_V_CH_Energy, n_Info.CH_Energy.ToString("0.000")); //
            lb_V_CH_C_Energy.Text = n_Info.CH_Charge_wh.ToString("0.000");  // SetLabelText(lb_V_CH_C_Energy, n_Info.CH_Charge_wh.ToString("0.000")); //
            lb_V_CH_D_Energy.Text = n_Info.CH_Discharge_wh.ToString("0.000");  // SetLabelText(lb_V_CH_D_Energy, n_Info.CH_Discharge_wh.ToString("0.000")); //
            lb_V_CH_Power.Text = n_Info.CH_Power.ToString("0.000");  //SetLabelText(lb_V_CH_Power, n_Info.CH_Power.ToString("0.000")); //

            if (n_Info.CH_Temperature > -50 && n_Info.CH_Temperature < 100)
            {
                // SetLabelText(lb_V_CH_Temperature, n_Info.CH_Temperature.ToString("0.000")); //lb_V_CH_Temperature.Text    = n_Info.CH_Temperature.ToString("0.000");
                lb_V_CH_Temperature.Text = n_Info.CH_Temperature.ToString("0.0");  //SetLabelText(lb_V_CH_Temperature, n_Info.CH_Temperature.ToString("0.0")); //
            }
            else
            {
                //SetLabelText(lb_V_CH_Temperature, "");
                lb_V_CH_Temperature.Text = "";
            }

            if (n_Info.CH_Frequency > 0)
            {
                lb_V_CH_Freq.Text = n_Info.CH_Frequency.ToString("0.000");  //SetLabelText(lb_V_CH_Freq, n_Info.CH_Frequency.ToString("0.000")); //
                lb_V_CH_IM.Text = n_Info.CH_IM.ToString("0.00000");  //SetLabelText(lb_V_CH_IM, n_Info.CH_IM.ToString("0.00000")); //
                lb_V_CH_RE.Text = n_Info.CH_RE.ToString("0.00000");  //SetLabelText(lb_V_CH_RE, n_Info.CH_RE.ToString("0.00000")); //
                lb_V_CH_RS.Text = n_Info.CH_RS.ToString("0.00000"); // LBG //SetLabelText(lb_V_CH_RS, n_Info.CH_RS.ToString("0.00000")); //
                lb_V_CH_RCT.Text = n_Info.CH_RCT.ToString("0.00000");// LBG //SetLabelText(lb_V_CH_RCT, n_Info.CH_RCT.ToString("0.00000")); //
            }
            else
            {
                lb_V_CH_Freq.Text = "";
                lb_V_CH_IM.Text = "";
                lb_V_CH_RE.Text = "";
                lb_V_CH_RS.Text = "";
                lb_V_CH_RCT.Text = "";
            }

            if (m_ITDevEnable)
            {
                if (m_ucIT_List.Count > mych)
                {
                    lb_V_CH_INSUL.Text = n_Info.CH_INSUL_1 + " / " + n_Info.CH_INSUL_2;
                }
                else
                {
                    lb_V_CH_INSUL.Text = "";
                }
            }
            else
            {
                lb_V_CH_INSUL.Text = "";
            }
            //-
        }

        private delegate void Delegate_Disp_Chanel_InitInfo(int ch);
        public void Disp_Chanel_InitInfo(int ch)
        {

            if (this.InvokeRequired)
            {
                // ---------------------------------
                // 231203 BGH
                // ---------------------------------
                try
                {
                    var d = new Delegate_Disp_Chanel_InitInfo(Disp_Chanel_InitInfo);
                    this.Invoke(d, new object[] { ch });
                    // return;
                }
                catch { }
                return;

            }


            //+ 공정 진행 정보
            // ghbaik
            //grp_Ch_Info.Text = " 채널 상세 정보 [채널 " + (ch + 1).ToString("D2") + "]";
            //+ Add by LBG - 230403 : 언어 변경 적용
            if (this.SystemLanguage == LanguageType.KOREAN)
            {
                grp_Ch_Info.Text = " 채널 공정 정보 [채널 " + (ch + 1).ToString("D2") + "]";
            }
            else if (this.SystemLanguage == LanguageType.ENGLISH)
            {
                grp_Ch_Info.Text = " Channel Running Information [CH " + (ch + 1).ToString("D2") + "]";
            }
            //-

            // -----------------------
            // ghbaik
            // -----------------------
            string mstr = " "; //ghbaik,  "Idle";
            lb_V_CH_Type.Text = mstr;

            lb_V_CH_Code.Text = " ";

            lb_V_CH_T_Time.Text = " ";
            lb_V_CH_S_Time.Text = " ";

            lb_V_CH_T_Cycle.Text = " ";
            lb_V_CH_C_Cycle.Text = " ";
            lb_V_CH_T_Step.Text = " ";
            lb_V_CH_C_Step.Text = " ";

            lb_V_CH_Schedule.Text = " ";
            //+ Add By LBG - 230103 : 백이사님 요청 Work Name 추가
            lb_V_CH_WorkName.Text = " ";
            //-
            //-

            //+ 동작 정보
            lb_V_CH_Volt.Text = " "; // n_Info.CH_Volt.ToString("0.000");
            lb_V_CH_Curr.Text = " "; //           = n_Info.CH_Curr.ToString("0.000");
            lb_V_CH_Capa.Text = " "; //           = n_Info.CH_Capa.ToString("0.00000");
            lb_V_CH_C_Capa.Text = " "; //         = n_Info.CH_Char_Capa.ToString("0.00000");
            lb_V_CH_D_Capa.Text = " "; //        = n_Info.CH_Disc_Capa.ToString("0.00000");
            lb_V_CH_Energy.Text = " "; //         = n_Info.CH_Energy.ToString("0.00000");
            lb_V_CH_C_Energy.Text = " "; //      = n_Info.CH_Charge_wh.ToString("0.00000");
            lb_V_CH_D_Energy.Text = " "; //   = n_Info.CH_Discharge_wh.ToString("0.00000");
            lb_V_CH_Power.Text = " "; //         = n_Info.CH_Power.ToString("0.00000");

            lb_V_CH_Temperature.Text = " "; //    = n_Info.CH_Temperature.ToString("0.000");
            lb_V_CH_Freq.Text = " "; //          = n_Info.CH_Frequency.ToString("0.000");
            lb_V_CH_IM.Text = " "; //             = n_Info.CH_IM.ToString("0.00000");
            lb_V_CH_RE.Text = " "; //             = n_Info.CH_RE.ToString("0.00000");
            lb_V_CH_RS.Text = " "; //            = n_Info.CH_RS.ToString("0.00000"); // LBG
            lb_V_CH_RCT.Text = " "; //            = n_Info.CH_RCT.ToString("0.00000");// LBG
            //-

            lb_V_CH_INSUL.Text = "";  // 231114 BGH
        }

        // --------------------------------------------------
        // ghbaik
        // --------
        // 채널을 선택하면, 선택한 채널 인덱스 배열 목록을 설정
        // --------------------------------------------------
        public void SetScheduleSelection(int[] setsche)
        {
            if (setsche == null)
            {
                m_SelCh4Schedule = null;
                return;
            }
            if (setsche.Length < 1)
            {
                m_SelCh4Schedule = null;
                return;
            }

            m_SelCh4Schedule = new int[setsche.Length];
            Array.Copy(setsche, m_SelCh4Schedule, m_SelCh4Schedule.Length);


            bool pMenuActive = false;
            int boardid = 0;
            int selch = 0;
            int bzch = 0;

            // ------------------------------------------------------------------------
            // 여러채널 선택했을때, 통신보드가 살아있는 놈이 한개라도 있어야 팝업이 유효함.
            // ------------------------------------------------------------------------
            // 231211 블럭처리
            // string sysmsg = "// Ch Selection // ";
            for (int i = 0; i < m_SelCh4Schedule.Length; i++)
            {
                //  sysmsg += ((i + 1).ToString("D3") + " ");
                selch = m_SelCh4Schedule[i];
                boardid = Board_Ch_Mapping[selch];  // ghbaik
                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);  // ghbaik2

                // ------------------------------------------------------
                // 셀의 종류에 따라, 1V 이하로 내려갈 수 있으모르
                // Limit값을 0.01로 설정, BGH 230710
                // ------------------------------------------------------
                if (m_ucBoard_Status.GetBoardConnectivity(boardid) &&
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V >= 0)  // 전압도 올라와야 함. 230710
                {
                    pMenuActive = true;
                    break;
                }

            }
            // WriteSystemLog(sysmsg);

            if (pMenuActive)
            {
                bt_CH_Work_Start.Enabled = true;
                bt_CH_Work_End.Enabled = true;
                bt_CH_Work_Schedule.Enabled = true;
                bt_CH_Next_Step.Enabled = true;
                bt_CH_Graph_RT_Cycler.Enabled = true;
                bt_CH_Graph_RT_ACIA.Enabled = true;

                //+ Add by LBG - 230822 : Main Menu에서 제어 부분 버튼 처리
                mn_Control_Start.Enabled        = true;
                mn_Control_Stop.Enabled         = true;
                mn_Control_Next_Step.Enabled    = true;
                mn_Control_Schedule.Enabled     = true;
                mn_Control_Graph.Enabled        = true;
                mn_Control_Nyquist.Enabled      = true;
                //-

                m_ucChannel_Status.SetPopupEnabledStatus(true);
            }
            else
            {
                bt_CH_Work_Start.Enabled        = false;
                bt_CH_Work_End.Enabled          = false;
                bt_CH_Work_Schedule.Enabled     = false;
                bt_CH_Next_Step.Enabled         = false;
                bt_CH_Graph_RT_Cycler.Enabled   = false;
                bt_CH_Graph_RT_ACIA.Enabled     = false;

                //+ Add by LBG - 230822 : Main Menu에서 제어 부분 버튼 처리
                mn_Control_Start.Enabled        = false;
                mn_Control_Stop.Enabled         = false;
                mn_Control_Next_Step.Enabled    = false;
                mn_Control_Schedule.Enabled     = false;
                mn_Control_Graph.Enabled        = false;
                mn_Control_Nyquist.Enabled      = false;
                //-

                m_ucChannel_Status.SetPopupEnabledStatus(false);
            }

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            m_ucChannel_Status.SetParalPopupEnabledStatus(m_bParallel_Use);
            //-
            
        }

        /// <summary>
        /// LBG : 선택된 채널의 작업 시작 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Work_Start_Click(object sender, EventArgs e)
        {
            //+ Revision by YMJ - 250131 : 스타트 로직 일원화 및 타입 추가
            Start_Schedule(1);
            //-
        }

        /// <summary>
        /// LBG : 선택된 채널의 작업 종료 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Work_End_Click(object sender, EventArgs e)
        {
            WriteSystemLog(">> End work [Main]");
            if (m_SelCh4Schedule == null)
            {
                WriteSystemLog(">> Cancel [Not selected ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "작업 종료", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Stop Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-                
                return;
            }

            if (m_iCur_CH_NO >= 0)
            {
                // ------------------------------------------------------------------
                string drmsg1 = "";
                string drmsg2 = "";
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                    drmsg2 = "작업 종료";
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    drmsg1 = "Do you want to proceed selected job?";
                    drmsg2 = "Stop Work";
                }
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                if (dr == DialogResult.Yes)
                {
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        // -------------------------------------------
                        // Safety 처리
                        // 현 채널과 관련있는 알람들을 리스트에서 제거
                        // -------------------------------------------
                        RemoveAlarm(m_SelCh4Schedule[i]);
                        EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER, true);  // 종료전에 마지막 레코드 삽입, 231115 BGH
                        EndTest2ndStep(m_SelCh4Schedule[i]);                        
                        WriteSystemLog(m_SelCh4Schedule[i], ">> End Work [Main]" , true);
                    }

                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                    if (m_ucChamber.isConnected)
                    {
                        //if (m_ucChamber.DoesWorking)
                        {
                            m_ucChamber.RemoveCh(m_iCur_CH_NO);
                            if (m_ucChamber.GetCount() == 0)
                            {
                                m_ucChamber.StopAction();
                                Thread.Sleep(100);
                                // m_ucChamber.StopSerial();
                                m_ucChamber.DoesWorking = false;
                                m_ucChamber.SP = 0; // -100; // -100.0f;
                                m_ucChamber.HUMIDITY_S = 0;
                                // -------------------------
                                // 230917, BGH
                                ResetChamberMaintainSetting();
                            }
                        }
                    }
                    //-
                }
                else
                {
                    WriteSystemLog(">> 'NO' selected");
                }
                // ------------------------------------------------------------------
            }
            else
            {
                WriteSystemLog(">> Cancel work[End work - No seleched ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "작업 종료", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Stop Work", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
            }
            // EndTest(m_Cur_Ch_idx);
        }

        /// <summary>
        /// LBG : 선택된 채널의 작업 일시 정지 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Work_Pause_Click(object sender, EventArgs e)
        {

        }

        /// <summary>
        /// LBG : 선택된 채널의 작업 예약 설정 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Work_Reserve_Click(object sender, EventArgs e)
        {

        }

        /// <summary>
        /// LBG : 선택된 채널의 현재 작업 중인 Schedule 확인 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Work_Schedule_Click(object sender, EventArgs e)
        {
            WriteSystemLog("// View schedule [Main]");
			if (!IsOnTesting[m_iCur_CH_NO])
			{
				WriteSystemLog(m_iCur_CH_NO, "// View schedule [Main] - NOT On Test", false);
				return;
			}

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(m_iCur_CH_NO))
            {
                WriteSystemLog(m_iCur_CH_NO, ">> Graph View Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            //+ Revision by YMJ - 240208 : 스케줄보기 클릭 시 기존 창 열려있을 경우 기존 창 닫고 새창으로 열기
            if (!m_bCurSchedule_View)
            {
                WriteSystemLog(m_iCur_CH_NO, ">> View schedule - " + Recipe_Files[m_iCur_CH_NO], false);
            }
            else
            {
                WriteSystemLog(m_iCur_CH_NO, ">> View schedule [react]", false);

                m_frmRecipeView.Close();
            }

            int m_cstep = m_ucStepInfo_List[m_iCur_CH_NO].m_currentStepNo;
            if (m_cstep < 1 || m_cstep >= Recipe_Files[m_iCur_CH_NO].Length) m_cstep = 0;

            m_bCurSchedule_View = true;
            m_frmRecipeView = new frmRecipe_View(this, m_iCur_CH_NO, Recipe_Files[m_iCur_CH_NO], m_cstep); // m_CurChStatusInfo.Schedule_Path);
            m_frmRecipeView.StartPosition = FormStartPosition.CenterParent;

            // ---------------------------
            // Event 지정
            // ---------------------------
            OnChangedStepNumber += m_frmRecipeView.Set_Highlight_Step;

            m_frmRecipeView.Show();
            //-
        }

        /// <summary>
        /// LBG : 선택된 채널의 작업 Schedule 변경 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Change_Scehdule_Click(object sender, EventArgs e)
        {

        }

        /// <summary>
        /// LBG : 선택된 채널의 현재 작업 Step을 다음 Step으로 변경 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Next_Step_Click(object sender, EventArgs e)
        {
            WriteSystemLog(">> Next step [Main]");
            if (m_SelCh4Schedule == null)
            {
                WriteSystemLog(">> Cancel work[Next step - No seleched ch]");

                //+ 
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "다음 작업", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Next Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
                return;
            }

            if (m_iCur_CH_NO >= 0)
            {
                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 한개 채널 선택 시 Slave 채널이면 return
                if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_SelCh4Schedule[0]))
                {
                    WriteSystemLog(m_SelCh4Schedule[0], ">> Move next step is Cancelled [Parallel slave channel]", true);
                    return;
                }
                //-

                // ------------------------------------------------------------------
                string drmsg1 = "";
                string drmsg2 = "";
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                    drmsg2 = "다음 Step";
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    drmsg1 = "Do you want to proceed selected job?";
                    drmsg2 = "Next Step";
                }
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                if (dr == DialogResult.Yes)
                {
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        // -------------------------------------------
                        // Safety 처리
                        // 현 채널과 관련있는 알람들을 리스트에서 제거
                        // -------------------------------------------

                        //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                        if (CheckParallelSlave(m_SelCh4Schedule[i]))
                        {
                            WriteSystemLog(m_SelCh4Schedule[i], ">> Move to next step Cancelled [Parallel slave channel]", true);
                        }
                        //-
                        else
                        {
	                        RemoveAlarm(m_SelCh4Schedule[i]);
	                        EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER);  // NONE에서 USER로 변경, 231115 BGH
	
	                        WriteSystemLog(m_SelCh4Schedule[i], ">> Move to next step", true);
						}
                    }
                }
                else
                {
                    WriteSystemLog(">> 'NO' selected");
                }
            }
            else
            {
                WriteSystemLog(">> Cancel work[Next step - No seleched ch]");

                //+ Add by LBG - 230403 : 언어 변경 적용
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show(new Form { TopMost = true }, "작업하실 채널을 먼저 선택하여 주십시오.", "다음 Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Please select the channel you want to work on first.", "Next Step", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                //-
            }
        }

        /// <summary>
        /// LBG : 선택된 채널의 Cycler 실시간 그래프 출력 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void bt_CH_Graph_RT_Cycler_Click(object sender, EventArgs e)
        {
            WriteSystemLog("// View RT-Graph [Main]");
            if (!m_bGraph_RT_Cycler)
            {
                m_bGraph_RT_Cycler = true;

                WriteSystemLog(m_iCur_CH_NO, "View RT-Graph [Main]", false);

                m_Graph_RT_Cycler = new frmGraph_RT_Cycler(this, m_iCur_CH_NO);
                m_Graph_RT_Cycler.StartPosition = FormStartPosition.CenterParent;

                m_Graph_RT_Cycler.Show();
            }
            else
            {
                if (m_Graph_RT_Cycler != null)
                {
                    m_Graph_RT_Cycler.WindowState = FormWindowState.Normal;
                    m_Graph_RT_Cycler.Activate();
                }
                else
                {
                    m_bGraph_RT_Cycler = true;

                    m_Graph_RT_Cycler = new frmGraph_RT_Cycler(this, m_iCur_CH_NO);
                    m_Graph_RT_Cycler.StartPosition = FormStartPosition.CenterParent;

                    m_Graph_RT_Cycler.Show();
                }
            }
        }

        /// <summary>
        /// LBG : 선택된 채널의 ACIA 실시간 그래프 출력 버튼 Click Event 함수
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private int isACIAStep(int ch_acia)
        {
            int iret = 0;   // NO ACIA
            try
            {
                int CurrentNo; // = mtControlData[ch].CurrentNo;
                cls_stepInfo CurStInfo = new cls_stepInfo(this);
                //+ Revision by YMJ - 250630 : 불필요 항목 삭제
                //cls_stepInfo.struStep mStep = new cls_stepInfo.struStep();
                //-

                CurStInfo = m_ucStepInfo_List[ch_acia];
                CurrentNo = CurStInfo.m_currentStepNo;
                //+ Revision by YMJ - 250630 : 불필요 항목 삭제
                //mStep = CurStInfo.m_steplist[CurrentNo];
                //-
                
                iret = 0;
                //+ Revision by YMJ - 250630 : 현재 스텝 조건 탐색 부분 추가
                if (CurrentNo != -1)
                {
                    if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.MCZ) { iret = 2; }
                    else if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.MBT) { iret = 1; }
                }
                //-
            }
            catch { }

            return iret;
        }

        private void bt_CH_Graph_RT_ACIA_Click(object sender, EventArgs e)
        {
            int iret = isACIAStep(m_iCur_CH_NO);
            WriteSystemLog("// View ACIA Graph - MBT [Main]");

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            //+ Revision by YMJ - 250630 : 선택 항목 중 가장 앞쪽 채널 정보 가져오도록 오류 수정
            if (CheckParallelSlave(m_SelCh4Schedule[0]))
            //-
            {
                WriteSystemLog(m_iCur_CH_NO, ">> Graph View Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            if ((!m_bGraph_RT_ACIA) && (iret > 0))
            {
                m_bGraph_RT_ACIA = true;

                WriteSystemLog(m_iCur_CH_NO, "View ACIA Graph [Main]", false);

                m_Graph_RT_ACIA = new frmGraph_RT_ACIA(this, m_iCur_CH_NO);
                m_Graph_RT_ACIA.StartPosition = FormStartPosition.CenterParent;

                m_Graph_RT_ACIA.Show();

                PreProcessMxZ(m_iCur_CH_NO);
            }
            else
            {
                if (m_Graph_RT_ACIA != null)
                {
                    m_Graph_RT_ACIA.WindowState = FormWindowState.Normal;
                    m_Graph_RT_ACIA.Activate();
                }
                //+ Revision by YMJ - 250630 : MBT 혹은 MxZ 측정 중 일 때만 그래프 나타나도록 수정
                /*else
                {
                    m_bGraph_RT_ACIA = true;

                    m_Graph_RT_ACIA = new frmGraph_RT_ACIA(this, m_iCur_CH_NO);
                    m_Graph_RT_ACIA.StartPosition = FormStartPosition.CenterParent;

                    m_Graph_RT_ACIA.Show();

                    PreProcessMxZ(m_iCur_CH_NO);
                }*/
                //-
            }
        }
        private void PreProcessMxZ(int c_ch)
        {
            try
            {
                int iret = isACIAStep(c_ch);
                if (iret == 2)
                {
                    //+ Revisioin by YMJ - 250213 : MxZ 변경
                    // MCZ
                    if (m_ucMcz_List[c_ch].LASTIDX > 0)
                    {
                        for (int i = 0; i < m_ucMcz_List[c_ch].LASTIDX; i++)
                        {
                            m_Graph_RT_ACIA.Add_Value_Nyquist(m_ucMcz_List[c_ch].m_zDataListItems[i].ZReal * 1000, m_ucMcz_List[c_ch].m_zDataListItems[i].ZImagenary * 1000);
                            m_Graph_RT_ACIA.Add_Value_Bode(m_ucMcz_List[c_ch].m_zDataListItems[i].Frequency, m_ucMcz_List[c_ch].m_zDataListItems[i].ZMagnitude * 1000, m_ucMcz_List[c_ch].m_zDataListItems[i].ZPhase);

                            WriteSystemLog(c_ch, ">> Add ACIR record [MxZ] - RE:" +
                                                  (m_ucMcz_List[c_ch].m_zDataListItems[i].ZReal * 1000).ToString("F5") + ", " +
                                                  (m_ucMcz_List[c_ch].m_zDataListItems[i].ZImagenary * 1000).ToString("F5") + "]", true);
                        }
                    }
                    //-
                }
                else if (iret == 1)
                {
                    // MBT
                    if (m_ucMbT_List[c_ch].LastItemIndex > 0)
                    {
                        for (int i = 0; i < m_ucMbT_List[c_ch].LastItemIndex; i++)
                        {
                            m_Graph_RT_ACIA.Add_Value_Nyquist(m_ucMbT_List[c_ch].meis_item[i].zdata.real * 1000, m_ucMbT_List[c_ch].meis_item[i].zdata.img * 1000);
                            m_Graph_RT_ACIA.Add_Value_Bode(m_ucMbT_List[c_ch].meis_item[i].info.freq, m_ucMbT_List[c_ch].meis_item[i].zdata.mag * 1000, m_ucMbT_List[c_ch].meis_item[i].zdata.phase);

                            WriteSystemLog(c_ch, ">> Add ACIR record [MBT] - RE:" +
                                                  (m_ucMbT_List[c_ch].meis_item[i].zdata.real * 1000).ToString("F5") + ", " +
                                                  (m_ucMbT_List[c_ch].meis_item[i].zdata.img * 1000).ToString("F5") + "]", true);
                        }
                    }
                }

            }
            catch { }
        }
        #endregion

        // -------------
        //
        // -------------
        //private void ClearAlarmWindowVisibility()
        //{
        //    isAlarmWindowPopup = false;
        //}


        public struct struClearAlarm {
            public int ch;
            public Alarm_Treat_Type actionType;

            void Reset()
            {
                ch = 0;
                actionType = Alarm_Treat_Type.Work_None;
            }
        }
        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        public void DispSafetyWindow()
        {
            bool AlarmAdjust = false;
            if (m_AlarmPopupList.Count() > 0)
            {
                //WriteSystemLog("// Alarm Window");

                string msg = "";

                List <struClearAlarm> alarm_list = new List<struClearAlarm>();                
                for (int i = 0; i < m_AlarmPopupList.Count(); i++)
                {
                    if (m_AlarmPopupList[i].Alarm_Treat != Alarm_Treat_Type.Work_None)
                    {
                        struClearAlarm alarm = new struClearAlarm();
                        alarm.ch = m_AlarmPopupList[i].CH_NO;
                        alarm.actionType = m_AlarmPopupList[i].Alarm_Treat;
                        alarm_list.Add(alarm);

                        WriteSystemLog((alarm.ch - 1), "// Event :: Alarm Clear // Action : " + m_AlarmPopupList[i].Alarm_Treat.ToString(), true);

                        // -------------------------------------------
                        // Alarm Clear 내용을 동일 Ch 항목에 모두 적용
                        // -------------------------------------------
                        for (int m = 0; m < m_AlarmPopupList.Count(); m++)
                        {
                            if (alarm.ch == m_AlarmPopupList[m].CH_NO)
                            {
                                Alarm_Info alinfo = new Alarm_Info();
                                alinfo = m_AlarmPopupList[m];
                                alinfo.CH_NO = -1;
                                alinfo.Alarm_Treat = Alarm_Treat_Type.Work_None;
                                m_AlarmPopupList[m] = alinfo;

                                msg = msg + " <" + alinfo.CH_NO.ToString() + "," + alinfo.Alarm_Code.ToString() + "," + alinfo.Alarm_Desc + ">";
                            }
                        }
                    }
                }
                if (alarm_list.Count() > 0)
                {
                    WriteSystemLog(">> CheckRemoveAlarmList : " + msg);

                    for (int i = m_AlarmPopupList.Count() - 1; i >= 0;  i--)
                    {
                        if (m_AlarmPopupList[i].CH_NO < 0)
                        {
                            m_AlarmPopupList.RemoveAt(i);
                        }
                    }

                    for (int i = 0; i < alarm_list.Count(); i++)
                    {
                        if (alarm_list[i].actionType == Alarm_Treat_Type.Work_Resume)
                        {                            
                            ResumeCurrentStep(alarm_list[i].ch-1);
                        }
                        else if (alarm_list[i].actionType == Alarm_Treat_Type.Work_Stop)
                        {
                            EndCurrentStep(alarm_list[i].ch - 1, eNUM_CutOFF_Type.USER, true);  // 종료전에 마지막 레코드 삽입, 231115 BGH, 231116
                            EndTest2ndStep(alarm_list[i].ch-1);
                        }
                        else if (alarm_list[i].actionType == Alarm_Treat_Type.Work_NextStep)
                        {
                            EndCurrentStep(alarm_list[i].ch - 1, eNUM_CutOFF_Type.USER);  // NONE에서 USER로 변경, 231115 BGH
                        }
                    }

                    AlarmAdjust = true;
                }


                bool FormFound = false;
                foreach (Form frm in Application.OpenForms)
                {
                    if (frm.Name == "frmAlarm_Msg")
                    {
                        if (AlarmAdjust)
                        {
                            frm.Close();
                            FormFound = false;
                        }
                        else
                        {
                            FormFound = true;
                            WriteSystemLog(">> Alarm Windows [Alarm Count=" + m_AlarmPopupList.Count() + "]");

                            // --
                            // 먼저 클리어 
                            // --
                            //((frmAlarm_Msg)frm).ClearAlarmList();

                            for (int i = 0; i < m_AlarmPopupList.Count(); i++)
                            {
                                Alarm_Info n_info = m_AlarmPopupList[i]; //new Alarm_Info();
                                                                         //n_info = m_AlarmPopupList[i];

                                if (n_info.Alarm_NewInserted)
                                {
                                    ((frmAlarm_Msg)frm).Add_AlarmList(n_info);
                                    n_info.Alarm_NewInserted = false;
                                    m_AlarmPopupList[i] = n_info;
                                    Thread.Sleep(0);
                                }
                            }
                            //frm.TopMost = true;
                            frm.Show();
                            //frm.TopMost = false;
                            //frm.WindowState = FormWindowState.Normal;
                        }
                        break;
                    }
                }

                if (!FormFound && m_AlarmPopupList.Count() > 0)
                {
                    frmAlarm_Msg n_frmAlarm_Msg = new frmAlarm_Msg(this);                    
                    //n_frmAlarm_Msg.OnCloseAlarmPopup += ClearAlarmWindowVisibility;

                    System.Threading.Thread.Sleep(100);
                    System.Threading.Thread.Sleep(100);
                    n_frmAlarm_Msg.Show();
                    //isAlarmWindowPopup = true;

                    WriteSystemLog(">> Alarm Windows [Alarm Count=" + m_AlarmPopupList.Count() + "]");

                    for (int i = 0; i < m_AlarmPopupList.Count(); i++)
                    {
                        Alarm_Info n_info = m_AlarmPopupList[i]; //new Alarm_Info();
                        //n_info = m_AlarmPopupList[i];
                        n_frmAlarm_Msg.Add_AlarmList(n_info);
                        
                        if (n_info.Alarm_NewInserted)
                        {
                            n_info.Alarm_NewInserted = false;
                            m_AlarmPopupList[i] = n_info;
                            Thread.Sleep(0);
                        }
                    }
                }
            }
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        private bool AddAlarmCount(int ch, int index)
        {
            bool ret = false;
            m_AlarmRetryCount[ch, index]++;
            if (m_AlarmRetryCount[ch, index] > 2)
            {
                ret = true;
                m_AlarmRetryCount[ch, index] = 0;
            }
            return ret;
        }
        private void ResetAlarmCount(int ch, int index)
        {
            m_AlarmRetryCount[ch, index] = 0;
        }

        // --------------------------------------------
        //
        // --------------------------------------------
        public void CheckVoltSafetyCondition(int ch)
        {
            bool IsSafetyViolated = false;
            TypeOfSafetyViolation res = TypeOfSafetyViolation.NONE;
            //int idx = 0;
            string merr = "";
            string msub = "";
            double value = 0; //, valueL = 0, valueU = 0;
            bool ETCError = false;

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            if (m_ucCycler_ABT_List[boardid].m_ChStatusList == null)
            {
                return;
            }

            IsSafetyViolated = false;

            if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)ABT.TypeOfSafetyViolation.ETC) > 0)
            {
                ETCError = true;
            }

            // -------------------------------------------
            // Check Safety by Voltage
            // -------------------------------------------
            if (m_VsafetyOver > 0)
            {
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_V;
                else value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                
                if (value > (m_VsafetyOver - 0.0005))
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.OverVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC001]OVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }
            }
            if (m_VsafetyUnder > 0)
            {
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_V;
                else value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;

                if (value < (m_VsafetyUnder + 0.0005))
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.UnderVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC002]UVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }                
            }


            // ----------------------------------------------
            // Cycler Alarm Handling
            // ----------------------------------------------
            if (IsSafetyViolated)
            {
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet == 0)
                {
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet = 1;
                    m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.STANDBY, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                }

                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode = (int)res;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString = merr;


                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
                m_dispChStatus.ch_s_Code = merr;
                m_dispChStatus.ch_s_Exist_Alarm = true;
                m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

            }
            else if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet != 0)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet = 0;

                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode = 0;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString = "0(OK)";

                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
                m_dispChStatus.ch_s_Exist_Alarm = false;
                m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            }
            
        }


        // --------------------------------------------
        //
        // --------------------------------------------
        public void CheckSafetyCondition(int ch)
        {
            bool IsSafetyViolated = false;
            TypeOfSafetyViolation res = TypeOfSafetyViolation.NONE;
            string vconv = "";  // 231211
            string fmats = "F3";

            string merr = "";
            string msub = "";
            double value = 0, valueL = 0, valueU = 0;
            bool ETCError = false;

            if (m_ucStepInfo_List == null) { return; }
            if (m_ucStepInfo_List.Count <= ch) { return; }

            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            try
            {
                CurStInfo = m_ucStepInfo_List[ch];
                if (CurStInfo == null) { return; }
            }
            catch
            {
            }

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            if (m_ucCycler_ABT_List[boardid].m_ChStatusList == null)
            {
                return;
            }

            IsSafetyViolated = false;

            if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)ABT.TypeOfSafetyViolation.ETC) > 0)
            {
                ETCError = true;
            }

            // -----------------------------------
            // Step Safety 때문에
            // -----------------------------------
            int CurrentNo = CurStInfo.m_currentStepNo;
            if (CurrentNo < 0)
            {
                return;
            }
            if (CurrentNo >= CurStInfo.m_steplist.Count)
            {
                return;
            }
            cls_stepInfo.struStep mStep = CurStInfo.m_steplist[CurrentNo];


            // 231112
            if (Volt_Number_Digit == "F4") fmats = "F4";
            else fmats = "F3";

            // -------------------------------------------
            // Check Safety by Voltage
            // -------------------------------------------
            if (CurStInfo.m_safety.safety_volt_enable)
            {
                valueL = CurStInfo.m_safety.safety_volt_l;
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_V;
                else  value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                valueU = CurStInfo.m_safety.safety_volt_h;

                // ------------------------------------
                // 231112 BGH
                // ------------------------------------
                vconv = value.ToString(fmats); double.TryParse(vconv, out value);
                vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                vconv = valueU.ToString(fmats); double.TryParse(vconv, out valueU);

                // if (value < (valueL + 0.0005))
                if (value <= (valueL))
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.UnderVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC002]UVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }
                // else if (value > (valueU - 0.0005))
                else if (value >= valueU)
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.OverVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC001]OVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }
            }

            // -----------------------------------------
            // Step
            // -----------------------------------------
            if (mStep.Step_Safety_V_Use)
            {
                valueL = mStep.Step_Safety_V_Under;
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_V;
                else value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                valueU = mStep.Step_Safety_V_Over;

                // ------------------------------------
                // 231112 BGH
                // ------------------------------------
                vconv = value.ToString(fmats); double.TryParse(vconv, out value);
                vconv = valueL.ToString(fmats); double.TryParse(vconv, out valueL);
                vconv = valueU.ToString(fmats); double.TryParse(vconv, out valueU);

                // if (value < (valueL + 0.0005))  // if (value < valueL)
                if (value <= valueL)
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.UnderVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC003]Step-UVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }
                //else if (value > (valueU - 0.0005))
                else if (value >= valueU)
                {
                    IsSafetyViolated = true;
                    res = TypeOfSafetyViolation.OverVolt;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC004]Step-OVP";
                    //-
                    msub = " [" + value.ToString("F3") + "V]";

                    AddAlarm(ch, res, merr + msub);
                }

            }


            // -------------------------------------------
            // Check Safety by Current
            // ------------------------------------------------------------------
            // 스텝 시작하여, Rising 전에는 Safety 검사하면 안됨
            // 예) 방전 후 REST 실행시, 전류가 0 되기전에 검사하면 OCP 알람 발생함.
            // ------------------------------------------------------------------
            // 231023, BGH
            // ------------------------------------------------------------------
            // if (CurStInfo.m_safety.safety_curr_enable && CurStInfo.isRised)
            // 240102, BGH
            if (CurStInfo.m_safety.safety_curr_enable && 
               (mStep.steptype == cls_stepInfo.enumStepType.Charge || mStep.steptype == cls_stepInfo.enumStepType.Discharge || mStep.steptype == cls_stepInfo.enumStepType.Pattern) && 
                CurStInfo.isRised)
            {
                valueL = (CurStInfo.m_safety.safety_curr_h) * (-1);
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_I;
                else value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                valueU = CurStInfo.m_safety.safety_curr_h;

                double dblimit = 0.0005;

                // -------------------------------------------------------------
                // CV일경우, 최초에 MAX 전류로 충방전 시작하기 때문에 Offset 조절
                // 231025, BGH
                // -------------------------------------------------------------
                if (mStep.stepmode == cls_stepInfo.enumStepMode.CV)
                {
                    valueL *= 1.02;  // 180A --> 183.6로 올려줌.
                    valueU *= 1.02;  // 180A --> 183.6로 올려줌.
                }

                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode == cls_stepInfo.enumStepMode.CV)
                {
                    // CV모드에서는 처음에 Limit까지 전류를 가져다 쓰기 때문에 Limit값을 좀 더 크게 줘야 한다.
                    // BGH, 230920
                    // 수정, 231019
                    dblimit = valueL * 0.001; // - 0.1;
                }
                
                if (Math.Abs(value) < 1000)
                {
                    if (value <= (valueL + dblimit))
                    {
                        res = TypeOfSafetyViolation.UnderCurr;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC005]UCP";
                        //-
                        msub = " [" + value.ToString("F3") + "A]";
                        IsSafetyViolated = true;

                        //if (AddAlarmCount(ch, Idx_UnderCurr)) AddAlarm(ch, res, merr + msub);
                        AddAlarm(ch, res, merr + msub);

                    }
                    else
                    {
                        ResetAlarmCount(ch, Idx_UnderCurr);
                    }

                    if (value >= (valueU - dblimit))
                    {
                        res = TypeOfSafetyViolation.OverCurr;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC006]OCP";
                        //-
                        msub = " [" + value.ToString("F3") + "A]";  // "V]";
                        IsSafetyViolated = true;

                        //if (AddAlarmCount(ch, Idx_OverCurr)) AddAlarm(ch, res, merr + msub);
                        AddAlarm(ch, res, merr + msub);
                    }
                    else
                    {
                        ResetAlarmCount(ch, Idx_OverCurr);
                    }
                }
            }

            // -----------------------------------------
            // Step
            // ------------------------------------------------------------------
            // 스텝 시작하여, Rising 전에는 Safety 검사하면 안됨
            // 예) 방전 후 REST 실행시, 전류가 0 되기전에 검사하면 OCP 알람 발생함.
            // ------------------------------------------------------------------
            // 231023, BGH
            // ------------------------------------------------------------------
            // if (mStep.Step_Safety_I_Use && CurStInfo.isRised)
            // 240102, BGH
            if (mStep.Step_Safety_I_Use && 
               (mStep.steptype == cls_stepInfo.enumStepType.Charge || mStep.steptype == cls_stepInfo.enumStepType.Discharge || mStep.steptype == cls_stepInfo.enumStepType.Pattern) && 
               CurStInfo.isRised)
            {
                valueL = mStep.Step_Safety_I_Under;
                if (ETCError) value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Alarm_I;
                else value = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                valueU = mStep.Step_Safety_I_Over;

                double dblimitL = 0.0005;
                double dblimitU = 0.0005;

                // -------------------------------------------------------------
                // CV일경우, 최초에 MAX 전류로 충방전 시작하기 때문에 Offset 조절
                // 231025, BGH
                // -------------------------------------------------------------
                if (mStep.stepmode == cls_stepInfo.enumStepMode.CV)
                {
                    valueL *= 1.011;  // 180A --> 181.98로 올려줌.
                    valueU *= 1.011;  // 180A --> 181.98로 올려줌.
                }

                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode == cls_stepInfo.enumStepMode.CV)
                {
                    // CV모드에서는 처음에 Limit까지 전류를 가져다 쓰기 때문에 Limit값을 좀 더 크게 줘야 한다.
                    // BGH, 230920
                    // 수정, 231019
                    dblimitL = valueL * 0.001; // - 0.1;
                    dblimitU = valueU * (-0.001); // - 0.1;
                }

                if (Math.Abs(value) < 1000)
                {
                    //+ Revision by YMJ -240812 : UCP 판단 시 방전 시에도 정상 판단을 위해 절대값 적용
                    if (Math.Abs(value) <= (valueL + dblimitL))
                    //-
                    {
                        res = TypeOfSafetyViolation.UnderCurr;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC007]Step-UCP";
                        //-
                        msub = " [" + value.ToString("F3") + "A]";
                        IsSafetyViolated = true;

                        // if (AddAlarmCount(ch, Idx_UnderCurr)) AddAlarm(ch, res, merr + msub);
                        AddAlarm(ch, res, merr + msub);
                    }
                    else
                    {
                        ResetAlarmCount(ch, Idx_UnderCurr);
                    }

                    //+ Revision by YMJ -240812 : OCP 판단 시 방전 시에도 정상 판단을 위해 절대값 적용
                    if (Math.Abs(value) >= (valueU - dblimitU))
                    //-
                    {
                        res = TypeOfSafetyViolation.OverCurr;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC008]Step-OCP";
                        //-
                        msub = " [" + value.ToString("F3") + "A]";  // "V]";
                        IsSafetyViolated = true;

                        // if (AddAlarmCount(ch, Idx_OverCurr)) AddAlarm(ch, res, merr + msub);
                        AddAlarm(ch, res, merr + msub);
                    }
                    else
                    {
                        ResetAlarmCount(ch, Idx_OverCurr);
                    }
                }
            }

            // -------------------------------------------
            // Check Safety by Ah
            // -------------------------------------------
            if (CurStInfo.m_safety.safety_capa_enable)
            {
                value = Math.Abs(m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q); //.Current_Q);
                valueU = Math.Abs(CurStInfo.m_safety.safety_capa_h);

                if (Math.Abs(value) < 1000)
                {                    
                    if (value >= (valueU - 0.0005))
                    {
                        res = TypeOfSafetyViolation.OverQ;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC009]OQP";
                        //-
                        msub = " [" + value.ToString("F3") + "Ah]";
                        IsSafetyViolated = true;

                        AddAlarm(ch, res, merr + msub);
                    }
                }
            }

            // -----------------------------------------
            // Step
            // -----------------------------------------
            if (mStep.Step_Safety_Q_Use)
            {
                //+ Revision by YMJ -240812 : 용량 스텝 컷오프 판단 시 E -> Q로 판단하도록 변경
                value = Math.Abs(m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q); //.Current_Q);
                //-
                valueU = Math.Abs(mStep.Step_Safety_Q_Over);

                if (Math.Abs(value) < 1000)
                {
                    if (value >= (valueU - 0.0005))
                    {
                        res = TypeOfSafetyViolation.OverQ;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        merr = "[CYC010]Step-OQP";
                        //-
                        msub = " [" + value.ToString("F3") + "Ah]";
                        IsSafetyViolated = true;

                        AddAlarm(ch, res, merr + msub);
                    }
                }
            }

            //+ Revision by YMJ - 251013 : 충방전기에서 올라오는 알람의 경우 따로 처리
            // -------------------------------------------
            // IsSafetyViolated 검사하기 때문에 반드시 이곳에 있어야함
            // 충방전기에서 DEV말고는 전압, 전류 관련 Safety만 있기때문에
            // 전압, 전류 검사한 다음 바로 여기!!!!
            // -------------------------------------------
            /*if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)TypeOfSafetyViolation.ETC) != 0)
            {
                if (!IsSafetyViolated)
                {
                    res = TypeOfSafetyViolation.ETC;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC011]Cycler Error";
                    //-
                    msub = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmMessage;

                    AddAlarm(ch, res, merr + msub);
                }

                IsSafetyViolated = true;                
            }*/
            //

            // -------------------------------------------
            // Check Safety by Temperature
            // -------------------------------------------
            //+ Revision by LBG - 230410 : Chamber & Chiller 안전 조건 추가
            // 수정 요건 필요~!!!
            if (CurStInfo.m_safety.safety_Chamber_enable && m_ucChamber.EnableFlag)
            {
                value = m_ucChamber.PV; // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;
                if (value > -40 && value < 100)  // if (value > -50 && value < 100)
                {
                    valueL = CurStInfo.m_safety.safety_Chamber_l;
                    valueU = CurStInfo.m_safety.safety_Chamber_h;

                    if (value <= valueL)
                    {
                        res = TypeOfSafetyViolation.UnderTemp;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        //+ Revision by YMJ - 241125 : Proteciton 주체 장비 설명 추가
                        merr = "[CMB001]Chamber_UTP";
                        //-
                        //-
                        msub = " [" + value.ToString("F1") + "℃]";

                        IsSafetyViolated = true;
                        AddAlarm(ch, res, merr + msub);
                    }

                    if (value >= valueU)
                    {
                        res = TypeOfSafetyViolation.OverTemp;
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        //+ Revision by YMJ - 241125 : Proteciton 주체 장비 설명 추가
                        merr = "[CMB002]Chamber_OTP";
                        //-
                        //-
                        msub = " [" + value.ToString("F1") + "℃]";

                        IsSafetyViolated = true;
                        AddAlarm(ch, res, merr + msub);
                    }

                }
            }

            //+ Revision by LBG - 250623 : Chiller Multi Device로 변경
            ////+ Revision by YMJ - 241125 : Chiller 안전 조건 추가
            //if (CurStInfo.m_safety.safety_Chiller_enable && m_ucChiller.EnableFlag)
            //{
            //    value = m_ucChiller.PV; // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;
            //    if (value > -40 && value < 100)  // if (value > -50 && value < 100)
            //    {
            //        valueL = CurStInfo.m_safety.safety_Chiller_l;
            //        valueU = CurStInfo.m_safety.safety_Chiller_h;

            //        if (value <= valueL)
            //        {
            //            res = TypeOfSafetyViolation.UnderTemp;
            //            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
            //            merr = "[CHL004]Chiller_UTP";
            //            //-
            //            msub = " [" + value.ToString("F1") + "℃]";

            //            IsSafetyViolated = true;
            //            AddAlarm(ch, res, merr + msub);
            //        }

            //        if (value >= valueU)
            //        {
            //            res = TypeOfSafetyViolation.OverTemp;
            //            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
            //            merr = "[CHL005]Chiller_OTP";
            //            //-
            //            msub = " [" + value.ToString("F1") + "℃]";

            //            IsSafetyViolated = true;
            //            AddAlarm(ch, res, merr + msub);
            //        }

            //    }
            //}
            ////-
            
            if (CurStInfo.m_safety.safety_Chiller_enable && m_clsSys_Set.m_bUse_Chiller)
            {
                for (int i = 0; i < m_bChiller_Cnt; i++)
                {
                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                    value = m_ucChiller[i].PV; // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T;
                    //-

                    if (value > -40 && value < 100)  // if (value > -50 && value < 100)
                    {
                        valueL = CurStInfo.m_safety.safety_Chiller_l;
                        valueU = CurStInfo.m_safety.safety_Chiller_h;

                        if (value <= valueL)
                        {
                            res = TypeOfSafetyViolation.UnderTemp;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[CHL004]Chiller_UTP";
                            //-
                            msub = " [" + value.ToString("F1") + "℃]";

                            IsSafetyViolated = true;
                            AddAlarm(ch, res, merr + msub);
                        }

                        if (value >= valueU)
                        {
                            res = TypeOfSafetyViolation.OverTemp;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[CHL005]Chiller_OTP";
                            //-
                            msub = " [" + value.ToString("F1") + "℃]";

                            IsSafetyViolated = true;
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }
            }
            //-

            // -------------------------------------------
            // Check Safety by DAU/BMS/AUX Volt
            // -------------------------------------------
            if (CurStInfo.m_safety.safety_temp_enable)
            {
                bool boolAuxVSafety = false;

                if (m_ucDAU_List != null)
                {
                    if (m_DAU_Temp != null && m_NumOfDAU > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_dau[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_temp_l;
                            value = m_DAU_Temp[ch][i];
                            valueU = CurStInfo.m_safety.safety_temp_h;
                            if (value > -40 && value < 100)
                            {
                                if (value <= (valueL + 0.0005))
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[DAU001]DAU_UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= (valueU - 0.0005))
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[DAU002]DAU_OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                            }
                            if (isviolt) break;
                        }
                        
                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }

                if (m_ucBMS_List != null && (!boolAuxVSafety))
                {
                    if (m_BMS_Temp != null && m_NumOfBMS > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_bms[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_temp_l;
                            value = m_BMS_Temp[ch, i];
                            valueU = CurStInfo.m_safety.safety_temp_h;

                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN002]BMS_UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN003]BMS_OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                            }
                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                if (m_ucAUX7019_List != null && (!boolAuxVSafety))
                {
                    if (m_AUX_Temp != null && m_NumOfAUX > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_aux[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_temp_l;
                            value = m_AUX_Temp[ch, i];
                            valueU = CurStInfo.m_safety.safety_temp_h;
                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[AUX002]AUX_UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[AUX003]AUX_OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }

                                if (isviolt) break;
                            }
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                // +
                // BGH, MBI 지원
                //
                if (m_ucMBI_List != null && (!boolAuxVSafety))
                {
                    if (m_MBI_Temp != null && m_NumOfMBI > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_mbi[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_temp_l;
                            value = m_MBI_Temp[ch, i];
                            valueU = CurStInfo.m_safety.safety_temp_h;
                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[MBI002]MBI_UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[MBI003]MBI_OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }

                                if (isviolt) break;
                            }
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

            }

            // ------------------------------------
            // STep
            // ------------------------------------
            if (mStep.Step_Safety_T_Use)
            {
                bool boolAuxVSafety = false;

                if (m_ucAUX7019_List != null)
                {
                    if (m_AUX_Temp != null && m_NumOfAUX > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_aux[ch]; i++)
                        {
                            valueL = mStep.Step_Safety_T_Under;
                            value = m_AUX_Temp[ch, i];
                            valueU = mStep.Step_Safety_T_Over;

                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[AUX004]AUX Step-UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[AUX005]AUX Step-OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                            }
                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                if (m_ucBMS_List != null && (!boolAuxVSafety))
                {
                    if (m_BMS_Temp != null && m_NumOfBMS > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_bms[ch]; i++)
                        {
                            valueL = mStep.Step_Safety_T_Under;
                            value = m_BMS_Temp[ch, i];
                            valueU = mStep.Step_Safety_T_Over;

                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN004]BMS Step-UTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN005]BMS Step-OTP";
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                            }
                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                if (m_ucDAU_List != null && (!boolAuxVSafety))
                {
                    if (m_DAU_Temp != null && m_NumOfDAU > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_dau[ch]; i++)
                        {
                            valueL = mStep.Step_Safety_T_Under;
                            value = m_DAU_Temp[ch][i];
                            valueU = mStep.Step_Safety_T_Over;
                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    //+ Revision by YMJ - 241125 : Step 안전조건에 맞는 Message로 변경 
                                    merr = "[DAU003]DAU Step-UTP";
                                    //-
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    //+ Revision by YMJ - 241125 : Step 안전조건에 맞는 Message로 변경 
                                    merr = "[DAU004]DAU Step-OTP";
                                    //-
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                            }
                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }

                // +
                // BGH, MBI 지원
                //
                if (m_ucMBI_List != null && (!boolAuxVSafety))
                {
                    if (m_MBI_Temp != null && m_NumOfMBI > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_tempcount_mbi[ch]; i++)
                        {
                            valueL = mStep.Step_Safety_T_Under;
                            value = m_MBI_Temp[ch, i];
                            valueU = mStep.Step_Safety_T_Over;
                            if (value > -40 && value < 100)
                            {
                                if (value <= valueL)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    //+ Revision by YMJ - 241125 : Step 안전조건에 맞는 Message로 변경 
                                    merr = "[MBI004]MBI Step-UTP";
                                    //-
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }
                                else if (value >= valueU)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverTemp;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    //+ Revision by YMJ - 241125 : Step 안전조건에 맞는 Message로 변경 
                                    merr = "[MBI005]MBI Step-OTP";
                                    //-
                                    //-
                                    msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "℃]";
                                    isviolt = true;
                                }

                                if (isviolt) break;
                            }
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }
            }


            // -------------------------------------------
            // Check Safety by DAU/BMS/AUX Volt
            // -------------------------------------------
            if (CurStInfo.m_safety.safety_AUXvolt_enable)
            {
                bool boolAuxVSafety = false;
                if (m_ucDAU_List != null)
                {
                    //+ Revision by LBG - 230812 : 해당 채널의 DAU 전압값만 체크로 변경                        
                    if (m_DAU_Volt != null && m_NumOfDAU > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_DAU_Volt[ch].Count; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_AUXvolt_l;
                            value = m_DAU_Volt[ch][i];
                            valueU = CurStInfo.m_safety.safety_AUXvolt_h;
                            if (value <= (valueL + 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.UnderVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[DAU005]DAU_UVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                            else if (value >= (valueU - 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.OverVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[DAU006]DAU_OVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }

                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }

                if (m_ucBMS_List != null && (!boolAuxVSafety))
                {                                        
                    if (m_BMS_Volt != null && m_NumOfBMS > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_voltcount_bms[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_AUXvolt_l;
                            value = m_BMS_Volt[ch, i];
                            valueU = CurStInfo.m_safety.safety_AUXvolt_h;
                            if (value <= (valueL + 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.UnderVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[CAN006]BMS_UVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                            else if (value >= (valueU - 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.OverVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[CAN007]BMS_OVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }

                if (m_ucAUX7019_List != null && (!boolAuxVSafety))
                {                    
                    if (m_AUX_Volt != null && m_NumOfAUX > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_voltcount_aux[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_AUXvolt_l;
                            value = m_AUX_Volt[ch, i];
                            valueU = CurStInfo.m_safety.safety_AUXvolt_h;
                            if (value <= (valueL + 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.UnderVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[AUX006]AUX_UVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                            else if (value >= (valueU - 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.OverVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[AUX007]AUX_OVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }

                // +
                // BGH, MBI 지원
                //
                if (m_ucMBI_List != null)
                {
                    if (m_MBI_Volt != null && m_NumOfMBI > ch)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_voltcount_mbi[ch]; i++)
                        {
                            valueL = CurStInfo.m_safety.safety_AUXvolt_l;
                            value = m_MBI_Volt[ch, i];
                            valueU = CurStInfo.m_safety.safety_AUXvolt_h;
                            if (value <= (valueL + 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.UnderVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[MBI006]MBI_UVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }
                            else if (value >= (valueU - 0.0005))
                            {
                                IsSafetyViolated = true;
                                res |= TypeOfSafetyViolation.OverVolt;
                                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                merr = "[MBI007]MBI_OVP";
                                //-
                                msub = " [idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "V]";
                                isviolt = true;
                            }

                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                            boolAuxVSafety = true;
                        }
                    }
                }
            }

            // -------------------------------------------
            // Check AUX Volt Difference
            // -------------------------------------------
            if (CurStInfo.m_safety.safety_AUXvolt_Diff_enable)
            {
                if (m_ucAUX7019_List != null)
                {
                    if (m_AUX_Volt != null && m_NumOfAUX > ch)
                    {
                        bool isviolt = false;

                        value = AUX_V_diff[ch];
                        valueU = CurStInfo.m_safety.safety_AUXvolt_Diff_value;
                        if (value >= (valueU - 0.0005))
                        {
                            IsSafetyViolated = true;
                            res |= TypeOfSafetyViolation.DiffVolt;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[AUX008]AUX_VDIFF";
                            //-
                            msub = " [" + value.ToString("F3") + "V]";
                            isviolt = true;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                // +
                // 230911, BGH
                if (m_ucDAU_List != null)
                {
                    if (m_DAU_Volt != null && m_NumOfDAU > ch)
                    {
                        bool isviolt = false;

                        //+Revision by YMJ - 231124 : DAU 파라미터 변경
                        value = m_DAU_V_Diff[ch];
                        //-
                        valueU = CurStInfo.m_safety.safety_AUXvolt_Diff_value;
                        if (value >= (valueU - 0.0005))
                        {
                            IsSafetyViolated = true;
                            res |= TypeOfSafetyViolation.DiffVolt;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[DAU007]DAU_VDIFF";
                            //-
                            msub = " [" + value.ToString("F3") + "V]";
                            isviolt = true;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                // +
                // 230911, BGH
                if (m_ucBMS_List != null)
                {
                    if (m_BMS_Volt != null && m_NumOfBMS > ch)
                    {
                        bool isviolt = false;

                        value = BMS_V_diff[ch];
                        valueU = CurStInfo.m_safety.safety_AUXvolt_Diff_value;
                        if (value >= (valueU - 0.0005))
                        {
                            IsSafetyViolated = true;
                            res |= TypeOfSafetyViolation.DiffVolt;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[CAN008]BMS_VDIFF";
                            //-
                            msub = " [" + value.ToString("F3") + "V]";
                            isviolt = true;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }

                // +
                // 230911, BGH
                if (m_ucMBI_List != null)
                {
                    if (m_MBI_Volt != null && m_NumOfMBI > ch)
                    {
                        bool isviolt = false;

                        value = MBI_V_diff[ch];
                        valueU = CurStInfo.m_safety.safety_AUXvolt_Diff_value;
                        if (value >= (valueU - 0.0005))
                        {
                            IsSafetyViolated = true;
                            res |= TypeOfSafetyViolation.DiffVolt;
                            //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                            merr = "[MBI008]MBI_VDIFF";
                            //-
                            msub = " [" + value.ToString("F3") + "V]";
                            isviolt = true;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }
            }


            // -------------------------------------------
            // CAN
            // -------------------------------------------
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_ucCAN_List != null)
            {
                if (m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
                {
                    if (m_ucCAN_List[ch].isConnected && m_ucCAN_List[ch].CAN_List != null)
                    {
                        bool isviolt = false;
                        for (int i = 0; i < m_ucCAN_List[ch].CAN_List.Count; i++)
                        {
                            //+ Revision by YMJ - 250725 : CAN 안전조건 적용 방식 변경, 단방향 적용도 가능, 모든 스텝에서 양면 검사
                            if (m_ucCAN_List[ch].CAN_List[i].Addr > 0 && m_ucCAN_List[ch].CAN_List[i].CutOffCheck &&
                                //+ Revision by YMJ - 250716 : CAN 기본 Default값 변경
                                m_ucCAN_List[ch].CAN_List[i].Value != -999999)
                                //-
                            {
                                valueL = m_ucCAN_List[ch].CAN_List[i].Safety_L;
                                value = m_ucCAN_List[ch].CAN_List[i].Value;
                                valueU = m_ucCAN_List[ch].CAN_List[i].Safety_H;
                                
                                if (value <= (valueL + 0.0005) && valueL != -999999)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.UnderVolt;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN009]CAN_U_Limit";
                                    //-
                                    msub = " [Value:idx=" + (i + 1).ToString() + ", " + value.ToString("F3") + "]";
                                    isviolt = true;
                                }
                                if (value >= (valueU - 0.0005) && valueU != -999999)
                                {
                                    IsSafetyViolated = true;
                                    res |= TypeOfSafetyViolation.OverVolt;
                                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                                    merr = "[CAN010]CAN_O_Limit";
                                    //-
                                    msub = " [Value:index=" + (i + 1).ToString() + ", " + value.ToString("F3") + "]";
                                    isviolt = true;
                                }
                            }
                            //-

                            if (isviolt) break;
                        }

                        if (isviolt)
                        {
                            AddAlarm(ch, res, merr + msub);
                        }
                    }
                }
            }


            // -------------------------------------------
            // CAN
            // -------------------------------------------
            if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)TypeOfSafetyViolation.EPO_COMMErr) != 0)
            {
                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                merr = "[CYC012]Cycler Communication Error";
                //-
                msub = "";

                IsSafetyViolated = true;
                res = TypeOfSafetyViolation.EPO_COMMErr;

                AddAlarm(ch, res, merr + msub);
            }

            // ---------------------------------------------
            // No Current Alarm
            // ---------------------------------------------
            if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)TypeOfSafetyViolation.NoCurrent) != 0)
            {
                if (!IsSafetyViolated)
                {
                    res = TypeOfSafetyViolation.NoCurrent;
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    merr = "[CYC013]NO Current";
                    //-
                    msub = "";

                    //if (AddAlarmCount(ch, Idx_NoCurrent)) AddAlarm(ch, res, merr + msub);
                    AddAlarm(ch, res, merr + msub);
                    IsSafetyViolated = true;
                }
            }
            else
            {
                ResetAlarmCount(ch, Idx_NoCurrent);
            }

            // ----------------------------------------------
            // Cycler Alarm Handling
            // ----------------------------------------------
            if (IsSafetyViolated)
            {
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet == 0)
                {
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet = 1;

                    // ---------------------------------------
                    // 알람 발생시는 Standby로 대기, 230918
                    // ---------------------------------------
                    //m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.CC, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                    m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.STANDBY, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                }

                //m_ucCycler_ABT_List[boardid].WriteCyclerLogWithEvent(bzch, merr);
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode = (int)res;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString = merr;


                // ---------------------
                // STep 정지/중지/대기
                // 2023 ghccc
                // ---------------------
                // SuspendCurrentStep(ch, merr);
                SafetyCurrentStep(ch, merr);

                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
                m_dispChStatus.ch_s_Code = merr;
                m_dispChStatus.ch_s_Exist_Alarm = true;
                m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
                
            }
            else if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet != 0)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmSet = 0;

                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode = 0;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].StatusCodeString = "0(OK)";

                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
                m_dispChStatus.ch_s_Exist_Alarm = false;
                m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            }

            // --------------------------------------------------------
            // + Added By BGH
            // Alarm은 발생했는데 팝업창만 닫힌 경우
            // --------------------------------------------------------
            //if (m_AlarmPopupList.Count() > 0 && (!isAlarmWindowPopup))
            //{
            //    frmAlarm_Msg n_frmAlarm_Msg = new frmAlarm_Msg(this);
            //    n_frmAlarm_Msg.OnCloseAlarmPopup += ClearAlarmWindowVisibility;

            //    for (int i = 0; i < m_AlarmPopupList.Count(); i++)
            //    {
            //        n_frmAlarm_Msg.Add_AlarmList(m_AlarmPopupList[i]);
            //    }

            //    System.Threading.Thread.Sleep(100);
            //    System.Threading.Thread.Sleep(100);
            //    n_frmAlarm_Msg.Show();
            //    isAlarmWindowPopup = true;
            //}
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        public void DevAlarmDescription(int ch)
        {
            string merr = "";
            string msub = "";
            TypeOfSafetyViolation res = TypeOfSafetyViolation.NONE;
            //int insidx = -1;
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            //+ Revision by YMJ - 251013 : 충방전기에서 알람 올라왔을 경우 처리 수정 및 정지 추가
            if ((m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmCode & (int)TypeOfSafetyViolation.ETC) != 0)
            {
                res = TypeOfSafetyViolation.ETC;
                //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                merr = "[CYC011]Cycler Error";
                //-
                msub = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].AlarmMessage;

                AddAlarm(ch, res, merr + msub);
                //WriteAlarmLog(ch, (int)res, res.ToString(), merr + msub);

                SuspendCurrentStep(ch, "Cycler Error");
            }
            //-
        }

        // ---------------------------------------------------
        // 
        // ---------------------------------------------------
        public void AddAlarm(int ch, TypeOfSafetyViolation errCode, string errMsg)
        {
            // ------------------------------------------
            // 중복성 체크
            // 240118 BGH
            // ------------------------------------------
            if (m_AlarmPopupList != null)
            {
                bool bfound = false;
                for (int i = 0; i < m_AlarmPopupList.Count; i++)
                {
                    if (m_AlarmPopupList[i].CH_NO == (ch + 1) && m_AlarmPopupList[i].Alarm_Code == errCode)
                    {
                        bfound = true;
                        break;
                    }
                }

                if (bfound) return;
            }
            // -
            // -------------------------------------------

            Alarm_Info n_Alarm_Info = new Alarm_Info();

            n_Alarm_Info.CH_NO = ch + 1;
            n_Alarm_Info.Alarm_Time = DateTime.Now;
            n_Alarm_Info.Alarm_Code = errCode;
            n_Alarm_Info.Alarm_Desc = errMsg; // GetSafetyString((int)res);
            n_Alarm_Info.Alarm_Treat = Alarm_Treat_Type.Work_None;
            n_Alarm_Info.Alarm_NewInserted = true;

            // ----------------------------------
            // Alarm List에 추가
            // ----------------------------------
            m_AlarmPopupList.Add(n_Alarm_Info);

            // ----------------------------------
            //  Alarm Log
            // ----------------------------------
            WriteAlarmLog(ch, (int)errCode, errCode.ToString(), errMsg);
            //WriteSystemLog(ch, "// Event :: Alarm Add // " + errCode.ToString() + "(" + ((int)errCode).ToString() + ") // " + errMsg, true);
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        public void RemoveAlarm(int ch)
        {
            if (m_AlarmPopupList == null) return;

            if (m_AlarmPopupList.Count() > 0)
            {
                int listcount = m_AlarmPopupList.Count() - 1;
                for (int i = listcount; i >= 0; i--)
                {
                    if (m_AlarmPopupList[i].CH_NO == (ch + 1))
                    {
                        WriteSystemLog(ch, "// Remove Alarm [" + 
                                       m_AlarmPopupList[i].Alarm_Code.ToString() + ", " +
                                       m_AlarmPopupList[i].Alarm_Desc + "]", true);
                        m_AlarmPopupList.RemoveAt(i);
                    }
                }
            }
        }

        // ---------------------------------------------------
        // 알람중에 MBT 관련 알람이 있을경우 true 리턴
        // 240122 BGH
        // ---------------------------------------------------
        public bool RemoveAlarmCheckMBT(int ch)
        {
            bool bret = false;

            if (m_AlarmPopupList == null) return false;

            if (m_AlarmPopupList.Count() > 0)
            {
                int listcount = m_AlarmPopupList.Count() - 1;
                for (int i = listcount; i >= 0; i--)
                {
                    if (m_AlarmPopupList[i].CH_NO == (ch + 1))
                    {
                        if (m_AlarmPopupList[i].Alarm_Code == TypeOfSafetyViolation.MBT_Err || m_AlarmPopupList[i].Alarm_Code == TypeOfSafetyViolation.MBT_COMMErr)
                        {
                            bret = true;                       
                        }

                        WriteSystemLog(ch, "// Remove Alarm [" +
                                       m_AlarmPopupList[i].Alarm_Code.ToString() + ", " +
                                       m_AlarmPopupList[i].Alarm_Desc + "]", true);
                        m_AlarmPopupList.RemoveAt(i);
                    }
                }
            }
            return bret;
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        public bool StartTest(int ch)
        {
            WriteSystemLog(ch, "Start Test", true);

            // --------------------------------------
            // 전압이 1V 이상 있을때만 스케쥴 실행 
            // --------------------------------------
            if (!isChannelAlived(ch))
            {
                WriteSystemLog(ch, ">> Err::Channel is not active!!", true);
                return false;
            }

            if (m_ucStepInfo_List == null)
            {
                WriteSystemLog(ch, ">> Err::Invalid step list!!", true);
                return false;
            }
            if (m_ucStepInfo_List.Count <= ch)
            {
                WriteSystemLog(ch, ">> Err:: Step Count < Ch", true);
                return false;
            }

            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            try
            {
                CurStInfo = m_ucStepInfo_List[ch];
                if (CurStInfo == null)
                {
                    WriteSystemLog(ch, ">> Err::Step info!!", true);
                    return false;
                }
            }
            catch
            {
            }

            // --------------- 아래 #2179로 이동
            // 중간에 반영해야 할 값들이 더 있어서
            //CurStInfo.ch = ch;
            //CurStInfo.m_currentStepNo = 0;
            //m_ucStepInfo_List[ch] = CurStInfo;
            // ---------------------------------

            // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " Ch=" + (ch + 1).ToString() + " Start Test 1");

            // --------------------------------------------------------
            // Cycle STart / Cycle End 처리
            // public int[,] Cycling = new int[CyclingSize, 3];  // Cycle 시작 Start index, end index, Count
            // --------------------------------------------------------
            #region CYCLE START / END 처리 >>>>>
            for (int i = 0; i < CST_CyclingSize; i++)
            {
                for (int m = 0; m < 3; m++)
                {
                    cycling[ch, i, m] = 0;
                }
            }

            // p3p
            int m_srtidx = 0;
            int m_endidx = 0;
            List<int> endplist = new List<int>();

            if (m_ucStepInfo_List[ch].m_steplist != null)
            {
                if (m_ucStepInfo_List[ch].m_steplist.Count > 0)
                {
                    for (short i = 0; i < m_ucStepInfo_List[ch].m_steplist.Count; i++)
                    {
                        // Cycle 시작 Stepno, End stepnumber, Start index, end index, Count
                        switch (m_ucStepInfo_List[ch].m_steplist[i].steptype)
                        {
                            case cls_stepInfo.enumStepType.CYCLE_START:
                                cycling[ch, m_srtidx, 0] = i;
                                endplist.Add(m_srtidx);

                                if (m_srtidx < CST_CyclingSize) m_srtidx++;
                                break;

                            case cls_stepInfo.enumStepType.CYCLE_END:
                                if (endplist.Count > 0)
                                {
                                    m_endidx = endplist[endplist.Count - 1];
                                    endplist.RemoveAt(endplist.Count - 1);

                                    cycling[ch, m_endidx, 1] = i;
                                    cycling[ch, m_endidx, 2] = (short)m_ucStepInfo_List[ch].m_steplist[i].operaCondition.mValue;  // 반복횟수
                                }
                                break;
                        }
                    }

                    // -------------------------------------------------------
                    // loop index process
                    // -------------------------------------------------------
                    // m_endidx = endplist.Count(); ghbaik
                    m_endidx = m_srtidx;
                    //m_totloop_count = new int[m_endidx];

                    // -------------------------------------------------------
                    // End 없는 경우, Start없는 경우 처리
                    // -------------------------------------------------------
                    for (int i = 0; i < CST_CyclingSize; i++)
                    {
                        if (cycling[ch, i, 0] < 0 || cycling[ch, i, 1] < 0)
                        {
                            cycling[ch, i, 2] = 1;
                        }
                    }

                    // -------------------------------------------------------
                    // 중간 공백 제거
                    // -------------------------------------------------------
                    for (int i = 0; i < (CST_CyclingSize - 1); i++)
                    {
                        if (cycling[ch, i, 0] == -1)
                        {
                            for (int m = (i + 1); m < CST_CyclingSize; m++)
                            {
                                cycling[ch, m - 1, 0] = cycling[ch, m, 0];
                                cycling[ch, m - 1, 1] = cycling[ch, m, 1];
                                cycling[ch, m - 1, 2] = cycling[ch, m, 2];
                            }
                        }
                    }
                }

                // ghbaik
                CurStInfo.m_totCycle = 1;
                CurStInfo.m_curCycle = 1;

                CurStInfo.ResetCycCount();

                //if (m_endidx > 0)
                //{
                //    CurStInfo.m_depthCycle = 0;
                //    CurStInfo.m_curCycle = new int[m_endidx];
                //    CurStInfo.m_totCycle = new int[m_endidx];

                //    for (int i = 0; i < m_endidx; i++)
                //    {
                //        CurStInfo.m_curCycle[i] = 0;
                //        CurStInfo.m_totCycle[i] = cycling[ch, i, 2];
                //    }
                //}
                //else
                //{
                //    CurStInfo.m_depthCycle = 0;  // 0 초기화, 1~n (사용할때는 1을 빼서 인덱스로 사용)
                //}

                CurStInfo.TestStartTime = DateTime.Now;
                CurStInfo.TestReStartTime = DateTime.Now;
                CurStInfo.OGTime_Total = new TimeSpan(0, 0, 0, 0, 0);
                CurStInfo.OGTime_Total_4log = new TimeSpan(0, 0, 0, 0, 0);
                CurStInfo.OGTime_Total_Final = new TimeSpan(0, 0, 0, 0, 0);
                CurStInfo.OGTime_Total_4disp = new TimeSpan(0, 0, 0, 0, 0);
            }

            // ----------------------
            // ghbaik
            // ----------------------            
            CurStInfo.ch = ch;
            CurStInfo.m_currentStepNo = 0;

            CurStInfo.isSafetyTrying = true;  // Safety 설정동안 농땡이 치기 위해

            m_ucStepInfo_List[ch] = CurStInfo;

            #endregion

            // ------------------------------
            // Work folder
            // ------------------------------
            // 
            string fldpath = Application.StartupPath + "\\Data\\" + work_names[ch];

            try
            {
                DirectoryInfo di = new DirectoryInfo(fldpath);

                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            // ------------------------------
            // open Log
            // ------------------------------            
            fldpath = fldpath + "\\" + sche_names[ch];
            try
            {
                DirectoryInfo di = new DirectoryInfo(fldpath);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            // m_Log_Opt_File[i]

            //+ Add by LBG - 23.10.10 : 시작 시간 기록을 위하여 추가
            DateTime n_CurDatetime = DateTime.Now;
            //-

            string detailedname = m_Log_Opt_File[ch]; // "_" + work_names[ch] + "_" + sche_names[ch] + "_" + DateTime.Now.ToString("yyyyMMddHHmmss");
            //+ Revision by LBG - 23.10.10 : 시작 시간 기록을 위하여 추가
            //fldpath = string.Format("{0}\\{1:yyyyMMdd_HHmmss}\\CH{2:00}", fldpath, DateTime.Now, (ch + 1));
            fldpath = string.Format("{0}\\{1:yyyyMMdd_HHmmss}\\CH{2:00}", fldpath, n_CurDatetime, (ch + 1));

            Display_Channel_Status n_Ch_Status = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            n_Ch_Status.ch_Start_DateTime = n_CurDatetime;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, n_Ch_Status);
            //-

            try
            {
                DirectoryInfo di = new DirectoryInfo(fldpath);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            // ------------------------------
            // 아래에서 여기로 이동
            // ------------------------------
            double volth = 0.0, voltl = 0.0, curh = 0.0, curl = 0.0;
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            // ------------------------------
            // open Log
            // ------------------------------
            //+ Add by LBG - 230911 : Basic Log의 용량 단위로 파일을 나누기 위해 기존 파일명 저장
            //string _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_Datalog.csv";
            string _m_lpath = string.Empty;

            if (m_clsAppSet.Logging_Set.Basic_Use)
            {
                //+ Revision by YMJ - 240513 : 분할 저장 파일 포멧 수정
                _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_Datalog00.csv";
                //-
            }
            else
            {
                _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_Datalog.csv";
            }

            logReg[ch] = new StreamWriter(_m_lpath, true, System.Text.Encoding.UTF8);

            if (m_clsAppSet.Logging_Set.Basic_Use)
            {
                if (m_dicBasicLog_Path != null)
                {
                    if (m_dicBasicLog_Path.ContainsKey(ch))
                    {
                        m_dicBasicLog_Path[ch] = _m_lpath;
                    }
                    else
                    {
                        m_dicBasicLog_Path.Add(ch, _m_lpath);
                    }
                }
                else
                {
                    m_dicBasicLog_Path = new Dictionary<int, string>();
                    m_dicBasicLog_Path.Add(ch, _m_lpath);
                }
            }
            //-

            string mtitle = "";
            if (enableCVTimelogging)
            {
                mtitle = "Module,Channel,StartTime,EndTime,Total Cycle,Current Cycle,Step No,Step Type,Step Code,Step Time,Total Time,CV Time,InitV(V),Voltage(V),Current(A),Temperature(℃),Capacity(Ah),Energy(Wh),Power(W),ChargeCapacity(Ah),DischargeCapacity(Ah),ChargeEnergy(Wh),DischargeEnergy(Wh)";
            }
            else
            {
                mtitle = "Module,Channel,StartTime,EndTime,Total Cycle,Current Cycle,Step No,Step Type,Step Code,Step Time,Total Time,InitV(V),Voltage(V),Current(A),Temperature(℃),Capacity(Ah),Energy(Wh),Power(W),ChargeCapacity(Ah),DischargeCapacity(Ah),ChargeEnergy(Wh),DischargeEnergy(Wh)";
            }
            //string mtitle = "Module,Channel,StartTime,EndTime,Total Cycle,Current Cycle,Step No,Step Type,STep Code,Step Time,Total Time,InitV(V),Voltage(V),Current(A),Capacity(Ah),Energy(Wh),Power(W),ChargeCapacity(Ah),DischargeCapacity(Ah),ChargeEnergy(Wh),DischargeEnergy(Wh)";
            //string mtitle = "Timestamp, Step No, Step, Voltage(V), Current(A), Capacity(Ah), Energy(Wh), Power(W), Freq(Hz), Re(mΩ), Im(mΩ), Mag(mΩ), Rs(mΩ), Rct(mΩ), Temp(℃)";

            bool useElem = false;
            if (m_clsSys_Set.m_bUse_MBT || m_clsSys_Set.m_bUse_MCZ)
            {
                try
                {
                    if (m_clsSys_Set.m_Sys_MBT.Count() > 0) useElem = true;
                }
                catch { }
                try
                {
                    if (m_clsSys_Set.m_Sys_MCZ.Count() > 0) useElem = true;
                }
                catch { }

                if (useElem)
                {
                    mtitle = mtitle + ",Freq(Hz),Re(mΩ),Im(mΩ),Mag(mΩ),Rs(mΩ),Rct(mΩ),Temp(℃)";
                }
            }

            if (m_ucChamber.EnableFlag)
            {
                //+ Revision by LBG - 250821 : Simpac, TEMI2500의 경우 습도도 로깅 추가
                //mtitle += ",Chamber SP(℃)";
                //mtitle += ",Chamber PV(℃)";
                if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC || m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                {
                    mtitle += ",Chamber T_SP(℃)";
                    mtitle += ",Chamber T_PV(℃)";
                    mtitle += ",Chamber H_SP(%)";
                    mtitle += ",Chamber H_PV(%)";
                }
                else
                {
                mtitle += ",Chamber SP(℃)";
                mtitle += ",Chamber PV(℃)";
            }            
                //-
            }

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            //if ( m_ucChiller.EnableFlag )
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
            {
                mtitle += ",Chiller #" + "SP(℃)";
                mtitle += ",Chiller #" + "PV(℃)";
                mtitle += ",Chiller #" + "SP LPM";
                mtitle += ",Chiller #" + "PV LPM";
            }            
            //-       
            //-

            if (m_AUXEnable)
            {
                // if (m_AUX_Volt.GetLength(0) >= ch)
                if (m_ucAUX7019_List.Count > ch)
                {
                    if (m_ucBalancer_List != null)
                    {
                        if (m_ucBalancer_List.Count > ch)
                        {
                            if (m_ucBalancer_List[ch].ControlEnabled)
                            {
                                mtitle += ",Balancing";
                            }
                        }
                    }

                    // for (int i = 0; i < m_AUX_Volt.GetLength(1); i++)
                    for (int i = 0; i < m_voltcount_aux[ch]; i++)
                    {
                        mtitle += (",AUX Volt. #" + (i + 1).ToString() + " (V)");
                    }

                    // for (int i = 0; i < m_AUX_Temp.GetLength(1); i++)
                    for (int i = 0; i < m_tempcount_aux[ch]; i++)
                    {
                        mtitle += (",AUX Temp. #" + (i + 1).ToString() + " (℃)");
                    }
                }
            }

            if (m_DAUEnable)
            {
                // if (m_DAU_Volt.GetLength(0) >= ch)
                //if (m_NumOfDAU > ch)
                {
                    // for (int i = 0; i < m_DAU_Volt.GetLength(1); i++)
                    for (int i = 0; i < m_voltcount_dau[ch]; i++)
                    {
                        mtitle += (",DAU Volt. #" + (i + 1).ToString() + " (V)");
                    }

                    // for (int i = 0; i < m_DAU_Temp.GetLength(1); i++)
                    for (int i = 0; i < m_tempcount_dau[ch]; i++)
                    {
                        mtitle += (",DAU Temp. #" + (i + 1).ToString() + " (℃)");
                    }
                }
            }

            if (m_BMSEnable)
            {
                // if (m_BMS_Volt.GetLength(0) >= ch)
                if (m_ucBMS_List.Count > ch)
                {
                    mtitle += ",BMS PackVolt. (V)";  // 230922, BGH

                    // for (int i = 0; i < m_BMS_Volt.GetLength(1); i++)
                    for (int i = 0; i < m_voltcount_bms[ch]; i++)
                    {
                        mtitle += (",BMS Volt. #" + (i + 1).ToString() + " (V)");
                    }

                    // for (int i = 0; i < m_DAU_Temp.GetLength(1); i++)
                    for (int i = 0; i < m_tempcount_bms[ch]; i++)
                    {
                        mtitle += (",BMS Temp. #" + (i + 1).ToString() + " (℃)");
                    }
                }
            }

            // ------------------
            // + BGH
            if (m_MBIEnable)
            {
                // if (m_BMS_Volt.GetLength(0) >= ch)
                if (m_ucMBI_List.Count >= ch)
                {
                    for (int i = 0; i < m_voltcount_mbi[ch]; i++)
                    {
                        mtitle += (",MBI Volt. #" + (i + 1).ToString() + " (V)");
                    }

                    for (int i = 0; i < m_tempcount_mbi[ch]; i++)
                    {
                        mtitle += (",MBI Temp. #" + (i + 1).ToString() + " (℃)");
                    }
                }
            }

            if (m_ITDevEnable)
            {
                if (m_ucIT_List.Count > ch)
                {
                    mtitle = mtitle + ",Insulation R #1(MΩ),Insulation R #2(MΩ)";
                }
            }

            if (m_tVOCEnable)
            {
                //+ Revision by LBG - 240531 : MTVD 버전에 따라 데이터 로깅
                if (m_iMTVD_Type == 0)
                {
                    mtitle += (",tVOC #" + (ch + 1).ToString() + " (ug/m3)");
                }

                //mtitle += (",tVOC #" + (ch + 1).ToString() + " (ug/m3)");
                //-
            }

            if (m_powersupply)
            {
                mtitle += ",PowerSupply_SP(V),PowerSupply_PV(V)";
            }

            //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
            //+ Add by YMJ - 250424 : CREVIS 장비 Logging 기능 추가
            if (m_CREVISEnable)
            {
                if (m_ucCREVIS_List.Count > 0)
                {
                    for (int i = 0; i < m_CREVIS_DEVISION; i++)
                    {
                        mtitle += (",CREVIS Temp. #" + (i + 1).ToString() + " (℃)");
                    }
                }
            }
            //-
            //-

            //+ Revision by YMJ - 250725 : CAN 헤더 오류 수정
            //+ Revision by YMJ - 250717 : alwaysLogging 옵션 시 제대로 로깅 되도록 수정
            //+ Add by YMJ - 250716 : CAN Logging 기능 추가
            if (m_CANEnable)
            {
                for (int i = 0; i < CurStInfo.MDBC_List_Safety.Count; i++)
                {
                    mtitle += ("," + CurStInfo.MDBC_List_Safety[i].Signal_Name);
                }
            }
            //-
            //-
            //-

            WriteBasicLogOut(ch, mtitle);

            //+ Add by LBG - 230911 : Basic Log의 용량 단위로 파일을 나눠 새로 파일을 생성할 경우 표시하기 위한 Header 저장
            if (m_clsAppSet.Logging_Set.Basic_Use)
            {
                if (m_dicBasicLog_Header != null)
                {
                    if (m_dicBasicLog_Header.ContainsKey(ch))
                    {
                        m_dicBasicLog_Header[ch] = mtitle;
                    }
                    else
                    {
                        m_dicBasicLog_Header.Add(ch, mtitle);
                    }
                }
                else
                {
                    m_dicBasicLog_Header = new Dictionary<int, string>();
                    m_dicBasicLog_Header.Add(ch, mtitle);
                }
            }
            //-

            // ------------------------------
            // Step Result Log
            // ------------------------------
            _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_StepResult.csv";
            logStepRes[ch] = new StreamWriter(_m_lpath, true, System.Text.Encoding.UTF8);
            //mtitle = "Timestamp,Step No,Step,Current Cycle,Total Cycle,Cut_Off Type,Initial Voltage(V),Voltage(V),Current(A),Capacity(Ah),Energy(Wh),Power(W)";
            //if (m_clsSys_Set.m_bUse_MBT || m_clsSys_Set.m_bUse_MCZ)
            //{
            //    mtitle = mtitle + ",Freq(Hz),Re(mΩ),Im(mΩ),Mag(mΩ),Rs(mΩ),Rct(mΩ),Temp(℃)";
            //}
            // WriteStepResLog(ch, mtitle, ABT.eNUM_CutOFF_Type.NONE);
            // -------------------------------------------------------
            // csv 파일과 구조 동일하게 맞춤. 230820
            // -------------------------------------------------------
            WriteStepResLogOut(ch, mtitle);


            // ------------------------------
            // open cycler log
            // ------------------------------
            _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_Cycler.cyc";

            cfile[ch] = new FileStream(_m_lpath, FileMode.CreateNew, FileAccess.Write, FileShare.ReadWrite);
            logCycler[ch] = new StreamWriter(cfile[ch], System.Text.Encoding.UTF8);
            //+ Add by YMJ - 240115 : _Cycler.cyc 파일에 Current Cycle, Total Cycle 추가
            mtitle = "Timestamp,Current Cycle,Total Cycle,Step No,Step,Voltage(V),Current(A),Capacity(Ah),Energy(Wh),Power(W),Temp(℃)";
            //-
            WriteCyclerLogOut(ch, mtitle);

            logCyclerPath[ch] = _m_lpath;

            //+ Add by LBG : Cycler Data 추가 (Step End Data)
            _m_lpath = fldpath + "\\Ch" + (ch + 1).ToString() + detailedname + "_Cycler_Summary.cyc";
            logCyclerRes[ch] = new StreamWriter(_m_lpath, true, System.Text.Encoding.UTF8);
            //+ Add by YMJ - 240115 : _Cycler_Summary.cyc 파일에 Current Cycle, Total Cycle 추가
            mtitle = "Timestamp,Current Cycle,Total Cycle,Step No,Step,Voltage(V),Current(A),Capacity(Ah),Energy(Wh),Power(W),Temp(℃)";
            //-
            //mtitle = "Timestamp, Step No, Step, Voltage(V), Current(A), Capacity(Ah), Energy(Wh), Temp(℃)";
            WriteCyclerResOut(ch, mtitle);

            // --------------------------------
            // assign path
            // --------------------------------
            if (m_ucMbT_List != null)
            {
                if (m_ucMbT_List.Count > ch)
                {
                    m_ucMbT_List[ch].datalog_path = fldpath;
                }
            }
            if (m_ucMcz_List != null)
            {
                if (m_ucMcz_List.Count > ch)
                {
                    m_ucMcz_List[ch].DATALOG_PATH = fldpath;
                }
            }
            if (m_ucUDDS_List != null)
            {
                if (m_ucUDDS_List.Count > ch)
                {
                    m_ucUDDS_List[ch].datalog_path = fldpath;
                }
            }

			if (m_ucChamber.EnableFlag)
			{
				// ----------------------------------------
				// 셀에서 여러채널에서 제어할 경우, 한 채널만 
				// 열어놓으면 다른 채널에서 사용가능.
				// 중복 Open 금지
				// ----------------------------------------
				if (m_ucChamber.isConnected)
				{
					// ------------------------------------
					// 이미 챔버가 연결되어있다면, 채널만 추가하면 된다.
					// ------------------------------------
					m_ucChamber.AddCh(ch);
					WriteSystemLog(ch, ">> Start Chamber - Add Ch", false);
				}
				else 
				{
					if (m_ucChamber.StartSerial())
					{
                        //m_ucChamber.SetReadTimer();
						Thread.Sleep(100);

						m_ucChamber.AddCh(ch);
						WriteSystemLog(ch, ">> Start Chamber", false);

						//if (m_ucChamberDIO.EnableFlag)
						//{
						//	m_ucChamberDIO.StartSerial();
						//	WriteSystemLog(ch, ">> Start Chamber DIO", false);
						//}
					}
					else
					{
						WriteSystemLog(ch, ">> Start Chamber [Not connected]", false);
					}

					// ----------------------------------------
					// Chamber DIO는 챔버 연결과 독립적으로 연결해야함.
					// -----------------------------------------
					if (m_ucChamberDIO.EnableFlag)
					{
						if (m_ucChamberDIO.StartSerial())
						{
							WriteSystemLog(ch, ">> Start Chamber DIO", false);
						}
						else
						{
							WriteSystemLog(ch, ">> Start Chamber DIO [Not connected]", false);
						}
					}
				}
			}

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            //if (m_ucChiller.EnableFlag)
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
            {
                if (m_ucChamber.isConnected)
                {
                    // ------------------------------------
                    // 이미 챔버가 연결되어있다면, 채널만 추가하면 된다.
                    // ------------------------------------
                    m_ucChamber.AddCh(ch);
                    WriteSystemLog(ch, ">> Start Chamber - Add Ch", false);
                }
                else
                {
                    if (m_ucChiller[ch].StartSerial())
                    {
                        m_ucChiller[ch].SetReadTimer();
                    //m_ucChiller.StopAction();
                    Thread.Sleep(100);

                        WriteSystemLog(ch, ">> Start Chiller_" + ch.ToString() + "CH", false);
                    }
                    else
                    {
                            WriteSystemLog(ch, ">> Start Chiller_" + ch.ToString() + "CH [Not connected]", false);
                    }
                }
            }
            //-
            //-

            // ---------------------------------------------------------------

            //+ Add by LBG : 작업 시작 Recipe 파일
            if (File.Exists(Recipe_Files[ch]))
            {
                string n_sDestFile = fldpath + "\\" + sche_names[ch] + ".xml";
                File.Copy(Recipe_Files[ch], n_sDestFile);

                Recipe_Files[ch] = n_sDestFile;
            }
            //-

            m_currentStep[ch] = 0;


            // ---------------------------------------------------
            // 23.09.03 Safety 수신부에서 삭제
            // 23.09.03 시작 메뉴(버튼) 클릭하면 그때 미리 검사를 하므로
            //          여기에서 Build 한번 더 하는건 중복임
            // ---------------------------------------------------
            //string xmlpath = sche_names_restart[ch];
            //m_ucStepInfo_List[ch].BuildStepCondition(xmlpath);


            // ---------------------------------------------------
            // 23.09.02 Safety 안착하는 동안 표시 위해
            // ---------------------------------------------------
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.SafetyWarmingUp = true;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);


            // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " Ch=" + (ch + 1).ToString() + " Start Test 2");

            // ----------------------------------------------------------------
            // Set Safety
            // ----------------------------------------------------------------
            m_timelimit[ch] = -1;
            volth = Math.Abs((double)(CurStInfo.m_safety.safety_volt_h)) * 1000;
            voltl = Math.Abs((double)(CurStInfo.m_safety.safety_volt_l)) * 1000;
            curh = (double)(CurStInfo.m_safety.safety_curr_h) * 1000;
            curl = (curh) * (-1.0); // (double)(CurStInfo.m_safety.safety_curr_l) * 1000;


            m_ucCycler_ABT_List[boardid].Write_Safety_PacketABT(bzch, voltl, volth, curl, curh);
            // ----------------------------------------------------------------

            m_ChamberReact[ch] = false;

            return true;
        }

        private ACIR_TYPE p_acirtype = ACIR_TYPE.MBT;

        // --------------------
        // ghbbb
        // --------------------
        public void GetMBTTemperature(int ch, double ftmp)
        {
            //int rlchno = GetChNumber(ch); // , U_CBOARD_TYPE.FIND_BOARDNo_Using_Ch);
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);

            //+ Revision by YMJ - 240530 : 채널정보 UI에 온도 출력 설정값이 MBT일 경우에만 온도 갱신
            if (m_temp_Collect_dev.Equals("MBT"))
            {
                //if (ftmp > -25 && ftmp < 100)
                if (ftmp > 1 && ftmp < 100f)
                {
                    // m_ucCycler_ABT_List[m_Cur_BD_idx].m_ChStatusList[rlchno].Current_T = ftmp;
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = ftmp;
                }
                else
                {
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = 0;
                }
            }
            //-
        }

        // --------------------------------------------------------------------------------
        //
        // --------------------------------------------------------------------------------
        public void WriteTOSLog(int ch)
        {
            if (!tos_activation) return;

            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            string msgbasic = "";
            bool sche_done = false;

            tos_iswritting = true;

            // ------------------------------
            // open Log for TOS 연동
            // ------------------------------            
            string _t_path = "C:\\Data\\" + work_names[ch] + "\\M" + (boardid + 1).ToString("D2") + "CH" + (ch + 1).ToString("D3");
            try
            {
                DirectoryInfo di = new DirectoryInfo(_t_path);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }
            _t_path += ("\\" + work_names[ch] + ".txt");

            using (StreamWriter logTOS = new StreamWriter(_t_path, false, System.Text.Encoding.UTF8))
            {
                string ttitle = "CHANNEL_STATUS_CD, " +
                                "MODULE, " +
                                "CHANNEL_NO, " +
                                "START_TIME, " +
                                "END_TIME, " +
                                "STEP_NO, " +
                                "STEP_TYPE_CD, " +
                                "STATUS_LV2, " +
                                "STATUS_LV3, " +
                                "STATUS_CD, " +
                                "STEP_TIME, " +
                                "TOTAL_TIME, " +
                                "VOLTAGE, " +
                                "CURRENT, " +
                                "CAPACITY, " +
                                "POWER, " +
                                "WATT_HOUR, " +
                                "IMPEDANCE, " +
                                "TEMPERATURE, " +
                                "CUR_CYCLE, " +
                                "TOT_CYCLE, " +
                                "AVG_VOLTAGE, " +
                                "AVG_CURRENT, " +
                                "CHARGE_CAPACITY, " +
                                "DISCHARGE_CAPACITY, " +
                                "SCH_NAME, " +
                                "SV, " +
                                "DIAG, " +
                                "DATA_LOSS";
                logTOS.WriteLine(ttitle);
                logTOS.Flush();

                // -----------------------------------------
                // 29 ITEM
                //ttitle = "CHANNEL_STATUS_CD, MODULE, CHANNEL_NO, START_TIME, END_TIME, STEP_NO, STEP_TYPE_CD, STATUS_LV2, STATUS_LV3, STATUS_CD, STEP_TIME, TOTAL_TIME, VOLTAGE, CURRENT, " +
                //         "CAPACITY, POWER, WATT_HOUR, IMPEDANCE, TEMPERATURE, CUR_CYCLE, TOT_CYCLE, AVG_VOLTAGE, AVG_CURRENT, CHARGE_CAPACITY, DISCHARGE_CAPACITY, SCH_NAME, SV, DIAG, DATA_LOSS";
                // -----------------------------------------
                // 28 ITEM (without STATUS_CD)
                //ttitle = "CHANNEL_STATUS_CD, MODULE, CHANNEL_NO, START_TIME, END_TIME, STEP_NO, STEP_TYPE_CD, STATUS_LV2, STATUS_LV3, STEP_TIME, TOTAL_TIME, VOLTAGE, CURRENT, " +
                //         "CAPACITY, POWER, WATT_HOUR, IMPEDANCE, TEMPERATURE, CUR_CYCLE, TOT_CYCLE, AVG_VOLTAGE, AVG_CURRENT, CHARGE_CAPACITY, DISCHARGE_CAPACITY, SCH_NAME, SV, DIAG, DATA_LOSS";
                // -----------------------------------------


                // ------------------------------------------------------
                // 1. CHANNEL_STATUS_CD
                // ------------------------------------------------------            
                switch (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype)
                {
                    case cls_stepInfo.enumStepType.Charge:
                    case cls_stepInfo.enumStepType.Discharge:
                    case cls_stepInfo.enumStepType.CYCLE_START:
                    case cls_stepInfo.enumStepType.CYCLE_END:
                    case cls_stepInfo.enumStepType.MBT:
                    case cls_stepInfo.enumStepType.MCZ:
                    case cls_stepInfo.enumStepType.Rest:
                    case cls_stepInfo.enumStepType.OCV:
                    case cls_stepInfo.enumStepType.InsulationTest:
                    case cls_stepInfo.enumStepType.Pattern:
                        msgbasic = "ONGOING,";
                        break;
                    case cls_stepInfo.enumStepType.STANDBY:
                    case cls_stepInfo.enumStepType.STANDBY_wALARM:
                    case cls_stepInfo.enumStepType.WORK_END:
                    case cls_stepInfo.enumStepType.WORK_END_wALARM:
                        //msgbasic = "COMPLETE,";
                        msgbasic = "END,";
                        sche_done = true;
                        break;
                    default:
                        msgbasic = "STOP,";
                        break;
                }

                int cstepno = m_ucStepInfo_List[ch].m_currentStepNo;

                // ------------------------------------------------------
                // 2. MODULE
                // ------------------------------------------------------
                msgbasic += (boardid + 1).ToString() + ",";

                // ------------------------------------------------------
                // 3. CHANNEL_NO
                // ------------------------------------------------------
                msgbasic += (ch + 1).ToString() + ",";

                // ------------------------------------------------------
                // 4. START_TIME
                // ------------------------------------------------------
                msgbasic += m_ucStepInfo_List[ch].TestStartTime.ToString("yyyy-MM-dd HH:mm:ss") + ",";

                // ------------------------------------------------------
                // 5. END_TIME
                // ------------------------------------------------------
                if (sche_done)
                {
                    msgbasic += m_ucStepInfo_List[ch].TestEndTime.ToString("yyyy-MM-dd HH:mm:ss") + ",";
                }
                else
                {
                    msgbasic += ",";
                }

                // ------------------------------------------------------
                // 6. STEP_NO
                // ------------------------------------------------------                
                msgbasic += cstepno.ToString() + ",";

                // ------------------------------------------------------
                // 7. STEP_TYPE_CD
                // Error 코드등 표시
                // ------------------------------------------------------
                msgbasic += ",";

                // ------------------------------------------------------
                // 8. STATUS_LV2
                // ------------------------------------------------------
                msgbasic += ",";

                // ------------------------------------------------------
                // 9. STATUS_LV3
                // ------------------------------------------------------
                msgbasic += ",";

                // ------------------------------------------------------
                // 10. STATUS_CD
                // ------------------------------------------------------
                msgbasic += ",";

                // ------------------------------------------------------
                // 11. STEP_TIME
                // ------------------------------------------------------
                TimeSpan tdiff = new TimeSpan(0, 0, 0, 0);

                tdiff = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].OGTime_Step_4disp;

                if (tdiff.Days > 0)
                {
                    msgbasic += (tdiff.Days.ToString("D2") + " " + tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2") + "." + tdiff.Milliseconds.ToString("D2") + ",");
                }
                else
                {
                    msgbasic += (tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2") + "." + tdiff.Milliseconds.ToString("D2") + ",");
                }

                // ------------------------------------------------------
                // 12. TOTAL_TIME
                // ------------------------------------------------------
                tdiff = m_ucStepInfo_List[ch].OGTime_Total_4disp;

                if (tdiff.Days > 0)
                {
                    msgbasic += (tdiff.Days.ToString("D2") + " " + tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2") + "." + tdiff.Milliseconds.ToString("D2") + ",");
                }
                else
                {
                    msgbasic += (tdiff.Hours.ToString("D2") + ":" + tdiff.Minutes.ToString("D2") + ":" + tdiff.Seconds.ToString("D2") + "." + tdiff.Milliseconds.ToString("D2") + ",");
                }

                // ------------------------------------------------------
                // 13. VOLTAGE
                // ------------------------------------------------------
                //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                //msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V.ToString("F3") + ",";
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V.ToString(Volt_Number_Digit) + ",";
                //-

                // ------------------------------------------------------
                // 14. CURRENT
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I.ToString("F3") + ",";

                // ------------------------------------------------------
                // 15. CAPACITY
                // ------------------------------------------------------
                //msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_Q.ToString("F3") + ",";
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q.ToString("F3") + ",";

                // ------------------------------------------------------
                // 16. POWER
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_P.ToString("F3") + ",";

                // ------------------------------------------------------
                // 17. WATT_HOUR
                // ------------------------------------------------------
                //msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_E.ToString("F3") + ",";
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_E.ToString("F3") + ",";

                // ------------------------------------------------------
                // 18. IMPEDANCE
                // ------------------------------------------------------
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I != 0)
                {
                    msgbasic += (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V / m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I).ToString("F3") + ",";
                }
                else
                {
                    msgbasic += "0, ";
                }


                // ------------------------------------------------------
                // 19. TEMPERATURE
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2") + ",";


                // ------------------------------------------------------
                // 20. CUR_CYCLE
                // ------------------------------------------------------
                msgbasic += m_ucStepInfo_List[ch].m_curCycle.ToString() + ",";

                // ------------------------------------------------------
                // 21. TOT_CYCLE
                // ------------------------------------------------------
                msgbasic += m_ucStepInfo_List[ch].m_totCycle.ToString() + ",";

                // ------------------------------------------------------
                // 22. AVG_VOLTAGE
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Avg_V.ToString("F3") + ",";

                // ------------------------------------------------------
                // 23. AVG_CURRENT
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Avg_I.ToString("F3") + ",";

                // ------------------------------------------------------
                // 24. CHARGE_CAPACITY
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentCha_Q.ToString("F3") + ",";

                // ------------------------------------------------------
                // 25. DISCHARGE_CAPACITY
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentDisch_Q.ToString("F3") + ",";

                // ------------------------------------------------------
                // 26. SCH_NAME
                // ------------------------------------------------------
                try
                {
                    // msgbasic += Path.GetFileNameWithoutExtension(sche_names[ch]) + ".xml,";
                    msgbasic += sche_names[ch] + ".xml,";
                }
                catch
                {
                    msgbasic += ", ";
                }

                // ------------------------------------------------------
                // 27. SV
                // ------------------------------------------------------
                msgbasic += m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2") + ",";

                // ------------------------------------------------------
                // 28. DIAG
                // ------------------------------------------------------
                msgbasic += ",";

                // ------------------------------------------------------
                // 29. DATA_LOSS
                // ------------------------------------------------------
                // msgbasic += "NA, ";


                logTOS.WriteLine(msgbasic);
                logTOS.Flush();
            }

            tos_iswritting = false;
        }

        // --------------------------------------------------------------------------------
        //
        // --------------------------------------------------------------------------------
        // public void WriteBasicLog(int ch, string emgMsg, eNUM_CutOFF_Type cutype, bool wStepResult)
        public void WriteBasicLog(int ch, string emgMsg, eNUM_CutOFF_Type cutype, bool wStepResult, bool enProc = false)
        {
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            bool lastrec = false;

            // "Timestamp, Step, Mode, Voltage, Current, Capacity(Q), Energy(E), 
            string msgbasic = "";
            string msgcyclog = "";

            bool firstPatternlog = false;

            cls_devCyclerABT.struCyclerStatus cyInfo = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch]; //new cls_devCyclerABT.struCyclerStatus();
            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            cls_stepInfo.enumStepType eStepType;


            // 종료시 로그때문에 enProc 파라미터 도입
            // 231115 BGH
            if (!enProc && cyInfo.isPaused) return;           

            CurStInfo = m_ucStepInfo_List[ch];


            msgbasic = (boardid + 1).ToString() + "," + (ch + 1).ToString() + "," +       // Module, Channel, 
                        cyInfo.StartTime.ToString("yyyy-MM-dd HH:mm:ss") + "," +           // StartTime, 
                        DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "," +               // EndTime, 
                        CurStInfo.m_totCycle.ToString() + "," + CurStInfo.m_curCycle.ToString() + "," +     // Total Cycle, Current Cycle, 
                        (CurStInfo.m_currentStepNo + 1).ToString() + ",";                           // Step No, 

            try
            {
                if (cyInfo.m_ChamberWarming)
                {
                    if (SystemLanguage == LanguageType.KOREAN) msgbasic = msgbasic + "챔버대기,,";
                    else msgbasic = msgbasic + "Chamber Waiting,,";
                }
                else
                {
                    // Step Type, STep Code, 
                    eStepType = cyInfo.m_step.steptype;
                    if (emgMsg.Length < 2)
                    {
                        //eStepType = cyInfo.m_step.steptype;
                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            switch (eStepType)
                            {
                                case cls_stepInfo.enumStepType.Wait_Charge:
                                case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + "충전,"; break;

                                case cls_stepInfo.enumStepType.Wait_Discharge:
                                case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + "방전,"; break;

                                case cls_stepInfo.enumStepType.Wait_Rest:
                                case cls_stepInfo.enumStepType.Wait_OCV:
                                case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "휴지,"; break;
                                case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV,"; break;
                                case cls_stepInfo.enumStepType.Pattern:
                                    msgbasic = msgbasic + "패턴,";
                                    break;

                                // 231130
                                //case cls_stepInfo.enumStepType.Wait_MBT:
                                //case cls_stepInfo.enumStepType.MBT:
                                //    msgbasic = msgbasic + "EIS,"; break;

                                case cls_stepInfo.enumStepType.Wait_InsulTest:
                                case cls_stepInfo.enumStepType.InsulationTest:
                                    msgbasic = msgbasic + "절연저항,"; break;

                                default:
                                    msgbasic = msgbasic + eStepType.ToString() + ","; break;
                            }
                        }
                        else
                        {
                            msgbasic = msgbasic + eStepType.ToString() + ",";
                        }

                        if (eStepType == cls_stepInfo.enumStepType.Pattern)
                        {
                            firstPatternlog = true;
                        }

                        if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING)
                        {
                            string endmsg = "작업종료,";
                            if (SystemLanguage == LanguageType.KOREAN)
                            {

                                //switch (eStepType)
                                //{
                                //case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + "충전진행,"; break;
                                //case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + "방전진행,"; break;
                                //case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "REST진행,"; break;
                                //case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV진행,"; break;
                                //case cls_stepInfo.enumStepType.Pattern:
                                //    msgbasic = msgbasic + "패턴진행[" + m_ucUDDS_List[ch].FetchNumber.ToString("D5") + "],";
                                //    break;
                                //default: msgbasic = msgbasic + "STEP종료,"; break;

                                endmsg = "작업종료,";
                                switch (cutype)
                                {
                                    case eNUM_CutOFF_Type.VOLTAGE: endmsg = "전압종료,"; break;
                                    case eNUM_CutOFF_Type.CURRENT: endmsg = "전류종료,"; break;
                                    case eNUM_CutOFF_Type.TIME: endmsg = "시간종료,"; break;
                                    case eNUM_CutOFF_Type.CAPACITY: endmsg = "용량종료,"; break;
                                    case eNUM_CutOFF_Type.ENERGY: endmsg = "사용량종료,"; break;
                                    case eNUM_CutOFF_Type.DOD: endmsg = "DOD종료,"; break;
                                    case eNUM_CutOFF_Type.SOC: endmsg = "SOC종료,"; break;
                                    case eNUM_CutOFF_Type.POWER: endmsg = "전력종료,"; break;
                                    case eNUM_CutOFF_Type.deltaVoltage: endmsg = "전압변위종료,"; break;

                                    case eNUM_CutOFF_Type.deltaCurrent: endmsg = "전류변위종료,"; break;  // 231126
                                    case eNUM_CutOFF_Type.deltaTemp: endmsg = "온도변위종료,"; break;  // 231126

                                    case eNUM_CutOFF_Type.AUX_VOLTAGE: endmsg = "AUX전압종료,"; break;
                                    case eNUM_CutOFF_Type.AUX_TEMP: endmsg = "AUX온도종료,"; break;
                                    case eNUM_CutOFF_Type.CAN: endmsg = "CAN종료,"; break;
                                    case eNUM_CutOFF_Type.USER: endmsg = "USER종료,"; break;
                                }                                
                            }
                            else
                            {
                                //msgbasic = msgbasic + "StepEnd,";
                                endmsg = "StepEnd,";
                                switch (cutype)
                                {
                                    case eNUM_CutOFF_Type.VOLTAGE: endmsg = "StepEnd By Volt,"; break;
                                    case eNUM_CutOFF_Type.CURRENT: endmsg = "StepEnd By Current,"; break;
                                    case eNUM_CutOFF_Type.TIME: endmsg = "StepEnd By Time,"; break;
                                    case eNUM_CutOFF_Type.CAPACITY: endmsg = "StepEnd By Q[Ah],"; break;
                                    case eNUM_CutOFF_Type.ENERGY: endmsg = "StepEnd By E[Wh],"; break;
                                    case eNUM_CutOFF_Type.DOD: endmsg = "StepEnd By DOD,"; break;
                                    case eNUM_CutOFF_Type.SOC: endmsg = "StepEnd By SOC,"; break;
                                    case eNUM_CutOFF_Type.POWER: endmsg = "StepEnd By Power,"; break;
                                    case eNUM_CutOFF_Type.deltaVoltage: endmsg = "StepEnd By deltaVolt,"; break;

                                    case eNUM_CutOFF_Type.deltaCurrent: endmsg = "StepEnd By deltaCurr,"; break;  // 231126
                                    case eNUM_CutOFF_Type.deltaTemp: endmsg = "StepEnd By deltaTemp,"; break;  // 231126

                                    case eNUM_CutOFF_Type.AUX_VOLTAGE: endmsg = "StepEnd By AUX Voltage,"; break;
                                    case eNUM_CutOFF_Type.AUX_TEMP: endmsg = "AStepEnd By AUX Temperature,"; break;
                                    case eNUM_CutOFF_Type.CAN: endmsg = "StepEnd By CAN,"; break;
                                    case eNUM_CutOFF_Type.USER: endmsg = "StepEnd By User,"; break;
                                }
                            }
                            msgbasic = msgbasic + endmsg;

                            lastrec = true;
                        }
                        else
                        {
                            if (SystemLanguage == LanguageType.KOREAN)
                            {
                                switch (eStepType)
                                {
                                    //+ Revision by YMJ - 240523 : 충방전일 경우Step Code에 동작 모드 표기로 변경
                                    case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + cyInfo.m_step.stepmode + ","; break;
                                    case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + cyInfo.m_step.stepmode + ","; break;
                                    //-
                                    case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "휴지진행,"; break;
                                    case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV진행,"; break;
                                    case cls_stepInfo.enumStepType.Pattern:
                                        //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                                        /*if (cyInfo.OGTime_Step_4log.TotalMilliseconds == 0 && cyInfo.Current_I == 0)
                                        {
                                            msgbasic = msgbasic + "패턴진행[00000],";
                                        }
                                        else
                                        {*/
                                        msgbasic = msgbasic + "패턴진행[" + m_ucUDDS_List[ch].FetchNumber.ToString("D5") + "],";
                                        /*}*/
                                        //-
                                        break;
                                    default: msgbasic = msgbasic + "작업진행,"; break;
                                }
                            }
                            else
                            {
                                switch (eStepType)
                                {
                                    //+ Revision by YMJ - 240523 : 충방전일 경우Step Code에 동작 모드 표기로 변경
                                    case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + cyInfo.m_step.stepmode + ","; break;
                                    case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + cyInfo.m_step.stepmode + ","; break;
                                    //-
                                    case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "Resting,"; break;
                                    case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV Resting,"; break;
                                    case cls_stepInfo.enumStepType.Pattern:
                                        //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                                        /*if (cyInfo.OGTime_Step_4log.TotalMilliseconds == 0 && cyInfo.Current_I == 0)
                                        {
                                            msgbasic = msgbasic + "Pattern[00000],";
                                        }
                                        else
                                        {*/
                                        msgbasic = msgbasic + "Pattern[" + m_ucUDDS_List[ch].FetchNumber.ToString("D5") + "],";
                                        /*}*/
                                        //-
                                        break;
                                    default: msgbasic = msgbasic + "ING,"; break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // 231115 BGH
                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            switch (eStepType)
                            {
                                case cls_stepInfo.enumStepType.Wait_Charge:
                                case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + "충전,"; break;

                                case cls_stepInfo.enumStepType.Wait_Discharge:
                                case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + "방전,"; break;

                                case cls_stepInfo.enumStepType.Wait_Rest:
                                case cls_stepInfo.enumStepType.Wait_OCV:
                                case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "휴지,"; break;
                                case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV,"; break;
                                case cls_stepInfo.enumStepType.Pattern:
                                    msgbasic = msgbasic + "패턴,";
                                    break;

                                //case cls_stepInfo.enumStepType.Wait_MBT:
                                //case cls_stepInfo.enumStepType.MBT:
                                //    msgbasic = msgbasic + "EIS,"; break;

                                case cls_stepInfo.enumStepType.Wait_InsulTest:
                                case cls_stepInfo.enumStepType.InsulationTest:
                                    msgbasic = msgbasic + "절연저항,"; break;

                                default:
                                    msgbasic = msgbasic + eStepType.ToString() + ","; break;
                            }
                        }
                        else
                        {
                            msgbasic = msgbasic + eStepType.ToString() + ",";
                        }
                        //msgbasic = msgbasic + emgMsg + ",,";
                        msgbasic = msgbasic + emgMsg + ",";
                    }
                }


                if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING || emgMsg.Length > 1)
                {

                    msgbasic = msgbasic + cyInfo.OGTime_Step_Final.Days.ToString("D2") + ":" + cyInfo.OGTime_Step_Final.Hours.ToString("D2") + ":" +
                                cyInfo.OGTime_Step_Final.Minutes.ToString("D2") + ":" + cyInfo.OGTime_Step_Final.Seconds.ToString("D2") + ":" +
                                cyInfo.OGTime_Step_Final.Milliseconds.ToString("D3") + ",";

                    msgbasic = msgbasic + CurStInfo.OGTime_Total_Final.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Hours.ToString("D2") + ":" +
                                            CurStInfo.OGTime_Total_Final.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Seconds.ToString("D2") + ":" +
                                            CurStInfo.OGTime_Total_Final.Milliseconds.ToString("D3") + ",";

                    //+ Revision by YMJ - 240115 : Cycler 파일에 Current Cycle, Total Cycle 추가
                    msgcyclog = CurStInfo.OGTime_Total_Final.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Hours.ToString("D2") + ":" +
                                CurStInfo.OGTime_Total_Final.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Seconds.ToString("D2") + ":" +
                                CurStInfo.OGTime_Total_Final.Milliseconds.ToString("D3") + "," + CurStInfo.m_curCycle.ToString() + "," + CurStInfo.m_totCycle.ToString() + ",";
                    //-
                }
                else
                {
                    // Step Time, Total Time, 

                    msgbasic = msgbasic + cyInfo.OGTime_Step_4log.Days.ToString("D2") + ":" + cyInfo.OGTime_Step_4log.Hours.ToString("D2") + ":" +
                                          cyInfo.OGTime_Step_4log.Minutes.ToString("D2") + ":" + cyInfo.OGTime_Step_4log.Seconds.ToString("D2") + ":" +
                                          cyInfo.OGTime_Step_4log.Milliseconds.ToString("D3") + ",";

                    msgbasic = msgbasic + CurStInfo.OGTime_Total_4log.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Hours.ToString("D2") + ":" +
                                          CurStInfo.OGTime_Total_4log.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Seconds.ToString("D2") + ":" +
                                          CurStInfo.OGTime_Total_4log.Milliseconds.ToString("D3") + ",";

                    //+ Revision by YMJ - 240115 : Cycler 파일에 Current Cycle, Total Cycle 추가
                    msgcyclog = CurStInfo.OGTime_Total_4log.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Hours.ToString("D2") + ":" +
                                CurStInfo.OGTime_Total_4log.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Seconds.ToString("D2") + ":" +
                                CurStInfo.OGTime_Total_4log.Milliseconds.ToString("D3") + "," + CurStInfo.m_curCycle.ToString() + "," + CurStInfo.m_totCycle.ToString() + ",";
                    //-
                }

                // TEST22
                // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + " // " + msgbasic);

                // --------------------------------------
                // CV Time logging
                // --------------------------------------
                if (enableCVTimelogging)
                {
                    if (cyInfo.isCVModeStarted)
                    {
                        msgbasic = msgbasic + cyInfo.CVTime.Hours.ToString("D2") + ":" + cyInfo.CVTime.Minutes.ToString("D2") + ":" + cyInfo.CVTime.Seconds.ToString("D2") + ":" + cyInfo.CVTime.Milliseconds.ToString("D3") + ",";
                    }
                    else
                    {
                        msgbasic = msgbasic + "00:00:00:000,";
                    }
                }
                
                if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING)
                {
                    // -
                    // Complete는 한번만.
                    // -
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.WHATEVER;
                }


                // InitV(V), Voltage(V), Current(A), Capacity(Ah), Energy(Wh), Power(W), 
                //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                //msgbasic = msgbasic + CurStInfo.LastInitVoltage.ToString("F3") + ",";
                msgbasic = msgbasic + CurStInfo.LastInitVoltage.ToString(Volt_Number_Digit) + ",";
                //msgbasic = msgbasic + cyInfo.Current_V.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.Current_V.ToString(Volt_Number_Digit) + ",";
                //-

                //+ Revision by LBG - 231011 : CYC파일 열이 Step No, Step Type, Voltage가 중복 로깅되어 해당 부분 주석 처리
                //msgcyclog = msgcyclog + (CurStInfo.m_currentStepNo + 1).ToString() + ",";
                //msgcyclog = msgcyclog + cyInfo.m_step.steptype.ToString() + ",";
                //msgcyclog = msgcyclog + cyInfo.Current_V.ToString("F3") + ",";
                //-

                //+ Revision By YMJ - 240814 : 패턴 관련 로깅 옵션 수정
                /*if (firstPatternlog && cyInfo.OGTime_Step_4log.TotalMilliseconds == 0)
                {                    
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0,";

                    // -                    
                    msgcyclog = msgcyclog + "0,";
                    msgcyclog = msgcyclog + "0,";
                    msgcyclog = msgcyclog + "0,";
                    msgcyclog = msgcyclog + "0,";

                    // 231204
                    msgcyclog = msgcyclog + "0,0,0,0,0";


                    // ChargeCapacity(Ah), DischargeCapacity(Ah), ChargeEnergy(Wh), DischargeEnergy(Wh),
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0,";
                    msgbasic = msgbasic + "0";
                }
                else
                {*/

                //+ Add By YMJ - 251017 : 패턴일 경우 로깅 타임이 1000ms이하면 로깅 시에 용량 및 에너지 계산 처리
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype == cls_stepInfo.enumStepType.Pattern && m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.wIntv.wCond_Time <= 1000)
                {
                    double tgap = (CurStInfo.OGTime_Total_4log - CurStInfo.OGTime_Total_4log_before).TotalMilliseconds;
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q += cyInfo.Current_I * (tgap / 1000.0) / 3600.0;
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_E += cyInfo.Current_V * cyInfo.Current_I * (tgap / 1000.0) / 3600.0;

                    if (cyInfo.Current_I > 0)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentCha_Q += cyInfo.Current_I * (tgap / 1000.0) / 3600.0;
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentCha_E += cyInfo.Current_V * cyInfo.Current_I * (tgap / 1000.0) / 3600.0;
                    }
                    else if (cyInfo.Current_I < 0)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentDisch_Q += cyInfo.Current_I * (tgap / 1000.0) / 3600.0;
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurrentDischa_E += cyInfo.Current_V * cyInfo.Current_I * (tgap / 1000.0) / 3600.0;
                    }
                }
                //-
                msgbasic = msgbasic + cyInfo.Current_I.ToString("F3") + ",";

                //+ Revision by YMJ - 250114 : 온도 Reset 값일 경우 공란으로 표기
                if (cyInfo.Current_T == 999.99)
                {
                    msgbasic = msgbasic + ",";
                }
                else
                {
                    msgbasic = msgbasic + cyInfo.Current_T.ToString("F3") + ",";
                }
                //-
                msgbasic = msgbasic + cyInfo.CurStep_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurStep_E.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.Current_P.ToString("F3") + ",";

                // -
                msgcyclog = msgcyclog + (CurStInfo.m_currentStepNo + 1).ToString() + ",";
                msgcyclog = msgcyclog + cyInfo.m_step.steptype.ToString() + ",";
                //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                //msgcyclog = msgcyclog + cyInfo.Current_V.ToString("F3") + ",";
                msgcyclog = msgcyclog + cyInfo.Current_V.ToString(Volt_Number_Digit) + ",";
                //-
                msgcyclog = msgcyclog + cyInfo.Current_I.ToString("F5") + ",";
                msgcyclog = msgcyclog + cyInfo.CurStep_Q.ToString("F3") + ",";
                msgcyclog = msgcyclog + cyInfo.CurStep_E.ToString("F3") + ",";
                msgcyclog = msgcyclog + cyInfo.Current_P.ToString("F3") + ",";
                //+ Revision by YMJ - 250114 : 온도 Reset 값일 경우 공란으로 표기
                if (cyInfo.Current_T == 999.99)
                {
                    msgcyclog = msgcyclog;
                }
                else
                {
                    msgcyclog = msgcyclog + cyInfo.Current_T.ToString("F3");
                }
                //-

                // ChargeCapacity(Ah), DischargeCapacity(Ah), ChargeEnergy(Wh), DischargeEnergy(Wh),
                msgbasic = msgbasic + cyInfo.CurrentCha_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentDisch_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentCha_E.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentDischa_E.ToString("F3"); // + ",";
                /*}*/
                //-

                //+ Add By YMJ - 251017 : 패턴일 경우 로깅 타임이 1000ms이하면 로깅 시에 용량 및 에너지 계산 처리
                CurStInfo.OGTime_Total_4log_before = CurStInfo.OGTime_Total_4log;
                //-

                if (m_clsSys_Set.m_bUse_MBT || m_clsSys_Set.m_bUse_MCZ)
                {
                    bool useElem = false;
                    try
                    {
                        if (m_clsSys_Set.m_Sys_MBT.Count() > 0) useElem = true;
                    }
                    catch { }
                    try
                    {
                        if (m_clsSys_Set.m_Sys_MCZ.Count() > 0) useElem = true;
                    }
                    catch { }

                    if (useElem)
                    {
                        // Freq, Re, Im, Rs, Rct, T";
                        if (p_acirtype == ACIR_TYPE.MBT)
                        {
                            msgbasic = msgbasic + ",";
                            msgbasic = msgbasic + m_ucMbT_List[ch].MeasureData.freq.ToString("F3") + ",";
                            msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.RE * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.IM * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Mag * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Rs * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Rct * 1000.0).ToString("F5") + ",";
                            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T > -50 &&
                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                            {
                                msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2");
                            }
                            else
                            {
                                msgbasic = msgbasic + " ";
                            }
                        }
                        else
                        {
                            msgbasic = msgbasic + ",";
                            msgbasic = msgbasic + m_ucMcz_List[ch].MeasureData.freq.ToString("F3") + ",";
                            msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.RE * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.IM * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Mag * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Rs * 1000.0).ToString("F5") + ",";
                            msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Rct * 1000.0).ToString("F5") + ",";
                            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T > -50 &&
                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                            {
                                msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2");
                            }
                            else
                            {
                                msgbasic = msgbasic + " ";
                            }
                        }
                    }
                }

                //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                if (m_ucChamber.EnableFlag)
                //if (m_clsSys_Set.m_bUse_Chamber && m_clsSys_Set.m_Sys_Chamber != null)
                {
                    //for (int i = 0; i < m_clsSys_Set.m_Sys_Chamber.Count(); i++)
                    //{
                    //if (m_clsSys_Set.m_Sys_Chamber[i].Chamber_Use)
                    //{
                    if (m_ucChamber.SP < -50.0f || m_ucChamber.SP > 100)
                    {
                        msgbasic = msgbasic + "," ; 
                        msgbasic = msgbasic + "," ; 
                    }
                    else
                    {
                        //+ Revision by LBG - 250821 : Simpac, TEMI2500의 경우 습도도 로깅 추가
                        //if (lastrec)
                        //{
                        //    msgbasic = msgbasic + "," + m_ucChamber.SP_Backup.ToString("F2");
                                                                               //}
                        //else
                        //{
                        //    msgbasic = msgbasic + "," + m_ucChamber.SP.ToString("F2");
                                                                               //}
                        //msgbasic = msgbasic + "," + m_ucChamber.PV.ToString("F2");
                        if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
                        {
                            if (lastrec)
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP_Backup.ToString("F2");
                            }
                            else
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP.ToString("F2");
                            }
                            msgbasic = msgbasic + "," + m_ucChamber.PV.ToString("F2");
                            msgbasic = msgbasic + "," + m_ucChamber.HUMIDITY_S.ToString("F2");
                            msgbasic = msgbasic + "," + m_ucChamber.HUMIDITY_P.ToString("F2");
                        }
                        else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                        {
                            if (lastrec)
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP_Backup.ToString("F2");
                            }
                            else
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP.ToString("F2");
                            }
                            msgbasic = msgbasic + "," + m_ucChamber.PV.ToString("F2");
                            msgbasic = msgbasic + "," + m_ucChamber.HUMIDITY_S.ToString("F2");
                            msgbasic = msgbasic + "," + m_ucChamber.H_PV.ToString("F2");
                        }
                        else
                        {
                            if (lastrec)
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP_Backup.ToString("F2");
                            }
                            else
                            {
                                msgbasic = msgbasic + "," + m_ucChamber.SP.ToString("F2");
                            }
                            msgbasic = msgbasic + "," + m_ucChamber.PV.ToString("F2");
                        }
                        //-
                    }
                }

                //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
                //if (m_ucChiller.EnableFlag)
                if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
                {
                    msgbasic = msgbasic + "," + m_ucChiller[ch].SP.ToString("F2"); 
                    msgbasic = msgbasic + "," + m_ucChiller[ch].PV.ToString("F2"); 
                    msgbasic = msgbasic + "," + m_ucChiller[ch].Flow_SP.ToString("f2"); 
                    msgbasic = msgbasic + "," + m_ucChiller[ch].Flow_PV.ToString("f2"); 
                }
                //-
                //-

                if (m_AUXEnable)
                {
                    bool isbaln = false;
                    if (m_ucBalancer_List != null)
                    {
                        if (m_ucBalancer_List.Count > ch)
                        {
                            if (m_ucBalancer_List[ch].ControlEnabled && m_ucBalancer_List[ch].isBalancing)
                            {
                                for (int i = 0; i < m_ucBalancer_List[ch].BalancingList.Length; i++)
                                {
                                    if (m_ucBalancer_List[ch].BalancingList[i] == 1)
                                    {
                                        isbaln = true;
                                        break;
                                    }
                                }
                            }
                            
                        }
                    }

                    if (isbaln)
                    {
                        switch (m_ucBalancer_List[ch].BalancingResis)
                        {
                            case BALANCING_RESISTER_TYPE.R20: msgbasic = msgbasic + ", 20(Ω)"; break;
                            case BALANCING_RESISTER_TYPE.R40: msgbasic = msgbasic + ", 40(Ω)"; break;
                            case BALANCING_RESISTER_TYPE.R60: msgbasic = msgbasic + ", 60(Ω)"; break;
                        }

                        for (int i = 0; i < m_ucBalancer_List[ch].BalancingList.Length; i++)
                        {
                            if (m_ucBalancer_List[ch].BalancingList[i] == 1)
                            {
                                msgbasic += ((i + 1).ToString() + "/");
                            }
                        }
                    }
                    else
                    {
                        msgbasic = msgbasic + ",";
                    }


                    //if (m_AUX_Volt.GetLength(0) >= ch)
                    if (m_ucAUX7019_List.Count > ch)
                    {
                        // for (int i = 0; i < m_AUX_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_aux[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_AUX_Volt[ch, i].ToString("F3");
                        }

                        // for (int i = 0; i < m_AUX_Temp.GetLength(1); i++)
                        for (int i = 0; i < m_tempcount_aux[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_AUX_Temp[ch, i].ToString("F3");
                        }
                    }
                }

                if (m_DAUEnable)
                {
                    //if (m_DAU_Volt.GetLength(0) >= ch)
                   //if (m_NumOfDAU > ch)
                    {
                        // for (int i = 0; i < m_DAU_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_dau[ch]; i++)
                        {
                            //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                            //msgbasic = msgbasic + "," + m_DAU_Volt[ch, i].ToString("F3");
                            msgbasic = msgbasic + "," + m_DAU_Volt[ch][i].ToString(Volt_Number_Digit);
                            //-
                        }

                        //for (int i = 0; i < m_DAU_Temp.GetLength(1); i++)
                        for (int i = 0; i < m_tempcount_dau[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_DAU_Temp[ch][i].ToString("F2");
                        }
                    }
                }

                if (m_BMSEnable)
                {
                    // if (m_BMS_Volt.GetLength(0) >= ch)
                    if (m_ucBMS_List.Count > ch)
                    {
                        // ----------------------------------
                        // PackVoltage 추가, 230922, BGH
                        // ----------------------------------
                        msgbasic = msgbasic + "," + m_ucBMS_List[ch].m_PackVolt.ToString("F3");

                        // for (int i = 0; i < m_BMS_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_bms[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_BMS_Volt[ch, i].ToString("F3");
                        }

                        //for (int i = 0; i < m_BMS_Temp.GetLength(1); i++)
                        for (int i = 0; i < m_tempcount_bms[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_BMS_Temp[ch, i].ToString("F2");
                        }
                    }
                }

                // -------------------------------
                // + BGH
                if (m_MBIEnable)
                {
                    if (m_ucMBI_List.Count >= ch)
                    {
                        for (int i = 0; i < m_voltcount_mbi[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_MBI_Volt[ch, i].ToString("F3");
                        }

                        for (int i = 0; i < m_tempcount_mbi[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_MBI_Temp[ch, i].ToString("F2");
                        }
                    }
                }

                if (m_ITDevEnable)
                {
                    if (m_ucIT_List.Count > ch)
                    {
                        msgbasic = msgbasic + "," + m_ucIT_List[ch].m_Result1stPhase + "," + m_ucIT_List[ch].m_Result2ndPhase;
                    }
                }

                if (m_tVOCEnable)
                {
                    //+ Revision by LBG - 240531 : MTVD 버전에 따라 데이터 로깅
                    if (m_iMTVD_Type == 0)
                    {
                        if (m_ucTVocSOCList.Count > ch)
                        {
                            msgbasic = msgbasic + "," + m_ucTVocSOCList[ch].tVoc_avgValue.ToString("F5");
                        }
                        else
                        {
                            msgbasic = msgbasic + ",0";
                        }
                    }

                    //if (m_ucTVocSOCList.Count > ch)
                    //{
                    //    msgbasic = msgbasic + "," + m_ucTVocSOCList[ch].tVoc_avgValue.ToString("F5");
                    //}
                    //else
                    //{
                    //    msgbasic = msgbasic + ",0";
                    //}
                    //-
                }

                if (m_powersupply)
                {
                    msgbasic = msgbasic + "," + m_ucPowerSupply_PT.SP_Voltage.ToString("F2") + "," + m_ucPowerSupply_PT.PV_Voltage.ToString("F2");
                }

                //+ Revision by YMJ - 250718 : CREVIS 디스플레이 방식 변경(Device 단위 -> CH 단위)
                //+ Add by YMJ - 250424 : CREVIS 장비 Logging 기능 추가
                if (m_CREVISEnable)
                {
                    if(m_ucCREVIS_List.Count > 0)
                    {
                        for (int i = 0; i < m_CREVIS_DEVISION; i++)
                        {
                            msgbasic = msgbasic + "," + m_CREVIS_Temp[ch, i].ToString("F3");
                        }
                    }
                }
                //-
                //-

                //+ Add by YMJ - 250716 : CAN Logging 기능 추가
                if (m_CANEnable)
                {
                    for (int i = 0; i < m_ucCAN_List[ch].CAN_List.Count; i++)
                    {
                        //+ Revision by YMJ - 250725 : CAN 초기 값일 경우 공란으로 로깅
                        if (m_ucCAN_List[ch].CAN_List[i].Value == -999999)
                        {
                            msgbasic = msgbasic + ",";
                        }
                        else
                        {
                            msgbasic = msgbasic + "," + m_ucCAN_List[ch].CAN_List[i].Value.ToString();
                        }
                        //-
                    }
                }
                //-
            }
            catch
            {
                msgbasic = msgbasic + ", logErr";
            }

            WriteBasicLogOut(ch, msgbasic);
            if (wStepResult)
            {
                // ----------------------------------
                // 마지막 데이터로 Step Result 기록
                // ----------------------------------
                WriteStepResLogOut(ch, msgbasic);
            }

            //+ Revision by YMJ - 250326 :충방전 관련 데이터만 기록하도록 추가 반영
            if (cyInfo.m_step.steptype != cls_stepInfo.enumStepType.MBT && cyInfo.m_step.steptype != cls_stepInfo.enumStepType.MCZ && cyInfo.m_step.steptype != cls_stepInfo.enumStepType.InsulationTest
                && cyInfo.m_step.steptype != cls_stepInfo.enumStepType.Wait_MBT && cyInfo.m_step.steptype != cls_stepInfo.enumStepType.Wait_MCZ && cyInfo.m_step.steptype != cls_stepInfo.enumStepType.Wait_InsulTest)
            {
                WriteCyclerLogOut(ch, msgcyclog);
            }
            //-
        }

        // --------------------------------------------------------------
        // EIS 측정시 EIS 데이터 생성되면 BasicLog 레코드 하나 생성
        // --------------------------------------------------------------
        public void WriteBasicLogwithNyquist(int ch, ACIR_TYPE acirtype)
        {
            //bool NoError = true;
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            try
            {
                try
                {
                    if (acirtype == ACIR_TYPE.MBT)
                    {
                        typelistacir[ch] = 1;
                        p_acirtype = ACIR_TYPE.MBT;
                    }
                    else
                    {
                        typelistacir[ch] = 2;
                        p_acirtype = ACIR_TYPE.MCZ;
                    }
                }
                catch { }

                if (m_bGraph_RT_ACIA)
                {
                    if (m_Graph_RT_ACIA != null)
                    {
                        if (acirtype == ACIR_TYPE.MBT)
                        {
                            if (m_Graph_RT_ACIA.graph_ChNo == ch)
                            {
                                m_Graph_RT_ACIA.Add_Value_Nyquist(m_ucMbT_List[ch].MeasureData.RE * 1000, m_ucMbT_List[ch].MeasureData.IM * 1000);
                                m_Graph_RT_ACIA.Add_Value_Bode(m_ucMbT_List[ch].MeasureData.freq, m_ucMbT_List[ch].MeasureData.Mag * 1000, m_ucMbT_List[ch].MeasureData.Ph);
                            }
                            else
                            {
                                if (m_iCur_CH_NO != m_Graph_RT_ACIA.graph_ChNo && m_iCur_CH_NO == ch)
                                {
                                    m_Graph_RT_ACIA.Change_ACIA(ch);
                                    PreProcessMxZ(ch);
                                }
                            }
                        }
                        else
                        {
                            if (m_Graph_RT_ACIA.graph_ChNo == ch)
                            {
                                m_Graph_RT_ACIA.Add_Value_Nyquist(m_ucMcz_List[ch].MeasureData.RE * 1000, m_ucMcz_List[ch].MeasureData.IM * 1000);
                                m_Graph_RT_ACIA.Add_Value_Bode(m_ucMcz_List[ch].MeasureData.freq, m_ucMcz_List[ch].MeasureData.Mag * 1000, m_ucMcz_List[ch].MeasureData.Ph);
                            }
                            else
                            {
                                if (m_iCur_CH_NO != m_Graph_RT_ACIA.graph_ChNo && m_iCur_CH_NO == ch)
                                {
                                    m_Graph_RT_ACIA.Change_ACIA(ch);
                                    PreProcessMxZ(ch);
                                }
                            }
                        }
                    }
                }
            }
            catch { }


            //try
            //{
            //    if (logReg[ch] == null) return;
            //}
            //catch
            //{
            //    NoError = false;
            //}

            //if (!NoError) return;


            // ------
            // Event로 호출되기에 Tick을 추가로 더해줘야함
            // ------
            AddTickStepAndTotalTime(ch, 2);


            // "Timestamp, Step, Mode, Voltage, Current, Capacity(Q), Energy(E), 
            string msgbasic = "";
            //string msgcyclog = "";

            cls_devCyclerABT.struCyclerStatus cyInfo = new cls_devCyclerABT.struCyclerStatus();
            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            cls_stepInfo.enumStepType eStepType;
            cls_stepInfo.enumStepMode eStepMode;

            cyInfo = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];

            if (cyInfo.isPaused) return;

            CurStInfo = m_ucStepInfo_List[ch];


            msgbasic = (boardid + 1).ToString() + "," + (ch + 1).ToString() + "," +       // Module, Channel, 
                        cyInfo.StartTime.ToString("yyyy-MM-dd HH:mm:ss") + "," +           // StartTime, 
                        DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "," +               // EndTime, 
                        CurStInfo.m_totCycle.ToString() + "," + CurStInfo.m_curCycle.ToString() + "," +     // Total Cycle, Current Cycle, 
                        (CurStInfo.m_currentStepNo + 1).ToString() + ",";                           // Step No, 
            try
            {
                // Step Type, STep Code, 

                eStepType = cyInfo.m_step.steptype;
                eStepMode = cyInfo.m_step.stepmode;

                //msgbasic = msgbasic + cyInfo.m_step.steptype.ToString();
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    switch (eStepType)
                    {
                        case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + "충전,"; break;
                        case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + "방전,"; break;
                        case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "휴지,"; break;
                        case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV,"; break;
                        case cls_stepInfo.enumStepType.Pattern:
                            msgbasic = msgbasic + "패턴,";
                            break;
                        default:
                            msgbasic = msgbasic + eStepType.ToString() + ","; break;
                    }
                }
                else
                {
                    msgbasic = msgbasic + eStepType.ToString() + ",";
                }


                if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING)
                {
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        msgbasic = msgbasic + "STEP종료,";
                    }
                    else
                    {
                        msgbasic = msgbasic + "StepEnd,"; //"Complete,";
                    }
                }
                else
                {
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        switch (eStepType)
                        {
                            //+ Revision by YMJ - 240523 : 충방전일 경우Step Code에 동작 모드 표기로 변경
                            case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + eStepMode + ","; break;
                            case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + eStepMode + ","; break;
                            //-
                            case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "휴지진행,"; break;
                            case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV진행,"; break;
                            case cls_stepInfo.enumStepType.Pattern:
                                msgbasic = msgbasic + "패턴진행[" + m_ucUDDS_List[ch].FetchNumber.ToString("D5") + "],";
                                break;
                            default: msgbasic = msgbasic + "작업진행,"; break;
                        }
                    }
                    else
                    {
                        switch (eStepType)
                        {
                            //+ Revision by YMJ - 240523 : 충방전일 경우Step Code에 동작 모드 표기로 변경
                            case cls_stepInfo.enumStepType.Charge: msgbasic = msgbasic + eStepMode + ","; break;
                            case cls_stepInfo.enumStepType.Discharge: msgbasic = msgbasic + eStepMode + ","; break;
                            //-
                            case cls_stepInfo.enumStepType.Rest: msgbasic = msgbasic + "Resting,"; break;
                            case cls_stepInfo.enumStepType.OCV: msgbasic = msgbasic + "OCV Resting,"; break;
                            case cls_stepInfo.enumStepType.Pattern:
                                msgbasic = msgbasic + "Pattern[" + m_ucUDDS_List[ch].FetchNumber.ToString("D5") + "],";
                                break;
                            default: msgbasic = msgbasic + "ING,"; break;
                        }
                    }
                }


                if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING)
                {

                    msgbasic = msgbasic + cyInfo.OGTime_Step_Final.Days.ToString("D2") + ":" + cyInfo.OGTime_Step_Final.Hours.ToString("D2") + ":" +
                                cyInfo.OGTime_Step_Final.Minutes.ToString("D2") + ":" + cyInfo.OGTime_Step_Final.Seconds.ToString("D2") + ":" +
                                cyInfo.OGTime_Step_Final.Milliseconds.ToString("D3") + ",";

                    msgbasic = msgbasic + CurStInfo.OGTime_Total_Final.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Hours.ToString("D2") + ":" +
                                            CurStInfo.OGTime_Total_Final.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Seconds.ToString("D2") + ":" +
                                            CurStInfo.OGTime_Total_Final.Milliseconds.ToString("D3") + ",";

                    //msgcyclog = CurStInfo.OGTime_Total_Final.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Hours.ToString("D2") + ":" +
                    //            CurStInfo.OGTime_Total_Final.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_Final.Seconds.ToString("D2") + ":" +
                    //            CurStInfo.OGTime_Total_Final.Milliseconds.ToString("D3") + ",";

                }
                else
                {
                    // Step Time, Total Time, 

                    msgbasic = msgbasic + cyInfo.OGTime_Step_4log.Days.ToString("D2") + ":" + cyInfo.OGTime_Step_4log.Hours.ToString("D2") + ":" +
                                          cyInfo.OGTime_Step_4log.Minutes.ToString("D2") + ":" + cyInfo.OGTime_Step_4log.Seconds.ToString("D2") + ":" +
                                          cyInfo.OGTime_Step_4log.Milliseconds.ToString("D3") + ",";


                    msgbasic = msgbasic + CurStInfo.OGTime_Total_4log.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Hours.ToString("D2") + ":" +
                                          CurStInfo.OGTime_Total_4log.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Seconds.ToString("D2") + ":" +
                                          CurStInfo.OGTime_Total_4log.Milliseconds.ToString("D3") + ",";

                    //msgcyclog = CurStInfo.OGTime_Total_4log.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Hours.ToString("D2") + ":" +
                    //            CurStInfo.OGTime_Total_4log.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Seconds.ToString("D2") + ":" +
                    //            CurStInfo.OGTime_Total_4log.Milliseconds.ToString("D3") + ",";
                }

                // --------------------------------------
                // CV Time logging
                // --------------------------------------
                if (enableCVTimelogging)
                {
                    if (cyInfo.isCVModeStarted)
                    {
                        msgbasic = msgbasic + cyInfo.CVTime.Hours.ToString("D2") + ":" + cyInfo.CVTime.Minutes.ToString("D2") + ":" + cyInfo.CVTime.Seconds.ToString("D2") + ":" + cyInfo.CVTime.Milliseconds.ToString("D3") + ",";
                    }
                    else
                    {
                        msgbasic = msgbasic + "00:00:00:000,";
                    }
                }

                if (cyInfo.m_STepStatus == cls_devCyclerABT.STEP_STATUS.FINISHING)
                {
                    // -
                    // Complete는 한번만.
                    // -
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.WHATEVER;
                }

                // InitV(V), Voltage(V), Current(A), Capacity(Ah), Energy(Wh), Power(W), 
                msgbasic = msgbasic + CurStInfo.LastInitVoltage.ToString("F3") + ",";
                //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                //msgbasic = msgbasic + cyInfo.Current_V.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.Current_V.ToString(Volt_Number_Digit) + ",";
                //-
                msgbasic = msgbasic + cyInfo.Current_I.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurStep_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurStep_E.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.Current_P.ToString("F3") + ",";

                // -
                //msgcyclog = msgcyclog + CurStInfo.m_currentStepNo.ToString() + ",";
                //msgcyclog = msgcyclog + cyInfo.m_step.steptype.ToString() + ",";
                //msgcyclog = msgcyclog + cyInfo.Current_V.ToString("F3") + ",";
                //msgcyclog = msgcyclog + cyInfo.Current_I.ToString("F3") + ",";
                //msgcyclog = msgcyclog + cyInfo.CurStep_Q.ToString("F3") + ",";
                //msgcyclog = msgcyclog + cyInfo.CurStep_E.ToString("F3") + ",";
                //msgcyclog = msgcyclog + cyInfo.Current_P.ToString("F3") + ",";

                //+ Revision by YMJ - 250325 : MBT, MxZ 측정 시 로그 빠진 부분 수정
                if (cyInfo.Current_T == 999.99)
                {
                    msgbasic = msgbasic + ",";
                }
                else
                {
                    msgbasic = msgbasic + cyInfo.Current_T.ToString("F3") + ",";
                }
                //-

                // ChargeCapacity(Ah), DischargeCapacity(Ah), ChargeEnergy(Wh), DischargeEnergy(Wh),
                msgbasic = msgbasic + cyInfo.CurrentCha_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentDisch_Q.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentCha_E.ToString("F3") + ",";
                msgbasic = msgbasic + cyInfo.CurrentDischa_E.ToString("F3"); // + ",";

                // Freq, Re, Im, Rs, Rct, T";
                //+ Revision by YMJ - 240304 : MBT 측정 대기 제한 제거
                //m_timelimit[ch] = 240;  // 4 min, Reset
                //-
                if (p_acirtype == ACIR_TYPE.MBT)
                {
                    msgbasic = msgbasic + ",";
                    msgbasic = msgbasic + m_ucMbT_List[ch].MeasureData.freq.ToString("F3") + ",";
                    msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.RE * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.IM * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Mag * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Rs * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMbT_List[ch].MeasureData.Rct * 1000.0).ToString("F5") + ",";
                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                    {
                        msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2");
                    }
                    else
                    {
                        msgbasic = msgbasic + " ";
                    }
                }
                else
                {
                    msgbasic = msgbasic + ",";
                    msgbasic = msgbasic + m_ucMcz_List[ch].MeasureData.freq.ToString("F3") + ",";
                    msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.RE * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.IM * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Mag * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Rs * 1000.0).ToString("F5") + ",";
                    msgbasic = msgbasic + (m_ucMcz_List[ch].MeasureData.Rct * 1000.0).ToString("F5") + ",";
                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                    {
                        msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2");
                    }
                    else
                    {
                        msgbasic = msgbasic + " ";
                    }
                }

                //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                if (m_ucChamber.EnableFlag)
                //if (m_clsSys_Set.m_bUse_Chamber && m_clsSys_Set.m_Sys_Chamber != null)
                {
                    //for (int i = 0; i < m_clsSys_Set.m_Sys_Chamber.Count(); i++)
                    //{
                    //if (m_clsSys_Set.m_Sys_Chamber[i].Chamber_Use)
                    //{
                    if (m_ucChamber.SP < -50.0f || m_ucChamber.SP > 100)
                    {
                        msgbasic = msgbasic + ",";
                        msgbasic = msgbasic + ",";
                    }
                    else
                    {
                        msgbasic = msgbasic + "," + m_ucChamber.SP.ToString("F2"); // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_SP.ToString("F2");
                        msgbasic = msgbasic + "," + m_ucChamber.PV.ToString("F2"); // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_PV.ToString("F2");
                    }
                }

                //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
                if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
                {
                    msgbasic = msgbasic + "," + m_ucChiller[ch].SP.ToString("F2");
                    msgbasic = msgbasic + "," + m_ucChiller[ch].PV.ToString("F2");
                    msgbasic = msgbasic + "," + m_ucChiller[ch].Flow_SP.ToString("f2");  // BGH
                    msgbasic = msgbasic + "," + m_ucChiller[ch].Flow_PV.ToString("f2");  // BGH
                }
                //-
                //-

                if (m_AUXEnable)
                {
                    bool isbaln = false;
                    if (m_ucBalancer_List != null)
                    {
                        if (m_ucBalancer_List.Count > ch)
                        {

                            if (m_ucBalancer_List[ch].ControlEnabled && m_ucBalancer_List[ch].isBalancing)
                            {
                                for (int i = 0; i < m_ucBalancer_List[ch].BalancingList.Length; i++)
                                {
                                    if (m_ucBalancer_List[ch].BalancingList[i] == 1)
                                    {
                                        isbaln = true;
                                        break;
                                    }
                                }
                            }

                        }
                    }

                    if (isbaln)
                    {
                        switch (m_ucBalancer_List[ch].BalancingResis)
                        {
                            case BALANCING_RESISTER_TYPE.R20: msgbasic = msgbasic + ", 20(Ω)"; break;
                            case BALANCING_RESISTER_TYPE.R40: msgbasic = msgbasic + ", 40(Ω)"; break;
                            case BALANCING_RESISTER_TYPE.R60: msgbasic = msgbasic + ", 60(Ω)"; break;
                        }

                        for (int i = 0; i < m_ucBalancer_List[ch].BalancingList.Length; i++)
                        {
                            if (m_ucBalancer_List[ch].BalancingList[i] == 1)
                            {
                                msgbasic += ((i + 1).ToString() + "/");
                            }
                        }
                    }
                    else
                    {
                        msgbasic = msgbasic + ",";
                    }

                    if (m_NumOfAUX > ch)
                    {
                        for (int i = 0; i < m_voltcount_aux[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_AUX_Volt[ch, i].ToString("F3");
                        }

                        for (int i = 0; i < m_tempcount_aux[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_AUX_Temp[ch, i].ToString("F3");
                        }
                    }
                }

                if (m_DAUEnable)
                {
                    //if (m_NumOfDAU > ch)
                    {
                        for (int i = 0; i < m_voltcount_dau[ch]; i++)
                        {
                            //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                            //msgbasic = msgbasic + "," + m_DAU_Volt[ch, i].ToString("F3");
                            msgbasic = msgbasic + "," + m_DAU_Volt[ch][i].ToString(Volt_Number_Digit);
                            //-
                        }

                        for (int i = 0; i < m_tempcount_dau[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_DAU_Temp[ch][i].ToString("F2");
                        }
                    }
                }

                if (m_BMSEnable)
                {
                    if (m_NumOfBMS > ch)
                    {
                        for (int i = 0; i < m_voltcount_bms[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_BMS_Volt[ch, i].ToString("F3");
                        }

                        for (int i = 0; i < m_tempcount_bms[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_BMS_Temp[ch, i].ToString("F2");
                        }
                    }
                }

                // -------------------------------
                // + BGH
                if (m_MBIEnable)
                {
                    if (m_ucMBI_List.Count >= ch)
                    {
                        for (int i = 0; i < m_voltcount_mbi[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_MBI_Volt[ch, i].ToString("F3");
                        }

                        for (int i = 0; i < m_tempcount_mbi[ch]; i++)
                        {
                            msgbasic = msgbasic + "," + m_MBI_Temp[ch, i].ToString("F2");
                        }
                    }
                }


                if (m_ITDevEnable)
                {
                    if (m_ucIT_List.Count > ch)
                    {
                        msgbasic = msgbasic + "," + m_ucIT_List[ch].m_Result1stPhase + "," + m_ucIT_List[ch].m_Result2ndPhase;
                    }
                }


                if (m_tVOCEnable)
                {
                    if (m_ucTVocSOCList.Count > ch)
                    {
                        msgbasic = msgbasic + "," + m_ucTVocSOCList[ch].tVoc_avgValue.ToString("F5");
                    }
                    else
                    {
                        msgbasic = msgbasic + ",0";
                    }
                    
                }

                if (m_powersupply)
                {
                    msgbasic = msgbasic + "," + m_ucPowerSupply_PT.SP_Voltage.ToString("F2") + "," + m_ucPowerSupply_PT.PV_Voltage.ToString("F2");
                }
            }
            catch
            {
                msgbasic = msgbasic + " logErr";
            }
            WriteBasicLogOut(ch, msgbasic);
            //WriteCyclerLogOut(ch, msgcyclog);

            //m_eStepType[ch] = cyInfo.m_step.steptype;
            //m_eStepMode[ch] = cyInfo.m_step.stepmode;
            //+ Revision by LBG - 231201 : 채널 상세 정보 업데이트 일시 막음
            //ReNewChDispInformation(ch);
            //-
        }

        private void WriteBasicLogOut(int ch, string msg)
        {
            bool NoError = true;
            try
            {
                if (logReg[ch] == null) return;
            }
            catch
            {
                NoError = false;
            }
            if (!NoError) return;

            try
            {
                logReg[ch].WriteLine(msg);
                logReg[ch].Flush();

                //+ Add by LBG - 230911 : Basic Log의 용량 단위로 파일을 나누기 위해 신규 파일명으로 교체 및 Writer 생성
                if (m_dicBasicLog_Path != null && m_dicBasicLog_Path.ContainsKey(ch))
                {
                    if (File.Exists(m_dicBasicLog_Path[ch]))
                    {
                        FileInfo n_FileInfo = new FileInfo(m_dicBasicLog_Path[ch]);

                        if (m_clsAppSet.Logging_Set.Basic_Use)
                        {
                            if (n_FileInfo.Length >= m_clsAppSet.Logging_Set.Basic_Size) // 파일 용량이 지정된 용량을 넘을 경우 확인, 기본 300MB로 설정됨
                            {
                                string n_sFilePath  = m_dicBasicLog_Path[ch];
                                string[] n_sSplit   = n_sFilePath.Split('\\');
                                string[] n_sSplit_2 = n_sSplit[n_sSplit.Length - 1].Split('_');

                                //+ Revision by YMJ - 240513 : 분할 저장된 데이터 파일 처리 포멧 수정
                                string n_sOldNumber = n_sSplit_2[n_sSplit_2.Length - 1].Replace("Datalog","").Replace(".csv","");
                                //-

                                int n_iFileCnt      = -1;

                                if (int.TryParse(n_sOldNumber, out n_iFileCnt))
                                {
                                    string n_sNewNumber = (n_iFileCnt + 1).ToString("00");
                                    //+ Revision by YMJ - 240513 : 분할 저장된 데이터 파일 처리 포멧 수정
                                    string n_sReplace = n_sSplit_2[n_sSplit_2.Length - 1].Replace(n_sOldNumber, n_sNewNumber);
                                    n_sSplit_2[n_sSplit_2.Length - 1] = n_sReplace;
                                    //-
                                    string n_sFileNmae = string.Join("_", n_sSplit_2);

                                    //string n_sReplace = n_sSplit[n_sSplit.Length - 1].Replace(n_sOldNumber, n_sNewNumber);
                                    n_sSplit[n_sSplit.Length - 1] = n_sFileNmae;

                                    string n_sPathRes = string.Join("\\", n_sSplit);

                                    m_dicBasicLog_Path[ch] = n_sPathRes;

                                    logReg[ch].Close();
                                    logReg[ch] = null;

                                    logReg[ch] = new StreamWriter(n_sPathRes, true, System.Text.Encoding.UTF8);

                                    if (m_dicBasicLog_Header != null && m_dicBasicLog_Header.ContainsKey(ch))
                                    {
                                        logReg[ch].WriteLine(m_dicBasicLog_Header[ch]);
                                        logReg[ch].Flush();
                                    }
                                }
                            }
                        }
                    }
                }
                //-
            }
            catch { }
        }

        private void WriteStepResLogOut(int ch, string msg)
        {
            bool NoError = true;
            try
            {
                if (logStepRes[ch] == null) return;
            }
            catch
            {
                NoError = false;
            }
            if (!NoError) return;

            try
            {
                logStepRes[ch].WriteLine(msg);
                logStepRes[ch].Flush();
            }
            catch { }
        }

        // ghbaik
        private void WriteCyclerLogOut(int ch, string msg)
        {
            bool NoError = true;

            try
            {
                if (logCycler[ch] == null) return;
            }
            catch
            {
                NoError = false;
            }
            if (!NoError) return;

            try
            {
                logCycler[ch].WriteLine(msg);
                logCycler[ch].Flush();
            }
            catch { }
        }

        private void CloseCyclerLog(int ch)
        {
            try
            {
                if (logCycler[ch] != null) logCycler[ch].Close();
                if (cfile[ch] != null) cfile[ch].Close();
            }
            catch { }

            try
            {
                logCycler[ch] = null;
                logCyclerPath[ch] = "";
                cfile[ch] = null;
            }
            catch { }
        }
        ////+ Add by LBG : Cycler Step End Data 기록 부분 추가
        public void WriteCyclerResOut(int ch, string msg)
        {
            bool NoError = true;
            //int rlchno = GetChNumber(ch); //, U_CBOARD_TYPE.FIND_BOARDNo_Using_Ch);
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            try
            {
                if (logCyclerRes[ch] == null) return;
            }
            catch
            {
                NoError = false;
            }

            if (!NoError) return;

            try
            {
                if (msg == "")
                {
                    // "Timestamp, Step, Mode, Voltage, Current, Capacity(Q), Energy(E), Freq, Re, Im, Rs, Rct";
                    string msgbasic = "";
                    CurStInfo = m_ucStepInfo_List[ch];

                    //msgbasic = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + ",";
                    msgbasic = CurStInfo.OGTime_Total_4log.Days.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Hours.ToString("D2") + ":" +
                              CurStInfo.OGTime_Total_4log.Minutes.ToString("D2") + ":" + CurStInfo.OGTime_Total_4log.Seconds.ToString("D2") + ":" +
                              CurStInfo.OGTime_Total_4log.Milliseconds.ToString("D3") + ",";

                    //+ Add by YMJ - 240115 : Cycler 파일에 Current Cycle, Total Cycle 추가
                    msgbasic = msgbasic + CurStInfo.m_curCycle.ToString() + "," + CurStInfo.m_totCycle.ToString() + ",";
                    //-

                    msgbasic = msgbasic + (m_ucStepInfo_List[ch].m_currentStepNo + 1).ToString() + ",";
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype.ToString() + ",";

                    //+ Revision by LBG - 231016 : 전압 소수점 표시 단위 옵션화로 인한 변경 (LGES 요청사항)
                    //msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V.ToString("F3") + ",";
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V.ToString(Volt_Number_Digit) + ",";
                    //-
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I.ToString("F3") + ",";
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q.ToString("F3") + ",";
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_E.ToString("F3") + ",";
                    msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_P.ToString("F3") + ",";

                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T > -50 &&
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                    {
                        msgbasic = msgbasic + m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T.ToString("F2");
                    }
                    else
                    {
                        msgbasic = msgbasic + " ";
                    }

                    logCyclerRes[ch].WriteLine(msgbasic);
                }
                else
                {
                    logCyclerRes[ch].WriteLine(msg);
                }
                logCyclerRes[ch].Flush();
            }
            catch { }
        }
        //-

        // -------------------------------------
        // ghbaik
        // -------------------------------------
        private void CloseLog(int ch)
        {
            try
            {
                if (logReg[ch] != null) logReg[ch].Close();
            }
            catch { }

            try
            {
                logReg[ch] = null;
            }
            catch { }
        }

        // -------------------------------------
        // ghbaik
        // -------------------------------------
        private void CloseStepResLog(int ch)
        {
            try
            {
                if (logStepRes[ch] != null) logStepRes[ch].Close();
            }
            catch { }

            try
            {
                logStepRes[ch] = null;
            }
            catch { }
        }

        // -------------------------------------
        // ghbaik
        // -------------------------------------
        private void CloseCyclerResLog(int ch)
        {
            try
            {
                if (logCyclerRes[ch] != null) logCyclerRes[ch].Close();
            }
            catch { }

            try
            {
                logCyclerRes[ch] = null;
            }
            catch { }
        }

        
        // ------------------------------------------------
        //
        // ------------------------------------------------
        public void WriteSystemLog(string m_msg)
        {
            bool NoError = true;

            try { if (logSystem == null) return; }
            catch { NoError = false; }
            if (!NoError) return;

            try
            {
                if (logSystem != null)
                {
                    if (m_days != DateTime.Now.Day)
                    {
                        OpenSystemLog();
                    }
                    m_syslog_list.Add(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + " :: " + m_msg);
                }
            }
            catch { }
        }

        private void WriteSystemLog(int ch, string m_msg, bool DispVIinfo)
        {
            bool NoError = true;

            try { if (logSystem == null) return; }
            catch { NoError = false; }
            if (!NoError) return;

            try
            {
                if (DispVIinfo)
                {
                    int boardid = Board_Ch_Mapping[ch];  // ghbaik
                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

                    //+ Revision by LBG - 231117 : 통신이 끊어 졌다가 재 접속을 하게되면 Null이여서 Exception 발생, 발생하지 않도록 조치
                    //double vvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                    //double ivalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                    //double cvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q;

                    double vvalue = -1;
                    double ivalue = -1;
                    double cvalue = -1;

                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                    {
                        vvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;
                        ivalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;
                        cvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q;
                    }
                    //-

                    m_syslog_list.Add(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + " :: Ch=" + (ch + 1).ToString() + " " +
                                                                                         "[V=" + vvalue.ToString(Volt_Number_Digit) + "(V)," +
                                                                                         "I=" + ivalue.ToString("F3") + "(A)," +
                                                                                         "Q=" + cvalue.ToString("F3") + "(Ah)], " + m_msg);
                    //logSystem.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + ", Ch=" + (ch + 1).ToString() + " " +
                    //                                                                     "[V=" + vvalue.ToString("F3") + "V," +
                    //                                                                     "[I=" + vvalue.ToString("F3") + "A," +
                    //                                                                     "[Q=" + cvalue.ToString("F3") + "Ah], " + m_msg);
                }
                else
                {
                    m_syslog_list.Add(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + " :: Ch=" + (ch + 1).ToString() + " " + m_msg);
                    //logSystem.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + ", Ch=" + (ch + 1).ToString() + ", " + m_msg);
                }
                //logSystem.Flush();
            }
            catch { }
        }

        private void CloseSystemLog()
        {
            {
                try
                {
                    if (logSystem != null)
                    {
                        for (int i = 0; i < m_syslog_list.Count(); i++)
                        {
                            logSystem.WriteLine(m_syslog_list[i]);
                            logSystem.Flush();
                        }
                        m_syslog_list.Clear();
                        logSystem.Close();
                    }
                }
                catch { }

                try
                {
                    logSystem = null;
                }
                catch { }
            }
        }
        
        public void OpenSystemLog()
        {
            if (logSystem != null)
            {
                CloseSystemLog();
            }

            string fldpath = Application.StartupPath + "\\System\\Syslog\\" + DateTime.Now.ToString("yyyy_MM_dd");
            try
            {
                DirectoryInfo di = new DirectoryInfo(fldpath);
                if (di.Exists == false)
                {
                    di.Create();
                }
            }
            catch { }

            fldpath = fldpath + "\\Systemlog_" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".log";
            logSystem = new StreamWriter(fldpath, true, System.Text.Encoding.UTF8);
            m_days = DateTime.Now.Day;
        }

        // ------------------------------------------------
        //
        // ------------------------------------------------
        private void WriteAlarmLog(string m_msg)
        {
            bool NoError = true;

            try
            {
                if (logAlarm == null) return;
            }
            catch
            {
                NoError = false;
            }
            if (!NoError) return;

            try
            {
                logAlarm.WriteLine(m_msg);
                logAlarm.Flush();
            }
            catch { }
        }
        private void WriteAlarmLog(int ch, int code, string m_type, string m_msg)
        {
            bool NoError = true;

            try
            {
                if (logAlarm == null) return;
            }
            catch
            {
                NoError = false;
            }
            if (!NoError) return;

            try
            {
                string chstr = "";
                // ------------------
                // ch 번호가 음수일경우는, 특정 채널 알람이 아닌 System 전체에 대한 알람.
                // ------------------
                if (ch >= 0) chstr = (ch + 1).ToString();
                else chstr = "";

                string msg = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "," + chstr + "," +
                             code.ToString() + "," + m_type + "," + m_msg;
                logAlarm.WriteLine(msg);
                logAlarm.Flush();
            }
            catch { }
        }
        private void CloseAlarmLog()
        {
            try
            {
                if (logAlarm != null) logAlarm.Close();
            }
            catch { }

            try
            {
                logAlarm = null;
            }
            catch { }
        }

        // --------------------------------------------------------------------------------
        //
        // --------------------------------------------------------------------------------
        public void EndTest(int ch)
        {
            IsActivateEnding[ch] = 1;
        }

        //public void EndTest2ndStep(int ch, bool beStopped), 사용하지 않는 파라미터 제거 230911
        public void EndTest2ndStep(int ch)
        {
            WriteSystemLog(ch, "End Work", false);

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            // ----------------------------
            // 실행중인 스케쥴이 없다면 종료
            // ----------------------------
            if (!IsOnTesting[ch])
            {
                WriteSystemLog(ch, ">> Is not on test", true);
                return;
            }

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> Work End Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            // ------------------------------------------
            // 필요하다면 Timer 죽일것.
            // -----------------------------------------
            IsOnTesting[ch] = false; // 다시 false로 복구

            // ----------------------------
            // 전압이 안 떠있으면 의미 없음.
            // ----------------------------
            try
            {
                if (isChannelAlived(ch))
                {
                    m_ucCycler_ABT_List[boardid].ClearStatusFlag(bzch);
                    m_ucCycler_ABT_List[boardid].ForceToStandByABT(bzch);
                }
                // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = cls_stepInfo.enumStepType.STANDBY;
            }
            catch { }

            try
            {
                m_ucUDDS_List[ch].boolForceExit = true;
            }
            catch { }

            try
            {
                if (m_ucMbT_List[ch].isConnected)
                {                    
                    m_ucMbT_List[ch].STOPAcia();                
                    m_ucMbT_List[ch].DisCoNnect();
                }
            }
            catch { }

            try
            {
                //+ Revisioin by YMJ - 250213 : MxZ 정지 및 연결 종료 변경
                if (m_ucMcz_List[ch].isConnected)
                {
                    m_ucMcz_List[ch].StopACIR();
                    m_ucMcz_List[ch].DisConnect();
                }
                //-
            }
            catch { }

            // 231227, BGH
            try
            {
                typelistacir[ch] = 0;  // 231205 BGH

                if (m_ucMbT_List != null && m_ucMbT_List.Count > ch) m_ucMbT_List[ch].SetMeasureDataNUll();
                if (m_ucMcz_List != null && m_ucMcz_List.Count > ch) m_ucMcz_List[ch].SetMeasureDataNUll();
            }
            catch { }
            // -


            if (m_ucChamber.isConnected)
            {
				m_ucChamber.RemoveCh(ch);
				if (m_ucChamber.GetCount() == 0)
				{
					m_ucChamber.StopAction();
                    Thread.Sleep(100);
					// m_ucChamber.StopSerial();
					m_ucChamber.DoesWorking = false;
                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                    m_ucChamber.SP = -0; // -100; // -100.0f;
                    m_ucChamber.HUMIDITY_S = 0;
                    //-
                    // -------------------------
                    // 230917, BGH
                    ResetChamberMaintainSetting();
                }
            }

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            //if (m_ucChiller.isConnected)
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].isConnected)
            {
                m_ucChiller[ch].StopAction();
                Thread.Sleep(100);
                //m_ucChiller[ch].StopSerial();
                m_ucChiller[ch].SP = 999.99; // 999.99f;
            }
            //-
            //-

            //+ Revision by YMJ - 250716 : CAN 사용 중인 스텝에서만 연결되도록 변경하여 해당 항목 삭제
            /*// -----------------------------------------
            // CAN
            // -----------------------------------------
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
            {
                if (m_ucCAN_List[ch].ControlEnabled && m_ucCAN_List[ch].isConnected)
                {
                    //+ Revision by YMJ - 241018 : CAN 정보 상시 디스플레이 시 캔 리스트 리셋 및 캔통신 정지 제거
                    if (!m_ucCAN_List[ch].AlwaysLog)
                    {
                        if (m_ucCAN_List[ch].CAN_List != null) m_ucCAN_List[ch].Reset_DBCList();
                        m_ucCAN_List[ch].StopPCANComm();
                    }
                    //-

                    if(m_CANTXSend !=null) 
                    {
                        m_CANTXSend[ch] = false;
                    }
                }
            }*/
            //-

            // -------------------------------
            // 231027, BGH
            // -------------------------------
            if (m_clsAppSet.Enable_Set.Enable_Insulate && m_ITDevEnable && m_NumOfIT > ch)
            {
                if (m_ucIT_List != null)
                {
                    //+ Revision by YMJ - 240613 : 절연저항기 class 수정
                    //if (m_ucIT_List[ch].ControlEnabled && m_ucIT_List[ch].m_IsConnected)
                    if (m_ucIT_List[ch].ControlEnabled && m_ucIT_List[ch].IsConnected)
                    //-
                    {
                        //+ add by KGY - 240729 : 작업종료시 절연저항기 정지명령 추가
                        if (m_ucIT_List[ch].IsMeasuring)
                        {
                            m_ucIT_List[ch].InsTestStop();
                        }
                        //-
                        m_ucIT_List[ch].InsDisConnected();
                    }
                }
            }


            if (m_ucStepInfo_List == null) { return; }
            if (m_ucStepInfo_List.Count <= ch) { return; }

            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            try
            {
                CurStInfo = m_ucStepInfo_List[ch];

                if (CurStInfo == null) { return; }
                if (CurStInfo.m_currentStepNo < 0) { return; }
            }
            catch
            {
            }

            // -------------------------------------
            // Pattern 중간에 세울때
            // -------------------------------------
            if (m_ucStepInfo_List[ch].m_steplist[m_ucStepInfo_List[ch].m_currentStepNo].steptype == cls_stepInfo.enumStepType.Pattern)
            {
                if (m_ucUDDS_List[ch].isConnected) m_ucUDDS_List[ch].STOPPattern();
            }


            CurStInfo.TestEndTime = DateTime.Now;

            //cls_stepInfo.struStep _mstep = new cls_stepInfo.struStep();
            //_mstep = CurStInfo.m_steplist[CurStInfo.m_currentStepNo];
            //_mstep.steptype = cls_stepInfo.enumStepType.STANDBY;
            //CurStInfo.m_steplist[CurStInfo.m_currentStepNo] = _mstep;

            m_ucStepInfo_List[ch] = CurStInfo;

            // -------------------------------------------
            // Safety 처리
            // 현 채널과 관련있는 알람들을 리스트에서 제거
            // -------------------------------------------
            RemoveAlarm(ch);

            // --------------------------
            // TOS
            // --------------------------
            if (!tos_iswritting)
            {
                WriteTOSLog(ch);
            }

            // -----------------------------------------
            //
            // -----------------------------------------
            if (m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].isConnected)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                        m_ucBalancer_List[ch].isBalancing = false;
                        m_ucBalancer_List[ch].SendBalancingOffCmd();
                    }
                }
            }

            // -----------------------------
            // ghbaik            
            // -----------------------------
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);

            // ------------------------------------------------
            // 마지막 레코드는 표시 안해도 됨. 20230820, BGH
            // ------------------------------------------------
            //AddTickStepAndTotalTime(ch, 0);
            //WriteBasicLog(ch, "TestEnd");
            //WriteStepResLog(ch, "", ABT.eNUM_CutOFF_Type.NONE);


            // ---------------------
            // 
            // ---------------------
            //m_dispChStatus.ch_s_Step_Type = STEP_TYPE.WORK_END;
            //m_CurChStatusInfo.CH_StepType = STEP_TYPE.WORK_END;
            //m_dispChStatus.isTesting = false;

            //m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            //if (m_clsAppSet.Enable_Set.Chanel_Info_UI_Type == CH_INFO_UI_TYPE.Normal)
            //{
            //    m_ucChannel_Status.Display_Data_ChOnly(ch);
            //}
            //else
            //{
            //    // 40 Ch짜리 갱신파트
            //}

            // 230917, BGH
            // 종료하는 순간이 너무 짧으므로, 표시하는게 의미가 없다.
            // ReNewChDispInformation(ch);

            logCond[ch] = 0;
            logBuff[ch] = 0;

            CloseLog(ch);
            CloseStepResLog(ch);
            CloseCyclerLog(ch);
            CloseCyclerResLog(ch);

            IsActivateEnding[ch] = 0;

            CurStInfo.m_currentStepNo = -1;
            m_ucStepInfo_List[ch] = CurStInfo;

            
            WriteSystemLog(ch, "End Work", true);

            // ------------------------------------------
            // 이곳으로 이동
            // BGH
            // 230917, 종료상태 표시위해 isTesting을 뒤에 false로 설정
            // ------------------------------------------
            // 231115 BGH
            
            m_dispChStatus.isChamberWarming = false; 
            m_dispChStatus.ch_s_Step_Type = STEP_TYPE.WORK_END;


            m_CurChStatusInfo.CH_isPaused = false;           // 231115 BGH
            m_CurChStatusInfo.CH_isChamberWarming = false;   // 231115 BGH
            m_CurChStatusInfo.CH_StepType = STEP_TYPE.WORK_END;

            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            if (m_clsAppSet.Enable_Set.Chanel_Info_UI_Type == CH_INFO_UI_TYPE.Normal)
            {
                m_ucChannel_Status.Display_Data_ChOnly(ch);
            }
            else
            {
                // 40 Ch짜리 갱신파트
            }

            // 231115 BGH
            m_dispChStatus.ch_s_isPaused = false;


            m_dispChStatus.isTesting = false;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

            // ---------------------
            // 
            // ---------------------
            m_ucChannel_Status.SaveChannelStatus();
            //
            // --

            // -----------------------------------------------
            // 231027 BGH
            // -----------------------------------------------
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = cls_stepInfo.enumStepType.WORK_END;

            if (m_DataFilePath != null)
            {
                string fldpath = Application.StartupPath + "\\Data\\" + work_names[ch];
                string desfldpath = Path.Combine(m_DataFilePath, work_names[ch]);

                if (!Directory.Exists(m_DataFilePath))
                {
                    Directory.CreateDirectory(m_DataFilePath);
                }

                CopyDirectory(fldpath, desfldpath);
            }
        }

        void CopyDirectory(string sourceDir, string destinationDir)
        {
            if (!Directory.Exists(destinationDir))
                Directory.CreateDirectory(destinationDir);

            foreach (string file in Directory.GetFiles(sourceDir))
            {
                string destFile = Path.Combine(destinationDir, Path.GetFileName(file));
                File.Copy(file, destFile, true);
            }

            foreach (string subdir in Directory.GetDirectories(sourceDir))
            {
                string destSubDir = Path.Combine(destinationDir, Path.GetFileName(subdir));
                CopyDirectory(subdir, destSubDir);
            }
        }

        // ---------------------------------------------------
        // ch : channel number, base 0 (+1 to display)
        // 231116, 종료시에는 startCurrentStep() 실행안함.
        // ---------------------------------------------------
        // public void EndCurrentStep(int ch, eNUM_CutOFF_Type cotype)
        public void EndCurrentStep(int ch, eNUM_CutOFF_Type cotype, bool m_forceEnding = false)
        {
            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> End test Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);

            // ----------------------------------------
            // Pattern 중간에 종료하면, End 뒤에 Step ENd가 오므로 이런경우엔 
            // 이 함수 수행할 필요 없음
            // ----------------------------------------
            if (m_ucStepInfo_List[ch].m_currentStepNo < 0) return;

            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isRisedUp = false;

            // ----------------------------------------
            // Chamber Waiting 돌고있다면 false로, 230905 BGH
            // ----------------------------------------
            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_MaintainUse)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_MaintainUse = false;

                // +
                // 230911 아래 2줄 추가, BGH
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_Enable = false;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = false;

                // 231204, BGH
                ResetChamberMaintainSetting();
            }
            
            WriteSystemLog(ch, ">> End Step", true);
            try
            {
                // delay logging
                logBuff[ch] = logCond[ch];
            }
            catch { }
             
            // ------------------------------------------
            // 필요하다면 Timer 죽일것.
            // 예를들어, ACIA 타이머 같은것.
            // ------------------------------------------
            balancingActivated[ch] = 0;

            if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return; }
            if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return; }

            // ------------------------
            //
            // ------------------------
            if (m_ucStepInfo_List[ch].m_steplist[m_ucStepInfo_List[ch].m_currentStepNo].steptype > cls_stepInfo.enumStepType.CYCLE_END &&
                m_ucStepInfo_List[ch].m_steplist[m_ucStepInfo_List[ch].m_currentStepNo].steptype < cls_stepInfo.enumStepType.WORK_END)
            {
                m_ucChannel_Status.SaveChannelStatus();
            }
            ClearStatusFlag(ch);


            // ---------------------
            // Pattern 중간에 세울때
            // ---------------------
            if (m_ucUDDS_List[ch].isConnected || (m_ucStepInfo_List[ch].m_steplist[m_ucStepInfo_List[ch].m_currentStepNo].steptype == cls_stepInfo.enumStepType.Pattern))
            {
                m_ucUDDS_List[ch].ENdPattern();
            }

            if (m_ucMbT_List[ch].isConnected)
            {
                m_ucMbT_List[ch].STOPAcia();
                m_ucMbT_List[ch].DisCoNnect();
                //+ Add by YMJ - 240613 : MBT 스텝 종료 시 Status_Restart 관련 bool 값 초기화
                m_ucMbT_List[ch].Status_Restart = false;
                m_ucMbT_List[ch].Read_status_Restart = false;
                //-
                //+ Add by YMJ - 240621 : Comm Restart 초기화 추가
                m_ucMbT_List[ch].Comm_Restart = false;
                //-
            }

            if (m_ucMcz_List[ch].isConnected)
            {
                //+ Revisioin by YMJ - 250213 : MxZ 정지 및 연결 종료 변경
                m_ucMcz_List[ch].StopACIR();
                m_ucMcz_List[ch].DisConnect();
                //-
            }

            if (m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].isBalancing)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                        m_ucBalancer_List[ch].isBalancing = false;
                        m_ucBalancer_List[ch].SendBalancingOffCmd();
                    }
                }
            }

            // -------------------------------
            // 231027, BGH
            // -------------------------------
            if (m_clsAppSet.Enable_Set.Enable_Insulate && m_ITDevEnable && m_NumOfIT > ch)
            {
                if (m_ucIT_List != null)
                {
                    //+ Revision by YMJ - 240613 : 절연저항기 class 수정
                    //if (m_ucIT_List[ch].ControlEnabled && m_ucIT_List[ch].m_IsConnected)
                    if (m_ucIT_List[ch].ControlEnabled && m_ucIT_List[ch].IsConnected)
                    //-
                    {
                        //+ add by KGY - 240729 : 작업종료시 절연저항기 정지명령 추가
                        if (m_ucIT_List[ch].IsMeasuring)
                        {
                            m_ucIT_List[ch].InsTestStop();
                        }
                        //-
                        m_ucIT_List[ch].InsDisConnected();
                    }
                }
            }

            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            cls_stepInfo.struStep _mstep = new cls_stepInfo.struStep();

            try
            {
                CurStInfo = m_ucStepInfo_List[ch];

                if (CurStInfo == null) { EndTest2ndStep(ch); return; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return; }

                // ghbaik
                if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].steptype == cls_stepInfo.enumStepType.MBT ||
                    CurStInfo.m_steplist[CurStInfo.m_currentStepNo].steptype == cls_stepInfo.enumStepType.MCZ)
                {
                    if (m_Graph_RT_ACIA != null)
                    {
                        if (m_bGraph_RT_ACIA)
                        {
                            m_Graph_RT_ACIA.nyqu_activeIndex++;
                            m_Graph_RT_ACIA.bodeZ_activeIndex++;
                            m_Graph_RT_ACIA.bodeT_activeIndex++;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[CurrentStepEnd::3817] - " + ex.Message);
                EndTest2ndStep(ch);
                return;
            }

            // -----------------------------
            // 여기로 이동
            // -----------------------------
            try
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = false;
                _mstep = CurStInfo.m_steplist[CurStInfo.m_currentStepNo];

                // --------------------------------------------------------------
                // 231116 BGH
                // 231119 BGH : Wait_Charge, Wait_Discharge 모드 추가
                // --------------------------------------------------------------
                if (_mstep.steptype == cls_stepInfo.enumStepType.Charge || _mstep.steptype == cls_stepInfo.enumStepType.Discharge ||
                    _mstep.steptype == cls_stepInfo.enumStepType.Wait_Charge || _mstep.steptype == cls_stepInfo.enumStepType.Wait_Discharge)
                {
                    _mstep.cmmu_Qh = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_Q;
                    _mstep.cmmu_Wh = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].CurStep_E;
                    CurStInfo.m_steplist[CurStInfo.m_currentStepNo] = _mstep;

                    // Debug.WriteLine("COMQ_2 : " + _mstep.cmmu_Qh.ToString());
                }

                // --------------------------------------------------------------
                // Pause 상태에서 스텝을 종료하거나 다음 스텝으로 넘어가는 경우
                // BGH, 231115
                // --------------------------------------------------------------
                if (!CurStInfo.isTempPaused)
                {
                    //+ Add by LBG : Step 종료시 Cycler Data 별도 저장
                    if (_mstep.steptype == cls_stepInfo.enumStepType.Rest || _mstep.steptype == cls_stepInfo.enumStepType.OCV || 
                        _mstep.steptype == cls_stepInfo.enumStepType.Charge || _mstep.steptype == cls_stepInfo.enumStepType.Discharge || _mstep.steptype == cls_stepInfo.enumStepType.Pattern || 
                        _mstep.steptype == cls_stepInfo.enumStepType.MBT || _mstep.steptype == cls_stepInfo.enumStepType.MCZ || 
                        _mstep.steptype == cls_stepInfo.enumStepType.InsulationTest)
                    {
                        // ---
                        // Cycler Log
                        // ---
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.FINISHING;

                        AddTickStepAndTotalTime(ch, 0);
                        // WriteBasicLog(ch, "", cotype, true);
                        WriteBasicLog(ch, "", cotype, true, true);
                        logBuff[ch] = logCond[ch];

                        // ----------------------------------------------
                        // STep Result
                        // ----------------------------------------------
                        // WriteStepResLog(ch, "", cotype);
                        // STep Result 데이터는 BasicLog 기록시에 같이 함.
                        // ----------------------------------------------
                        //+ Revision by YMJ - 250326 :충방전 관련 데이터만 기록하도록 추가 반영
                        if (_mstep.steptype != cls_stepInfo.enumStepType.MBT && _mstep.steptype != cls_stepInfo.enumStepType.MCZ && _mstep.steptype != cls_stepInfo.enumStepType.InsulationTest
                            && _mstep.steptype != cls_stepInfo.enumStepType.Wait_MBT && _mstep.steptype != cls_stepInfo.enumStepType.Wait_MCZ && _mstep.steptype != cls_stepInfo.enumStepType.Wait_InsulTest)
                        //-
                        {
                            WriteCyclerResOut(ch, "");
                        }

                        // -
                        // Time Reset
                        // -
                        AddTickStepAndTotalTime(ch, 3);

                    }
                }
                else
                {
                    // --------------------------------------------------------------
                    // Pause 상태에서 스텝을 종료하거나 다음 스텝으로 넘어가는 경우
                    // BGH, 231115
                    // --------------------------------------------------------------
                    if (_mstep.steptype > cls_stepInfo.enumStepType.CYCLE_END && 
                        _mstep.steptype < cls_stepInfo.enumStepType.WORK_END)
                    {
                        // ---
                        // Cycler Log
                        // ---
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.FINISHING;

                        AddTickStepAndTotalTime(ch, 0);
                        //WriteBasicLog(ch, "", cotype, true);
                        WriteBasicLog(ch, "", cotype, true, true);
                        logBuff[ch] = logCond[ch];

                        // ----------------------------------------------
                        // STep Result
                        // ----------------------------------------------
                        // WriteStepResLog(ch, "", cotype);
                        // STep Result 데이터는 BasicLog 기록시에 같이 함.
                        // ----------------------------------------------
                        //+ Revision by YMJ - 250326 :충방전 관련 데이터만 기록하도록 추가 반영
                        if (_mstep.steptype != cls_stepInfo.enumStepType.MBT && _mstep.steptype != cls_stepInfo.enumStepType.MCZ && _mstep.steptype != cls_stepInfo.enumStepType.InsulationTest
                            && _mstep.steptype != cls_stepInfo.enumStepType.Wait_MBT && _mstep.steptype != cls_stepInfo.enumStepType.Wait_MCZ && _mstep.steptype != cls_stepInfo.enumStepType.Wait_InsulTest)
                        //-
                        {
                            WriteCyclerResOut(ch, "");
                        }

                        // -
                        // Time Reset
                        // -
                        AddTickStepAndTotalTime(ch, 3);

                    }
                }

            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[CurrentStepEnd::3786] - " + ex.Message);
                EndTest2ndStep(ch);
                return;
            }

            //+ Revision by YMJ - 250723 : 로깅 이후 CAN 초기화로 변경
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
            {
                if (m_ucCAN_List != null)
                {
                    if (m_ucCAN_List[ch].ControlEnabled && m_ucCAN_List[ch].isConnected)
                    {
                        //+ Add by YMJ - 241018 : CAN 정보 상시 디스플레이 옵션 추가
                        if (!m_ucCAN_List[ch].AlwaysLog)
                        {
                            //+ Revision by YMJ - 250716 : 상시 사용이 아닐 경우 CAN 정지
                            if (m_ucCAN_List[ch].CAN_List != null) m_ucCAN_List[ch].Reset_DBCList();
                            m_ucCAN_List[ch].StopPCANComm();
                            //-

                        }
                        //-
                        //m_ucCAN_List[ch].StopPCANComm();
                    }

                    //+ Revision by YMJ - 250716 : CANTX 플래그 초기화
                    if (m_CANTXSend != null)
                    {
                        m_CANTXSend[ch] = false;
                    }
                    //-
                }
            }
            //-
            ////-
            ///
            // --------------------------------------------------------------
            // 231102, DC모듈 펌웨어 버그 해결 위해
            // BGH
            // +
            // 231128, 이영재 상무 요구로 주석 처리함 
            // (Protection mode = null) 처리로 이 부분 필요 없어짐
            // --------------------------------------------------------------
            //try
            //{
            //    _mstep = CurStInfo.m_steplist[CurStInfo.m_currentStepNo];
            //    if (_mstep.steptype == cls_stepInfo.enumStepType.Charge || _mstep.steptype == cls_stepInfo.enumStepType.Discharge)
            //    {
            //        m_ucCycler_ABT_List[boardid].Write_StepEnd_PacketABT_byCC0A(bzch);
            //        Thread.Sleep(1);
            //    }
            //}
            //catch { }

            // -------------------------------
            // 231204, BGH
            // 나중에 주석부분 다 풀고 추가 지원해야함
            // 유의깊게 볼것은 MBT, MCZ의 MeasureData.Reset() 부분임
            // -------------------------------
            #region 231227                                                                      
            try
            {
                typelistacir[ch] = 0;  // 231205 BGH

                if (m_ucMbT_List != null && m_ucMbT_List.Count > ch) m_ucMbT_List[ch].SetMeasureDataNUll();
                if (m_ucMcz_List != null && m_ucMcz_List.Count > ch) m_ucMcz_List[ch].SetMeasureDataNUll();
            }
            catch { }

            //if (m_clsAppSet.Enable_Set.Enable_Insulate && m_ITDevEnable && m_NumOfIT > ch)
            //{
            //    try
            //    {
            //        if (m_ucIT_List != null)
            //        {
            //            if (m_ucIT_List[ch].ControlEnabled)
            //            {
            //                m_ucIT_List[ch].SetResultNUll();
            //            }
            //        }
            //    }
            //    catch { }
            //}
            #endregion

            // -
            // --------------------------------------------------------------

            WriteSystemLog(ch, ">> End Step : E_COND - " + cotype.ToString(), true);


            // ------------------------------------------------------------
            // Test 시작
            // 종료 스텝 지정 기능 추가, 230924
            // BGH
            // ------------------------------------------------------------
            if (m_Work_Step_Set[ch].End_Step_Use && m_Work_Step_Set[ch].End_Step_Idx > 0)
            {
                //+ Revision By YMJ - 250911 : End Step 설정 기능 수정 적용
                if (CurStInfo.m_currentStepNo == m_Work_Step_Set[ch].End_Step_Idx && CurStInfo.m_totCycle == m_Work_Step_Set[ch].End_Step_Cycle)
                //-
                {
                    WriteSystemLog(ch, ">> End Schedule to Step No " + CurStInfo.m_currentStepNo.ToString(), true);

                    IsActivateEnding[ch] = 0;
                    EndTest2ndStep(ch);

                    return;
                }
            }
            // -
            // --------------------------------------------------------------

            // ----------------------------------------------------
            // 231116 사용자중지 처리
            // BGH
            // +
            // ----------------------------------------------------
            if (m_forceEnding)
            {
                WriteSystemLog(ch, ">> End Schedule by User", true);

                IsActivateEnding[ch] = 0;
                //
                //EndTest2ndStep(ch);
                //
                return;
            }
            // -
            //


            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_CutOffType = cotype;  // ghbaik
            m_dispChStatus.isChamberWarming = false;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

            bool isallocated = false;
            int stepnumber = 0;
            if (cotype != eNUM_CutOFF_Type.NONE)
            {
                // 특정번호로 점프                
                switch (cotype)
                {
                    case eNUM_CutOFF_Type.VOLTAGE:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_V_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_V_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.CURRENT:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_I_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_I_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.TIME:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Time_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Time_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.CAPACITY:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Q_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Q_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.ENERGY:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_E_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_E_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.DOD:
                        // ----------------
                        // Energy는 어떻게?
                        // ----------------
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Percent_Q_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Percent_Q_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.SOC:

                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Percent_Q_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_Percent_Q_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.POWER:
                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_P_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_P_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.deltaVoltage:

                        if (CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_dV_Enabled)
                        {
                            isallocated = true;
                            stepnumber = CurStInfo.m_steplist[CurStInfo.m_currentStepNo].cutoffCondition.CutOff_dV_StepNo;
                        }
                        break;

                    case eNUM_CutOFF_Type.AUX_VOLTAGE:
                        isallocated = true;
                        stepnumber = m_AuxEndStepNumber[ch];
                        break;

                    case eNUM_CutOFF_Type.CAN:
                        isallocated = true;
                        stepnumber = m_AuxEndStepNumber[ch];
                        break;

                    default:
                        break;
                }
            }

            if (isallocated)
            {
                if (stepnumber <= 0)
                {
                    CurStInfo.m_currentStepNo++;
                }
                else
                {
                    // CurStInfo.m_currentStepNo = stepnumber - 1;
                    // + 
                    // 230911 조건추가 (stepnumber 범위 조절함)
                    if (stepnumber < CurStInfo.m_steplist.Count)
                    {
                        CurStInfo.m_currentStepNo = stepnumber;
                    }
                    else
                    {
                        CurStInfo.m_currentStepNo++;
                    }
                }
            }
            else
            {
                CurStInfo.m_currentStepNo++;
            }
            isallocated = false;

            m_currentStep[ch] = CurStInfo.m_currentStepNo;
            m_ucStepInfo_List[ch] = CurStInfo;

            // -------------------------------------------------------
            // 마지막 스텝에서는 한번 더 읽어서 Start 하지 말고 종료한다.
            // 231116 BGH
            // -------------------------------------------------------
            if (CurStInfo.m_currentStepNo < 0 || CurStInfo.m_steplist.Count <= CurStInfo.m_currentStepNo)
            {
                IsActivateEnding[ch] = 0;
                EndTest2ndStep(ch);
            }
            else
            {
                // 240102, BGH
                // if (StartCurrentStep(ch, false))
                if (StartCurrentStep(ch, false, false))
                {
                    m_timelimit[ch] = -1;
                    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
                }

                if (IsActivateEnding[ch] > 0)
                {
                    IsActivateEnding[ch] = 0;
                    EndTest2ndStep(ch);
                }
            }
        }
        // --
        //
        // --
        public void EndCurrentCPCV_CP_Step(int ch)
        {
            int CurrentNo = 0;

            if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return; }
            if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return; }

            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            try
            {
                CurStInfo = m_ucStepInfo_List[ch];

                if (CurStInfo == null) { EndTest2ndStep(ch); return; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return; }

                // ghbaik
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[CurrentStepEnd::4135] - " + ex.Message);
                EndTest2ndStep(ch);
                return;
            }

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { EndTest2ndStep(ch); return; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { EndTest2ndStep(ch); return; }

            //if (CurStInfo.m_steplist[CurrentNo].stepmode != cls_stepInfo.enumStepMode.CPCV_CP)
            //{
            //    Debug.WriteLine("Mainframe[CurrentStepEnd::4147] - CPCV Step error");
            //    EndTest2ndStep(ch);
            //    return;
            //}


            cls_stepInfo.struStep _step = CurStInfo.m_steplist[CurrentNo];
            _step.stepmode = cls_stepInfo.enumStepMode.CPCV_CV;
            CurStInfo.m_steplist[CurrentNo] = _step;


            // ghbaik2
            m_ucStepInfo_List[ch] = CurStInfo;

            // ghbaik2
            //int rlchno = GetChNumber(ch); //, U_CBOARD_TYPE.USE_CURRENT_ComBOARD);

            //double volth = 0.0, voltl = 0.0, curh = 0.0, curl = 0.0;

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            double refvalue = 0, secondvalue = 0; //, measV = 0;

            refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltVolt;
            secondvalue = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_I;

            if (_step.steptype == cls_stepInfo.enumStepType.Charge)
            {
                if (refvalue < 0) refvalue *= (-1);
                if (secondvalue < 0) secondvalue *= (-1);
            }
            else
            {
                if (refvalue > 0) refvalue *= (-1);
                if (secondvalue > 0) secondvalue *= (-1);
            }

            m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, refvalue, secondvalue);

            //WriteBasicLogTag(ch, "Step : " + CurrentNo.ToString() + ",   Intv : " + CurStInfo.m_steplist[CurrentNo].wIntv.ToString());
            //templog.WriteLine(DateTime.Now.ToString("HH:mm:ss.fff") + " : Start finish");
        }

        // --------------------
        //
        // --------------------
        public void SafetyCurrentStep(int ch, string m_susmsg)
        {
            // --------------------------------------
            // Test중이 아니라면 일시중지를 할 수 없다.
            // --------------------------------------
            if (!IsOnTesting[ch]) return;
            // --------------------------------------

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> Safety test Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            int CurrentNo; // = mtControlData[ch].CurrentNo;
            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();

            try
            {
                if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return; }
                if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return; }
            }
            catch { }

            CurStInfo = m_ucStepInfo_List[ch];
            try
            {
                if (CurStInfo == null) { EndTest2ndStep(ch); return; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return; }
            }
            catch { }

            // --------------------------------------------------
            // 일시정지 재진입 방지
            // --------------------------------------------------
            if (CurStInfo.isTempPaused) return;

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            // ---------------------------------------------------------
            // 이미 Paused 중일때는 그냥 나간다.
            // ---------------------------------------------------------
            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused)
            {
                return;
            }

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { return; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { EndTest2ndStep(ch); return; }

            cls_stepInfo.struStep mStep = new cls_stepInfo.struStep();

            //Debug.WriteLine("Ch=" + (ch + 1).ToString() + ", RealCh=" + bzch.ToString() + "," + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + ">> STepType=" +
            //                CurStInfo.m_steplist[CurrentNo].steptype.ToString() + ",  STepMode=" + CurStInfo.m_steplist[CurrentNo].stepmode.ToString());


            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_CutOffType = eNUM_CutOFF_Type.NONE; // ghbaik
            m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PAUSE;
            m_dispChStatus.ch_s_isPaused = true;

            //TimeSpan ts = DateTime.Now - m_dispChStatus.ch_s_Step_Time;
            //m_dispChStatus.ch_s_Spent_Time = m_dispChStatus.ch_s_Spent_Time.Add(ts);

            //ts = DateTime.Now - m_dispChStatus.ch_s_Total_Time;
            //m_dispChStatus.ch_s_TotSpent_Time = m_dispChStatus.ch_s_TotSpent_Time.Add(ts);

            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

            mStep = CurStInfo.m_steplist[CurrentNo];

            switch (mStep.steptype)
            {
                case cls_stepInfo.enumStepType.Pattern:
                    m_ucUDDS_List[ch].PAUSEPattern();
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Pattern;
                    break;

                case cls_stepInfo.enumStepType.MBT:
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    m_ucMbT_List[ch].STOPAcia();
                    m_ucMbT_List[ch].DisCoNnect();
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_MBT;
                    break;

                case cls_stepInfo.enumStepType.MCZ:  // ghbaik
                    //+ Revisioin by YMJ - 250213 : MxZ 정지 및 연결 종료 변경
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    m_ucMcz_List[ch].StopACIR();
                    m_ucMcz_List[ch].DisConnect();
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_MCZ;
                    //-
                    break;

                case cls_stepInfo.enumStepType.Charge:
                    //+ Add By YMJ - 240611 :  충전 중 Safety에 걸릴 경우 Stanby 명령 추가
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    //-
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Charge;
                    break;

                case cls_stepInfo.enumStepType.Discharge:
                    //+ Add By YMJ - 240611 :  방전 중 Safety에 걸릴 경우 Stanby 명령 추가
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    //-
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Discharge;
                    break;

                case cls_stepInfo.enumStepType.Rest:
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Rest;
                    break;

                // ghbaik
                case cls_stepInfo.enumStepType.OCV:
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_OCV;
                    break;

                case cls_stepInfo.enumStepType.Pause:
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Pause;
                    break;

                case cls_stepInfo.enumStepType.Ready:
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Ready;
                    break;

                default:
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Ready;
                    break;

            }

            // -
            //
            // -
            //+ Revision by YMJ - 240507 : 일시 정지 시 챔버 동작 멈추지 않기 여부 판단 및 챔버 수동 정지 버튼 처리
            if (m_chamberAutoStop)
            {
                StopChamberAction(ch);
            }
            else
            {
                m_ucChannel_Status.SetPopupEnabledChamberStop(m_ucChamber.DoesWorking);
            }
            //-

            // -
            // 시간차이 고정 후 정지
            // -
            // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + "[Ch=" + (ch + 1).ToString() + "] Safety start Log");

            AddTickStepAndTotalTime(ch, 3);
            if (m_susmsg.Length > 1)
            {
                WriteBasicLog(ch, "Pause-" + m_susmsg, eNUM_CutOFF_Type.NONE, false);
            }
            else
            {
                WriteBasicLog(ch, "Pause", eNUM_CutOFF_Type.NONE, false);
            }

            // ------------------
            // 일시정지
            // ------------------
            CurStInfo.isTempPaused = true;

            m_ucCycler_ABT_List[boardid].SetPauseTime(bzch);
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = mStep.steptype;

            CurStInfo.m_steplist[CurrentNo] = mStep;
            m_ucStepInfo_List[ch] = CurStInfo;

            // -------------------
            // 챔버 동작중이면, 중지
            // -------------------

            // ------------------------------------
            // 밸런싱 중이면 정지
            // ------------------------------------
            if (m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].isConnected)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                        m_ucBalancer_List[ch].isBalancing = false;
                        m_ucBalancer_List[ch].SendBalancingOffCmd();
                    }
                }
            }
        }

        // --------------------
        //
        // --------------------
        public void StopChamberAction(int ch)
        {
            if (m_ucChamber != null)
            {
				if (m_ucChamber.EnableFlag && m_ucChamber.isConnected)
				{
                    m_ucChamber.RemoveCh(ch);
                    if (m_ucChamber.GetCount() == 0)
                    {
                        m_ucChamber.StopAction();
                        Thread.Sleep(100);
                        
                        m_ucChamber.DoesWorking = false;
                        //+ Add By YMJ - 240416 : 챔버 정지 팝업 메뉴 사용 가불 처리
                        m_ucChannel_Status.SetPopupEnabledChamberStop(m_ucChamber.DoesWorking);
                        //-

                        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                        m_ucChamber.SP = 0; // -100; // -100.0f;
                        m_ucChamber.HUMIDITY_S = 0;
                        //-

                        // -------------------------
                        // 230917, BGH
                        ResetChamberMaintainSetting();
                    }

     //               if (m_ucChamber.DoesWorking)
					//{
					//	m_ucChamber.StopAction();
     //                   Thread.Sleep(100);
     //                   m_ucChamber.SP = -100; // -100.0f;
					//	m_ucChamber.DoesWorking = false;
					//}
				}
            }
        }


        // ------------------------------------------------
        // ghccc
        // Safety 조건, 알람 발생등의 상황
        // 현재 Step 정지하고, 화면 깜박임.
        // ------------------------------------------------
        public void SuspendCurrentStep(int ch, string m_susmsg)
        {
            // --------------------------------------
            // Test중이 아니라면 일시중지를 할 수 없다.
            // --------------------------------------
            try
            {
                if (!IsOnTesting[ch]) return;
            }
            catch(Exception ex)
            {
                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                Write_Log("MainFrame.SuspendCurrentStep", n_sDebugMsg);
                return;
            }
            // --------------------------------------

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> Suspend test Cancelled [Parallel slave channel]", true);
                return;
            }
            //-

            int CurrentNo; // = mtControlData[ch].CurrentNo;
            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();

            try
            {
                if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return; }
                if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return; }
            }
            catch { }

            CurStInfo = m_ucStepInfo_List[ch];
            try
            {
                if (CurStInfo == null) { EndTest2ndStep(ch); return; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return; }
            }
            catch { }

            //+ Revsion by YMJ - 240823 : 패턴 일시 정지 가능하도록 변경
            /*if(CurStInfo.m_steplist[CurStInfo.m_currentStepNo].steptype == cls_stepInfo.enumStepType.Pattern)
            {
                if (SystemLanguage == LanguageType.KOREAN)
                {
                    MessageBox.Show("패턴 모드에서는 일시정지를 사용할 수 없습니다.");
                }
                else if (SystemLanguage == LanguageType.ENGLISH)
                {
                    MessageBox.Show("Pause is not available in pattern mode.");
                }

                return;
            }*/
            //-

            // --------------------------------------------------
            // 일시정지 재진입 방지
            // --------------------------------------------------
            if (CurStInfo.isTempPaused) return;

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            // ---------------------------------------------------------
            // 이미 Paused 중일때는 그냥 나간다.
            // ---------------------------------------------------------
            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused)
            {
                return;
            }

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { return; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { EndTest2ndStep(ch); return; }

            cls_stepInfo.struStep mStep = new cls_stepInfo.struStep();

            //Debug.WriteLine("Ch=" + (ch + 1).ToString() + ", RealCh=" + bzch.ToString() + "," + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + ">> STepType=" +
            //                CurStInfo.m_steplist[CurrentNo].steptype.ToString() + ",  STepMode=" + CurStInfo.m_steplist[CurrentNo].stepmode.ToString());


            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            m_dispChStatus.ch_s_CutOffType = eNUM_CutOFF_Type.NONE; // ghbaik
            m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PAUSE;
            m_dispChStatus.ch_s_isPaused = true;

            //TimeSpan ts = DateTime.Now - m_dispChStatus.ch_s_Step_Time;
            //m_dispChStatus.ch_s_Spent_Time = m_dispChStatus.ch_s_Spent_Time.Add(ts);

            //ts = DateTime.Now - m_dispChStatus.ch_s_Total_Time;
            //m_dispChStatus.ch_s_TotSpent_Time = m_dispChStatus.ch_s_TotSpent_Time.Add(ts);

            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);

            mStep = CurStInfo.m_steplist[CurrentNo];

            switch (mStep.steptype)
            {
                case cls_stepInfo.enumStepType.Pattern:
                    m_ucUDDS_List[ch].PAUSEPattern();
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Pattern;
                    break;

                case cls_stepInfo.enumStepType.MBT:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    m_ucMbT_List[ch].STOPAcia();
                    m_ucMbT_List[ch].DisCoNnect();
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_MBT;
                    break;

                case cls_stepInfo.enumStepType.MCZ:  // ghbaik
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    //+ Revisioin by YMJ - 250213 : MxZ 정지 및 연결 종료 변경
                    m_ucMcz_List[ch].StopACIR();
                    m_ucMcz_List[ch].DisConnect();
                    //-
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_MCZ;
                    break;

                case cls_stepInfo.enumStepType.Charge:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Charge;
                    break;

                case cls_stepInfo.enumStepType.Discharge:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Discharge;
                    break;

                case cls_stepInfo.enumStepType.Rest:
                    // 230920 BGH, if (m_RestOptionStandby) m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, true);
                    //             else m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);

                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Rest;
                    break;

                // ghbaik
                case cls_stepInfo.enumStepType.OCV:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_OCV;
                    break;

                case cls_stepInfo.enumStepType.Pause:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Pause;
                    break;

                case cls_stepInfo.enumStepType.Ready:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Ready;
                    break;

                default:
                    // 230920 BGH, m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    mStep.steptype = cls_stepInfo.enumStepType.Wait_Ready;
                    break;
            }
            // 230920 BGH, 
            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
            // -

            // 
            // -

            //+ Revision by YMJ - 240415 : 일시 정지 시 챔버 동작 멈추지 않기 여부 판단 및 챔버 수동 정지 버튼 처리
            if (m_chamberAutoStop)
            {
                StopChamberAction(ch);
            }
            else
            {
                m_ucChannel_Status.SetPopupEnabledChamberStop(m_ucChamber.DoesWorking);
            }
            //-

            // -
            // 시간차이 고정 후 정지
            // -
            // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss,fff") + "[Ch=" + (ch + 1).ToString() + "] Suspend Log");

            AddTickStepAndTotalTime(ch, 3);
            // 240102, BGH
            if (m_susmsg.Length > 1)
            {
                WriteBasicLog(ch, "Pause-" + m_susmsg, eNUM_CutOFF_Type.NONE, false);
            }
            else
            {
                WriteBasicLog(ch, "Pause", eNUM_CutOFF_Type.NONE, false);
            }

            // ------------------
            // 일시정지
            // ------------------
            CurStInfo.isTempPaused = true;

            m_ucCycler_ABT_List[boardid].SetPauseTime(bzch);
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = mStep.steptype;

            CurStInfo.m_steplist[CurrentNo] = mStep;
            m_ucStepInfo_List[ch] = CurStInfo;

            // ------------------------------------
            // 밸런싱 중이면 정지
            // 231117 BGH
            // ------------------------------------
            if (m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].isConnected)
                    {
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                        m_ucBalancer_List[ch].isBalancing = false;
                        m_ucBalancer_List[ch].SendBalancingOffCmd();
                    }
                }
            }

            //+ Revision by YMJ - 250716 : 일시 정지 시 CAN TX 중지
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
            {
                if (m_ucCAN_List != null)
                {
                    if (m_CANTXSend != null)
                    {
                        m_CANTXSend[ch] = false;
                    }
                }
            }
            //-
        }

        // ------------------------------------------------
        // ghccc
        // 정지상태의 현재 Step 재개
        // ------------------------------------------------
        public void ResumeCurrentStep(int ch)
        {
            int CurrentNo; // = mtControlData[ch].CurrentNo;
            cls_stepInfo CurStInfo = new cls_stepInfo(this);
            //Display_Channel_Status m_dispChStatus = new Display_Channel_Status();

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> Resume test Cancelled [Parallel slave channel]", true);
                return ;
            }
            //-

            try
            {
                if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return; }
                if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return; }
            }
            catch { }

            CurStInfo = m_ucStepInfo_List[ch];

            try
            {
                if (CurStInfo == null) { EndTest2ndStep(ch); return; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return; }
            }
            catch { }

            // -----------------------------------------
            // 일시정지 상태가 아니라면 Resume 할 수 없다.
            // -----------------------------------------
            if (!CurStInfo.isTempPaused) return;

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2
            if (!m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused)
            {
                return;
            }

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { return; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { EndTest2ndStep(ch); return; }

            cls_stepInfo.struStep mStep = new cls_stepInfo.struStep();
            mStep = CurStInfo.m_steplist[CurrentNo];

            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);

            double volth = 0.0, voltl = 0.0, curh = 0.0, curl = 0.0;

            m_timelimit[ch] = -1;
            volth = Math.Abs((double)(CurStInfo.m_safety.safety_volt_h)) * 1000;
            voltl = Math.Abs((double)(CurStInfo.m_safety.safety_volt_l)) * 1000;
            curh = (double)(CurStInfo.m_safety.safety_curr_h) * 1000;
            curl = curh * (-1.0); // (double)CurStInfo.m_safety.safety_curr_l * 1000;

            bool isPossible = true;

            switch (mStep.steptype)
            {
                case cls_stepInfo.enumStepType.Wait_Pattern:
                    mStep.steptype = cls_stepInfo.enumStepType.Pattern;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PATTERN;
                    
                    break;

                case cls_stepInfo.enumStepType.Wait_MBT:
                    mStep.steptype = cls_stepInfo.enumStepType.MBT;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.ACIA;
                    break;

                case cls_stepInfo.enumStepType.Wait_MCZ:  // ghbaik
                    mStep.steptype = cls_stepInfo.enumStepType.MCZ;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.ACIA;
                    break;

                case cls_stepInfo.enumStepType.Wait_Charge:
                    mStep.steptype = cls_stepInfo.enumStepType.Charge;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CHARGE;
                    break;

                case cls_stepInfo.enumStepType.Wait_Discharge:
                    mStep.steptype = cls_stepInfo.enumStepType.Discharge;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.DISCHARGE;
                    break;

                case cls_stepInfo.enumStepType.Wait_Rest:
                    mStep.steptype = cls_stepInfo.enumStepType.Rest;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.REST;
                    break;

                case cls_stepInfo.enumStepType.Wait_OCV:
                    mStep.steptype = cls_stepInfo.enumStepType.OCV;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.OCV;
                    break;

                case cls_stepInfo.enumStepType.Wait_Pause:
                    mStep.steptype = cls_stepInfo.enumStepType.Pause;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PAUSE;
                    break;

                case cls_stepInfo.enumStepType.Wait_Ready:
                    mStep.steptype = cls_stepInfo.enumStepType.Ready;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.READY;
                    break;

                default:
                    isPossible = false;
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.NONE;
                    break;
            }

            // -------------------------------------
            // Wait 상태가 아니라면, Resume 할수 없다.
            // -------------------------------------
            if (!isPossible) { return; }


            // --------------------------------------------
            // AlarmList 지우기
            // 여기 들어오기 전에 알람은 지워야 한다.
            // 231117 BGH
            // --------------------------------------------
            // RemoveAlarm(ch);


            // --------------------------------------------
            //
            // --------------------------------------------
            try
            {
                // ----------------------------------------
                // DOD의 경우는 여기서 조건을 구성한다.
                // 231102 추가함 BGH
                // ----------------------------------------
                mStep.Chamber_MaintainUse = mStep.Chamber_MaintainUse_buff;

                if (mStep.cutoffCondition.CutOff_Percent_Q_Enabled)
                {
                    if (mStep.cutoffCondition.CutOff_Percent_Q_RefStep >= 0)
                    {
                        double m_CumQ = CurStInfo.m_steplist[mStep.cutoffCondition.CutOff_Percent_Q_RefStep].cmmu_Qh;
                        double m_CumW = CurStInfo.m_steplist[mStep.cutoffCondition.CutOff_Percent_Q_RefStep].cmmu_Wh;
                        double dPerc = mStep.cutoffCondition.CutOff_Percent_Q / 100;
                        if (mStep.cutoffCondition.CutOff_Percent_Q > 0) m_CumQ *= dPerc;
                        //m_CumQ *= 1000;
                        mStep.cutoffCondition.CutOff_E_Value = m_CumQ;

                        //Debug.WriteLine("    >>>> STep=" + CurrentNo.ToString() + ", Perc=" + mStep.cutoffCondition.CutOff_Percent_Q.ToString() + ", QValue=" + mStep.cutoffCondition.CutOff_E_Value.ToString());
                    }
                }
                else
                {
                    mStep.cutoffCondition.CutOff_Percent_Q = 0;
                }

                // ----------------------
                //  
                //if (m_ChamberReact[ch])
                //{
                //    mStep.Chamber_MaintainUse = false;
                //    m_ChamberReact[ch] = false;
                //}
                // Resume 시에는 필요 없음. 231117 BGH

                CurStInfo.m_steplist[CurrentNo] = mStep;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step = mStep;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].ResetInStep();
            }
            catch (Exception ex)
            {
                EndTest2ndStep(ch);
                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                Write_Log("MainFrame.ResumeCurrentStep", n_sDebugMsg);
                return;
            }
            // -
            // -----------------------------------------------------------------

            // --------
            // 230927, BGH
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = mStep.steptype;

            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = false;

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            if (m_ucChamber.EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chamber_Enable)
                {
                    if (!m_ucChamber.isConnected)
                    {
                        m_ucChamber.StartSerial();
						WriteSystemLog(ch, ">> Chamber Re-Start", false);
					}

					if (m_ucChamber.isConnected)
					{
						if (CurStInfo.m_steplist[CurrentNo].Chamber_MaintainUse)
						{
                            // -----------------------------------------------------------------------
                            // if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP)
                            // -----------------------------------------------------------------------
                            // 최초 실행에도 기존 설정 온도와 현재 설정이 같으면 챔버는 안돌리고 무한루프처럼 될 수 있음
                            // 230926, BGH
                            // -----------------------------------------------------------------------
                            if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP || ChlistMaintain.Count < 1)
                            {
                                //m_ucChamber.StopAction();

								m_ucChamber.SP = CurStInfo.m_steplist[CurrentNo].Chamber_SP;
                                //+ Add by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                                m_ucChamber.HUMIDITY_S = CurStInfo.m_steplist[CurrentNo].Chamber_Humidity_S;
                                //-
                                m_ucChamber.Inclination = 1; // 1.0f;

                                //+ Revision by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                                //m_ucChamber.SendWriteSPValue();
                                //Thread.Sleep(100);
                                //WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
                                {
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                                {
                                    m_ucChamber.SendWriteSPValue();
                                    Thread.Sleep(100);
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else
                                {
								m_ucChamber.SendWriteSPValue();
								Thread.Sleep(100);
                                WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                }
                                //-

                                //+ Add by LBG - 231120 : 알람 후 작업 재 진행 시 해당 채널 정보가 있는지 판별하기 위하여 추가
                                if (!m_ucChamber.Ch_Exist(ch))
                                {
                                    m_ucChamber.AddCh(ch);
                                }
                                //-

                                m_ucChamber.StartAction();
								m_ucChamber.DoesWorking = true;
                                WriteSystemLog(ch, ">> Chamber Start", false);
							}
							else
							{
								WriteSystemLog(ch, ">> Chamber Start [Skip-Same SP]", false);
							}

                            // -----------------------------------------
                            // BGH, 230926 추가함 (Suspend 시킬때 제거하는것과 같이)
                            // +
                            SetChamberMaintainSetting(ch);
                            // -
                            m_ChamberReact[ch] = true;

							m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = true;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused = false;  // 231117

                            WriteSystemLog(ch, ">> Chamber on SP=" + m_ucChamber.SP.ToString() + " w/ Waiting", false);

							CurStInfo.isTempPaused = false;
							m_ucStepInfo_List[ch] = CurStInfo;


                            // ---------------------------------------------
                            // logging 조건을 REST 조건으로
                            // ---------------------------------------------
                            logCond[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time / 100;  // 10ms 단위
                            if (logCond[ch] < 1) logCond[ch] = 1;
                            //+ Revision by YMJ - 240823 : 패턴 일 경우 로깅 주기 따로 체크
                            if (mStep.steptype != cls_stepInfo.enumStepType.Pattern)
                            {
                                logBuff[ch] = logCond[ch];
                            }
                            //-

                            // ---------------------------------------------
                            // Test중임을 표시
                            // ---------------------------------------------
                            IsOnTesting[ch] = true;

                            return;
						}
					}
                }
            }

            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chiller_Enable)
                {
                    if (!m_ucChiller[ch].isConnected)
                    {
                        m_ucChiller[ch].StartSerial();
                        WriteSystemLog(ch, ">> Chamber Re-Start", false);
                    }

                    m_ucChiller[ch].SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP;
                    m_ucChiller[ch].Flow_SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP_Flow;

                    WriteSystemLog(ch, ">> Chamber Start", false);

                    m_ucChiller[ch].StartAction();
                    m_ucChiller[ch].DoesWorking = true;

                    IsOnTesting[ch] = true;

                    return;
                }
            }
            //-
            //-

            // m_ChamberReact[ch] = false;  // 230913 BGH
            // 240102, BGH
            bool isVover = false;
            double curV = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;

            string stepmsg = ">> Resume Step // " + CurStInfo.m_steplist[CurrentNo].steptype.ToString();
            // --------------------------------------------
            // 충방전은 모아서 여기서 처리
            // --------------------------------------------
            switch (mStep.steptype)
            {
                case cls_stepInfo.enumStepType.Pattern:
                    //string pattern_path = CurStInfo.m_steplist[CurrentNo].strPath;
                    CurStInfo.isTempPaused = false;
                    //+ Revision by YMJ - 240823 : 패턴 일시정지 후 재기동 시 tick 값을 넘겨서 해당 tick 부터 돌 수 있도록 수정
                    m_ucUDDS_List[ch].RESUMEPattern(patternBuff[ch]);
                    logBuff[ch] = patternBuff[ch] + 1;
                    //-
                    break;

                case cls_stepInfo.enumStepType.MBT:
                    #region
                    //m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    //m_timelimit[ch] = 5;
                    //if (m_ucMbT_List[ch] != null)
                    //{
                    //    if (m_ucMbT_List.Count > ch)
                    //    {
                    //        int midx = m_clsSys_Link.Get_MBT_Index(ch);
                    //        m_ucMbT_List[ch].strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_IP;
                    //        m_ucMbT_List[ch].strTCPPort = "2000"; //.strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_TCP_Port;

                    //        if (m_ucMbT_List[ch].isConnected)
                    //        {
                    //            m_ucMbT_List[ch].DisCoNnect();
                    //        }
                    //        m_ucMbT_List[ch].CONnect();

                    //        m_timelimit[ch] = 240;  // 4 min, 240 sec
                    //    }
                    //}
                    CurStInfo.isTempPaused = false;

                    #endregion
                    break;

                case cls_stepInfo.enumStepType.MCZ:  // ghbaik
                    #region
                    //m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    //m_timelimit[ch] = 5;
                    //if (m_ucMcz_List[ch] != null)
                    //{
                    //    if (m_ucMcz_List.Count > ch)
                    //    {
                    //        int midx = m_clsSys_Link.Get_MxZ_Index(ch);
                    //        m_ucMcz_List[ch].mcz_comport_number = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_COM_Port;
                    //        m_ucMcz_List[ch].StartSerial();

                    //        if (m_ucMcz_List[ch].isConnected)
                    //        {
                    //            m_ucMcz_List[ch].mcz_login();
                    //        }

                    //        m_timelimit[ch] = 240;
                    //    }
                    //}
                    CurStInfo.isTempPaused = false;

                    #endregion
                    break;

                case cls_stepInfo.enumStepType.Charge:
                case cls_stepInfo.enumStepType.Discharge:
                case cls_stepInfo.enumStepType.Rest:
                case cls_stepInfo.enumStepType.OCV:  // ghbaik

                    #region
                    double refvalue = 0.0, secondvalue = 0.0;

                    // ---------------------------
                    // Board Index : base 0
                    // ---------------------------
                    refvalue = 0.0;
                    secondvalue = 0.0;
                    switch (mStep.stepmode)
                    {
                        case cls_stepInfo.enumStepMode.REST:
                            if (m_RestOptionStandby) m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, true);
                            else m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);
                            break;
                        case cls_stepInfo.enumStepMode.STANDBY:
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            CurStInfo.isTempPaused = false;
                            break;
                        case cls_stepInfo.enumStepMode.OCV:
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, true);
                            break;

                        case cls_stepInfo.enumStepMode.CC:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CC; // ghbaik

                            switch (mStep.steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = mStep.operaCondition.fltCurrent;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = mStep.operaCondition.fltCurrent;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            m_ucCycler_ABT_List[boardid].Write_CC_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        case cls_stepInfo.enumStepMode.CV:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CV; // ghbaik

                            // -----------------------------------------------------------------
                            // 최초 인가 전류를 CV에서는 CutOff 전류의 1.1배.
                            // 예로, CutOff 전류가 1A라면 최초 전류가 1.1A보다 커지면 스텝 시작
                            // 231019, BGH
                            // -----------------------------------------------------------------
                            // double cutoffI = CurStInfo.m_steplist[CurrentNo].cutoffCondition.CutOff_I * 1.1;
                            double cutoffI = CurStInfo.m_safety.safety_curr_h * 0.99;
                            switch (mStep.steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = (double)mStep.operaCondition.fltVolt;
                                    if (refvalue < 0)
                                    {
                                        refvalue = Math.Abs(refvalue);
                                    }
                                    if (cutoffI < 0)
                                    {
                                        cutoffI = Math.Abs(refvalue);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) <= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = (double)mStep.operaCondition.fltVolt;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1);
                                    }
                                    if (cutoffI > 0)
                                    {
                                        cutoffI *= (-1);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) >= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                            }

                            stepmsg += (" // " + mStep.steptype.ToString());
                            // ------------------------------
                            // 240102, BGH
                            // ------------------------------
                            if (isVover) { break; }

                            m_ucCycler_ABT_List[boardid].Write_CV_PacketABT(bzch, refvalue, cutoffI);
                            // stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        case cls_stepInfo.enumStepMode.CCCV:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CCCV; // ghbaik

                            switch (mStep.steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = (double)mStep.operaCondition.fltVolt;
                                    secondvalue = (double)mStep.operaCondition.fltCurrent;
                                    if (secondvalue < 0)
                                    {
                                        secondvalue *= (-1.0);
                                    }

                                    // 240102, BGH
                                    // CV Target 전압이 현재 전압보다 크면 Alarm.
                                    if (curV > 0 && Math.Abs(refvalue) <= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = (double)mStep.operaCondition.fltVolt;
                                    secondvalue = (double)mStep.operaCondition.fltCurrent;
                                    if (secondvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                        secondvalue *= (-1.0);
                                    }

                                    // 240102, BGH
                                    // CV Target 전압이 현재 전압보다 작으면 Alarm.
                                    if (curV > 0 && Math.Abs(refvalue) >= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                            }
                            stepmsg += (" // " + mStep.steptype.ToString());

                            // ------------------------------
                            // 240102, BGH
                            // ------------------------------
                            if (isVover) { break; }

                            m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, refvalue, secondvalue);
                            // stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        case cls_stepInfo.enumStepMode.CP:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CP; // ghbaik

                            switch (mStep.steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = mStep.operaCondition.fltValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = mStep.operaCondition.fltValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            m_ucCycler_ABT_List[boardid].Write_CP_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        case cls_stepInfo.enumStepMode.CR:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CR; // ghbaik

                            switch (mStep.steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = mStep.operaCondition.fltValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = mStep.operaCondition.fltValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            m_ucCycler_ABT_List[boardid].Write_CR_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        case cls_stepInfo.enumStepMode.CPCV_CP:
                            #region
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CPCV; // ghbaik
                            secondvalue = 0;
                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    refvalue = (double)mStep.operaCondition.fltCPValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    refvalue = (double)mStep.operaCondition.fltCPValue; //.fltValue; // .fltCPValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            m_ucCycler_ABT_List[boardid].Write_CP_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + mStep.steptype.ToString());
                            #endregion
                            break;

                        default:
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            CurStInfo.isTempPaused = false;
                            break;
                    }
                    #endregion

                    #region Resume 할때는 EIS는 제외. (남은시간 및 EIS 측정시간 문제 소지)
                    //if (m_clsAppSet.Enable_Set.Enable_ACIR)
                    //{
                    //    if (CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MBT_ON ||
                    //        CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MBT_ON_W_CYCLER)
                    //    {
                    //        m_timelimitSUB[ch] = 5;

                    //        if (m_ucMbT_List[ch] != null)
                    //        {
                    //            if (m_ucMbT_List.Count > ch)
                    //            {
                    //                int midx = m_clsSys_Link.Get_MBT_Index(ch);
                    //                m_ucMbT_List[ch].strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_IP;
                    //                m_ucMbT_List[ch].strTCPPort = "2000"; //.strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_TCP_Port;

                    //                if (m_ucMbT_List[ch].isConnected)
                    //                {
                    //                    m_ucMbT_List[ch].DisCoNnect();
                    //                }

                    //                m_ucMbT_List[ch].CONnect();

                    //                m_timelimitSUB[ch] = 240;  // 4 min, 240 sec
                    //            }
                    //        }
                    //    }

                    //    if (CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MXZ_ON ||
                    //        CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MXZ_ON_W_CYCLER)
                    //    {
                    //        m_timelimitSUB[ch] = 5;
                    //        if (m_ucMcz_List[ch] != null)
                    //        {
                    //            if (m_ucMcz_List.Count > ch)
                    //            {
                    //                int midx = m_clsSys_Link.Get_MxZ_Index(ch);
                    //                m_ucMcz_List[ch].mcz_comport_number = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_COM_Port;
                    //                m_ucMcz_List[ch].StartSerial();

                    //                if (m_ucMcz_List[ch].isConnected)
                    //                {
                    //                    m_ucMcz_List[ch].mcz_login();
                    //                }

                    //                m_timelimitSUB[ch] = 240;
                    //            }
                    //        }
                    //    }
                    //}
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.InsulationTest:
                    CurStInfo.isTempPaused = false;
                    break;
                    
                default:
                    // ---------------------
                    // 추가, 231101 BGH
                    // ---------------------
                    CurStInfo.isTempPaused = false;
                    break;
            }

            // --------------------------------------------------
            // 240102, BGH
            // --------------------------------------------------
            if (isVover)
            {
                if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.Charge)
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(ch, ABT.TypeOfSafetyViolation.OverVolt, "[CYC014]OVP[Target Voltage]");
                    //-
                    SuspendCurrentStep(ch, "OVP[CV/CCCV]");
                }
                else
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(ch, ABT.TypeOfSafetyViolation.UnderVolt, "[CYC015]UVP[Target Voltage]");
                    //-
                    SuspendCurrentStep(ch, "UVP[CV/CCCV]");
                }
                WriteSystemLog(ch, stepmsg, true);
                return;
            }
            // -

            // CurStInfo.isTempPaused = false;

            // ----------------------------------------------------
            // cell cv 중복실행 방지 flag을 clear한다.
            // CV중에 정지했어도, Resume할때 그 조건을 다시 검사해야 하기 때문에
            // 231002, BGH
            // ----------------------------------------------------
            CurStInfo.isCellCVexecuted = false;

            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused = false;  // 231117
            m_ucCycler_ABT_List[boardid].SetResumeTime(bzch);
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.steptype = mStep.steptype;
            // CurStInfo.TestReStartTime = DateTime.Now;

            m_dispChStatus.isTesting = true;  // 231020, BGH
            m_dispChStatus.ch_s_isPaused = false;
            m_dispChStatus.ch_s_Total_Time = DateTime.Now;
            m_dispChStatus.ch_s_Step_Time = DateTime.Now;

            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);


            CurStInfo.m_steplist[CurrentNo] = mStep;

            m_ucStepInfo_List[ch] = CurStInfo;


            WriteSystemLog(ch, stepmsg, true);

            // -------------------------------------------
            // Chamber
            // 온도만 설정하고 다음스텝으로 넘어가는 경우..
            // -------------------------------------------
            if (m_ucChamber.EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chamber_Enable)
                {
                    if (!m_ucChamber.isConnected)
                    {
                        m_ucChamber.StartSerial();
                    }

                    //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                    if (m_ucChamber.isConnected)
					{
						if (!CurStInfo.m_steplist[CurrentNo].Chamber_MaintainUse)
						{
                            // ----------------------------------------------------------------------------------------
                            // 230830 LGES 테스트 중 방전 후 REST 모드 Chamber 온도 기다리는 중에 계속 방전되는 버그
                            // 231128
                            // ----------------------------------------------------------------------------------------
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            //if (m_RestOptionStandby) m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            //else m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.CC, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);

                            if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP)
							{
                                //m_ucChamber.StopAction();

                                m_ucChamber.SP = CurStInfo.m_steplist[CurrentNo].Chamber_SP;
                                //+ Add by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                                m_ucChamber.HUMIDITY_S = CurStInfo.m_steplist[CurrentNo].Chamber_Humidity_S;
                                //-
                                m_ucChamber.Inclination = 1; // 1.0f;
                                //m_ucChamber.SendWriteSPValue();
                                //Thread.Sleep(100);
                                //WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
                                {
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                                {
                                    m_ucChamber.SendWriteSPValue();
                                    Thread.Sleep(100);
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else
                                {
								m_ucChamber.SendWriteSPValue();
								Thread.Sleep(100);
                                WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                }

                                //+ Add by LBG - 231120 : 알람 후 작업 재 진행 시 해당 채널 정보가 있는지 판별하기 위하여 추가
                                if (!m_ucChamber.Ch_Exist(ch))
                                {
                                    m_ucChamber.AddCh(ch);
                                }
                                //-

                                m_ucChamber.StartAction();
								m_ucChamber.DoesWorking = true;

                                WriteSystemLog(ch, ">> Chamber Start", false);

								if (m_ucChamberDIO.EnableFlag)
								{
									m_ucChamberDIO.StartSerial();
									WriteSystemLog(ch, ">> Start Chamber DIO", false);
								}
							}
							else
							{
								WriteSystemLog(ch, ">> Chamber Start [Skip-Same SP]", false);
							}
							WriteSystemLog(ch, ">> Chamber on SP=" + m_ucChamber.SP.ToString() + " NO Waiting", false);
						}
					}
                    //-
                }
            }

            // -------------------------------------------
            // AUX && Balancing
            // -------------------------------------------
            #region
            if (m_BalancingEnable && m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].ControlEnabled)
                    {
                        bool bfind = false;
                        List<AUX_Volt_Recipe> vrcp = CurStInfo.m_steplist[CurrentNo].lstAUXVolt;
                        if (vrcp != null)
                        {
                            for (int i = 0; i < vrcp.Count(); i++)
                            {
                                if (vrcp[i].AUX_V_Recipe_Balance) { bfind = true; break; }
                            }
                        }
                        if (bfind) { balancingActivated[ch] = 1; }
                        else balancingActivated[ch] = 0;

                        // ------------------------------------------
                        // 밸런싱 조건
                        // balancingActivated[ch] == 1
                        // m_AUXEnableMain = true
                        // m_AUXValue[ch] 값이 들어 올 것.
                        // ------------------------------------------

                        if (balancingActivated[ch] == 1 && m_AUXEnable && m_NumOfAUX > ch)
                        {
                            // ----------------------------------------------
                            // Balancing
                            // ----------------------------------------------
                            m_ucBalancer_List[ch].BalancingResis = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_R_Type;
                            m_ucBalancer_List[ch].ResetBalancingList();
                            double dstart = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Dev_Start * 0.001; // 0.001f;

                            // ------------------------------------------------------
                            // 밸런싱 대상 전압 중 최소값을 계산해 사용. 23.08.14
                            // ------------------------------------------------------
                            double vbmin = 999.99;
                            for (int i = 0; i < vrcp.Count(); i++)
                            {
                                if (vrcp[i].AUX_V_Recipe_Balance)
                                {
                                    if (m_AUX_Volt[ch, i] < vbmin) vbmin = m_AUX_Volt[ch, i];
                                }
                            }
                            if (vbmin > 10) vbmin = 0;

                            if (vbmin > 0)
                            {
                                for (int i = 0; i < vrcp.Count(); i++)
                                {
                                    if (vrcp[i].AUX_V_Recipe_Balance)
                                    {
                                        // -----------------------------------------------
                                        // 밸런싱도 여러채널 제공해야 하므로,
                                        // 이 부분은 수정되어야 한다.
                                        // 현재는 1번 채널만...
                                        // 병관 차장님!!! 신경써 주세요.
                                        // -----------------------------------------------
                                        //Debug.WriteLine("m_AUXValue[i] - AUX_V_min = " + (m_AUX_Volt[0, i] - AUX_V_min[0]).ToString("F3"));
                                        if (m_AUX_Volt[ch, i] > CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Lower &&
                                            m_AUX_Volt[ch, i] < CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Upper &&
                                            (m_AUX_Volt[ch, i] - vbmin) > dstart)
                                        {
                                            // ---------------------------------------
                                            // 현재는 i 의 범위는 1부터 8까지이다.
                                            // ---------------------------------------
                                            m_ucBalancer_List[ch].SetBalancingMode(i + 1, true);
                                        }
                                    }
                                }

                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = true;
                                m_ucBalancer_List[ch].isBalancing = true;
                                m_ucBalancer_List[ch].SendWriteCmdArray();
                            }
                        }
                    }
                }
            }
            #endregion


            // -------------------------------------------
            // CAN
            // -------------------------------------------
            // ----------------------------
            // BMS Control Checking
            // ----------------------------
            #region
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
            {
                // --------------------------------------------------
                // BMS 추종
                // --------------------------------------------------
                //+ Revision by YMJ - 250716 : 해당 스텝에서 CAN 사용 중일 경우만 CAN 재연결
                if (m_ucCAN_List[ch].ControlEnabled && (!m_ucCAN_List[ch].isConnected) && CurStInfo.m_steplist[CurrentNo].CAN_Use)
                {
                    // ----------------------------------------------------
                    // CAN Open
                    // ----------------------------------------------------
                    //+ Revision by YMJ - 250725 : CAN 연결 시 결과 로깅 추가
                    cls_devCAN.PCANReturnCode result;
                    if (m_ucCAN_List[ch].IS_FD_CAN) result = m_ucCAN_List[ch].StartPCANCommFD();
                    else result = m_ucCAN_List[ch].StartPCANComm();
                    if (result != cls_devCAN.PCANReturnCode.PCAN_OK)
                    {
                        WriteSystemLog("// CAN Connect Fail // Result : " + result.ToString());
                    }
                    else
                    {
                        WriteSystemLog("// CAN Connect Success // Result : " + result.ToString());
                    }
                    //-
                    
                    //+ Revision by YMJ - 250717 : CAN 정보 상시 디스플레이 옵션 시 Safety 및 Cutoff 적용을 위해 수정
                    //+ Revision by YMJ - 241018 : CAN 정보 상시 디스플레이 옵션 추가
                    if (!m_alwaysLog)
                    {
                        if (CurStInfo.m_steplist[CurrentNo].CAN_Use && CurStInfo.MDBC_List_Safety != null)
                        {
                            m_ucCAN_List[ch].CAN_List.Clear();
                            for (int i9 = 0; i9 < CurStInfo.MDBC_List_Safety.Count; i9++)
                            {
                                cls_devCAN.MDBC_PARSE mdbc = new cls_devCAN.MDBC_PARSE();
                                try
                                {
                                    //+ Revision by YMJ - 241008 : MDBC 정보 로드 추가
                                    mdbc.CutOffCheck = false;
                                    mdbc.Name = CurStInfo.MDBC_List_Safety[i9].Signal_Name;
                                    mdbc.Addr = (uint)CurStInfo.MDBC_List_Safety[i9].Signal_Addr;
                                    mdbc.sBit = CurStInfo.MDBC_List_Safety[i9].Signal_SBit;
                                    mdbc.Size = CurStInfo.MDBC_List_Safety[i9].Signal_Size;
                                    mdbc.ByteOrder = CurStInfo.MDBC_List_Safety[i9].Signal_ByteOrder;
                                    mdbc.Type = CurStInfo.MDBC_List_Safety[i9].Signal_Type;
                                    mdbc.Factor = CurStInfo.MDBC_List_Safety[i9].Signal_Factor;
                                    mdbc.Offset = CurStInfo.MDBC_List_Safety[i9].Signal_Offset;
                                    //-

                                    //+ Revision by YMJ - 241028 : value가 0일 수도 있으므로 수정 적용
                                    mdbc.Value = -999999;
                                    //-

                                    mdbc.CutOff_L = CurStInfo.MDBC_List_Safety[i9].CAN_Cut_Lower;
                                    mdbc.CutOff_H = CurStInfo.MDBC_List_Safety[i9].CAN_Cut_Upper;
                                    mdbc.Safety_L = CurStInfo.MDBC_List_Safety[i9].CAN_Safty_Lower;
                                    mdbc.Safety_H = CurStInfo.MDBC_List_Safety[i9].CAN_Safty_Upper;
                                }
                                catch { }
                                m_ucCAN_List[ch].Add_DBCList(mdbc);
                            }
                        }
                        else
                        {
                            m_ucCAN_List[ch].Reset_DBCList();
                        }

                        if (CurStInfo.m_steplist[CurrentNo].CAN_Use && CurStInfo.MDBC_List_Safety != null && CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info != null)
                        {
                            try
                            {
                                List<cls_devCAN.MDBC_PARSE> mdbc_list = m_ucCAN_List[ch].CAN_List;
                                for (int i9 = 0; i9 < CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info.Count; i9++)
                                {
                                    CAN_CUT_OFF_INFO mdbc_cut = CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info[i9];
                                    if (mdbc_cut.CAN_INDEX >= 0 && mdbc_cut.CAN_INDEX < m_ucCAN_List[ch].CAN_List_Count)
                                    {
                                        cls_devCAN.MDBC_PARSE mdbc = mdbc_list[mdbc_cut.CAN_INDEX];
                                        mdbc.CutOffCheck = true;
                                        mdbc.CutOff_L = mdbc_cut.CAN_Cut_Lower;
                                        mdbc.CutOff_H = mdbc_cut.CAN_Cut_Upper;
                                        mdbc.moveStep = mdbc_cut.CAN_Move_Step;
                                        mdbc_list[mdbc_cut.CAN_INDEX] = mdbc;
                                    }
                                }
                            }
                            catch { }
                        }
                    }
                    //+ Revision by YMJ - 251027 : CAN 정보 상시 디스플레이 옵션 시 CAN LIST 업데이트 제거 
                    //-
                    //-

                    if (m_CANTXSend != null && m_CANTXSendThread != null && CurStInfo.m_steplist[CurrentNo].CAN_TX_List != null)
                    {
                        m_CANTXSend[ch] = true;
                        m_CANTXSendThread[ch] = new Thread(() => startCANTXSend(ch, CurStInfo.m_steplist[CurrentNo].CAN_TX_List));
                        m_CANTXSendThread[ch].IsBackground = true;
                        m_CANTXSendThread[ch].Start();
                    }
                }
                //-
            }
            #endregion

            // ----------------------------
            // MBI
            // ----------------------------
            #region
            if (m_clsAppSet.Enable_Set.Enable_AUX && m_MBIEnable && m_NumOfMBI > ch)
            {
                if (m_ucMBI_List[ch/2].ControlEnabled && (!m_ucMBI_List[ch/2].isConnected))
                {
                    // ----------------------------------------------------
                    // CAN Open
                    // ----------------------------------------------------
                    if (m_ucMBI_List[ch/2].StartPCANComm() == cls_devMBI.PCANReturnCode.PCAN_OK)
                    {
                        m_ucMBI_List[ch/2].WriteStartCommandLaon();
                    }
                }
            }
            #endregion

            // --------------------------------
            // MBT/MCZ는 resume이 Restart임
            // 231101에 절연저항기 추가, BGH
            // --------------------------------
            // if (mStep.steptype == cls_stepInfo.enumStepType.MBT || mStep.steptype == cls_stepInfo.enumStepType.MCZ)
            if (mStep.steptype == cls_stepInfo.enumStepType.MBT || mStep.steptype == cls_stepInfo.enumStepType.MCZ ||
                mStep.steptype == cls_stepInfo.enumStepType.InsulationTest)
            {
                // 240102, BGH
                // if (StartCurrentStep(ch, false))
                if (StartCurrentStep(ch, false, true))
                {
                    m_timelimit[ch] = -1;
                    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
                }
            }
        }

        // ------------------------------------------------
        // ghccc
        // 다음 Step으로 이동 
        // ------------------------------------------------
        //public void SkipCurrentStep(int ch)
        //{
        //    m_timelimit[ch] = -1;

        //    // -------------------------------------------
        //    // Safety 처리
        //    // 현 채널과 관련있는 알람들을 리스트에서 제거
        //    // -------------------------------------------
        //    RemoveAlarm(ch);
        //    EndCurrentStep(ch, eNUM_CutOFF_Type.NONE);
        //}

        // ---------------------------------------------------
        // 
        // ---------------------------------------------------
        // public bool StartCurrentStep(int ch, bool forceFinish)
        // 240102, BGH
        public bool StartCurrentStep(int ch, bool forceFinish, bool isResumeStart)
        {
            int CurrentNo; // = mtControlData[ch].CurrentNo;
            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            WriteSystemLog(ch, ">> Load step information", false);
            if (forceFinish) { EndTest2ndStep(ch); return false; }
            try
            {
                if (m_ucStepInfo_List == null) { EndTest2ndStep(ch); return false; }
                if (m_ucStepInfo_List.Count <= ch) { EndTest2ndStep(ch); return false; }
            }
            catch { }

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            if (CheckParallelSlave(ch))
            {
                WriteSystemLog(ch, ">> Start test Cancelled [Parallel slave channel]", true);
                return false;
            }
            //-

            CurStInfo = m_ucStepInfo_List[ch];
            try
            {
                if (CurStInfo == null) { EndTest2ndStep(ch); return false; }
                if (CurStInfo.m_currentStepNo < 0) { EndTest2ndStep(ch); return false; }
            }
            catch { }

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            m_AuxEndStepNumber[ch] = 0;

            CurrentNo = CurStInfo.m_currentStepNo;

            if (CurStInfo.m_steplist == null) { return false; }
            if (CurrentNo >= CurStInfo.m_steplist.Count) { EndTest2ndStep(ch); return false; }

			// ----------------------------------------
			// 스케쥴 보기에서 현재 스텝 지정
			// ----------------------------------------
			OnChangedStepNumber?.Invoke(ch, CurrentNo);

            // Debug.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss (fff)") + " Ch=" + (ch + 1).ToString() + " Start STep 1");

            // ghbaik2
            cls_stepInfo.struStep mStep = new cls_stepInfo.struStep();

            try
            {
                mStep = CurStInfo.m_steplist[CurrentNo];

                //mStep.Chamber_Enable = mStep.Chamber_Enable_buff;  // 230909 BGH
                mStep.Chamber_MaintainUse = mStep.Chamber_MaintainUse_buff;


                // ----------------------------------------
                // DOD의 경우는 여기서 조건을 구성한다.
                // ghbaik
                // ----------------------------------------

                if (mStep.cutoffCondition.CutOff_Percent_Q_Enabled)
                {
                    if (mStep.cutoffCondition.CutOff_Percent_Q_RefStep >= 0)
                    {
                        double m_CumQ = CurStInfo.m_steplist[mStep.cutoffCondition.CutOff_Percent_Q_RefStep].cmmu_Qh;
                        double m_CumW = CurStInfo.m_steplist[mStep.cutoffCondition.CutOff_Percent_Q_RefStep].cmmu_Wh;
                        double dPerc = mStep.cutoffCondition.CutOff_Percent_Q / 100;
                        if (mStep.cutoffCondition.CutOff_Percent_Q > 0) m_CumQ *= dPerc;

                        mStep.cutoffCondition.CutOff_E_Value = m_CumQ;

                        //Debug.WriteLine("    >>>> STep=" + CurrentNo.ToString() + "CommQ=" + CurStInfo.m_steplist[mStep.cutoffCondition.CutOff_Percent_Q_RefStep].cmmu_Qh.ToString() + ", Perc=" + mStep.cutoffCondition.CutOff_Percent_Q.ToString() + ", QValue=" + mStep.cutoffCondition.CutOff_E_Value.ToString());
                    }
                }
                else
                {
                    mStep.cutoffCondition.CutOff_Percent_Q = 0;
                }

                // ----------------------
                // 
                if (m_ChamberReact[ch])
                {
                    mStep.Chamber_MaintainUse = false;
                    m_ChamberReact[ch] = false;
                }

                CurStInfo.m_steplist[CurrentNo] = mStep;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step = mStep;
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].ResetInStep();
                m_ucCycler_ABT_List[boardid].SetStartTime(bzch);

                // -
                // Reset
                // -
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Mainframe[CurrentStepStart::4020] - " + ex.Message);
                EndTest2ndStep(ch);
                return false;
            }

            // ----------
            //
            // ----------
            CurStInfo.isTempPaused = false;
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused = false;

            // -----------
            // 230621 BGH
            // -----------
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;

            // ------------------
            // Initial Voltage
            // ------------------
            CurStInfo.LastInitVoltage = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;


            // ---------------------
            // 첫번째 로그 기록위해.
            // ---------------------
            CurStInfo.isRised = true;

            // ghbaik2
            m_ucStepInfo_List[ch] = CurStInfo;

            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(ch);
            // ----------------------------------------------------
            // 231101, BGH
            // ----------------------------------------------------
            m_dispChStatus.ch_s_Step_No = CurrentNo + 1;
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            // 챔버대기때 스텝번호 적용을 위해, 일단 Save
            // -

            m_dispChStatus.ch_s_CutOffType = eNUM_CutOFF_Type.NONE; // ghbaik
            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.NONE; // ghbaik

            m_dispChStatus.SafetyWarmingUp = false;  // Safety 설정이 끝났음. 즉, 정식 Step 실행

            // --
            //
            // --
            string stepmsg = ">> Start Step // " + CurStInfo.m_steplist[CurrentNo].steptype.ToString();

            logopt[ch] = 0;

            // -----------------------------
            // 230911
            // -----------------------------
            // 231126 주석처리함, 이유 : 더이상 사용하지 않음
            //if (log_volt.Count > 0) log_volt.Clear();
            //if (log_curr.Count > 0) log_curr.Clear();
            //if (log_temp.Count > 0) log_temp.Clear();
            // -------------------------------------------
            // 231126, 변경된 delta 계산 알고리즘 적용
            // -------------------------------------------
            log_volt_delta[ch] = -1;  // NOT Use
            log_volt_backup[ch] = -1;  // NOT Use
            if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Volt >= 0.001)
            {
                log_volt_delta[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Volt;  // Use
                log_volt_backup[ch] = 0;  // Use
            }

            log_curr_delta[ch] = -1;  // NOT Use
            log_curr_backup[ch] = -1;  // NOT Use
            if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Curr >= 0.001)
            {
                log_curr_delta[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Curr;  // Use
                log_curr_backup[ch] = 0;  // Use
            }

            log_temp_delta[ch] = -50;  // NOT Use
            log_temp_backup[ch] = -1;  // NOT Use
            if (CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Temp >= 0.01)
            {
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T > -40 &&
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T < 100)
                {
                    log_temp_delta[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Temp;  // Use
                    log_temp_backup[ch] = 0;  // Use
                }
            }

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            // -----------------------------
            // Chamber 조건 먼저 검사
            // ------------------------------
            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = false;
            if (m_ucChamber.EnableFlag && 
               (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.Rest ||
                CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.OCV) )
            {                
                if (CurStInfo.m_steplist[CurrentNo].Chamber_Enable)
                {
                    if (!m_ucChamber.isConnected)
                    {
                        m_ucChamber.StartSerial();
                    }

					if (m_ucChamber.isConnected)
					{
						if (CurStInfo.m_steplist[CurrentNo].Chamber_MaintainUse)
						{
                            // ----------------------------------------------------------------------------------------
                            // 230830 LGES 테스트 중 방전 후 REST 모드 Chamber 온도 기다리는 중에 계속 방전되는 버그
                            // 231128
                            // ----------------------------------------------------------------------------------------
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            //if (m_RestOptionStandby) m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            //else m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.CC, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);

                            // -----------------------------------------------------------------------
                            // if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP)
                            // -----------------------------------------------------------------------
                            // 최초 실행에도 기존 설정 온도와 현재 설정이 같으면 챔버는 안돌리고 무한루프처럼 될 수 있음
                            // 230926, BGH
                            // -----------------------------------------------------------------------
                            if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP || ChlistMaintain.Count < 1)
                            {
                                //m_ucChamber.StopAction();

                                m_ucChamber.SP = CurStInfo.m_steplist[CurrentNo].Chamber_SP;
                                //+ Add by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                                m_ucChamber.HUMIDITY_S = CurStInfo.m_steplist[CurrentNo].Chamber_Humidity_S;
                                //-
                                m_ucChamber.Inclination = 1; // 1.0f;
                                //m_ucChamber.SendWriteSPValue();
                                //Thread.Sleep(100);
                                //WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
                                {
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
                                {
                                    m_ucChamber.SendWriteSPValue();
                                    Thread.Sleep(100);
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else
                                {
								m_ucChamber.SendWriteSPValue();
                                Thread.Sleep(100);
                                WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                }

                                //+ Add by LBG - 231120 : 알람 후 작업 재 진행 시 해당 채널 정보가 있는지 판별하기 위하여 추가
                                if (!m_ucChamber.Ch_Exist(ch))
                                {
                                    m_ucChamber.AddCh(ch);
                                }
                                //-

                                m_ucChamber.StartAction();
                                
                                m_ucChamber.DoesWorking = true;

                                WriteSystemLog(ch, ">> Chamber Start", false);
							}
							else
							{
								WriteSystemLog(ch, ">> Chamber Start [Skip-Same SP]", false);
							}

                            // -----------------------------------------
                            // BGH
                            // +
                            SetChamberMaintainSetting(ch);
                            // -
							m_ChamberReact[ch] = true;

							m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_ChamberWarming = true;
							WriteSystemLog(ch, ">> Chamber on SP=" + m_ucChamber.SP.ToString() + " w/ Waiting", false);

                            // ---------------------------------------------
                            // logging 조건을 REST 조건으로
                            // ---------------------------------------------
                            logCond[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time / 100;  // 10ms 단위
                            if (logCond[ch] < 1) logCond[ch] = 1;
                            logBuff[ch] = logCond[ch];

                            // ---------------------------------------------
                            // Test중임을 표시
                            // ---------------------------------------------
                            IsOnTesting[ch] = true;
                            return false;
						}
					}
                }
            }

            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chiller_Enable)
                {
                    if (!m_ucChiller[ch].isConnected)
                    {
                        m_ucChiller[ch].StartSerial();
                        WriteSystemLog(ch, ">> Chiller Re-Start_"+ ch.ToString() + "CH", false);
                    }

                    m_ucChiller[ch].SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP;
                    m_ucChiller[ch].Flow_SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP_Flow;

                    WriteSystemLog(ch, ">> Chiller Start_" + ch.ToString() + "CH", false);

                    m_ucChiller[ch].StartAction();
                    m_ucChiller[ch].DoesWorking = true;

                    IsOnTesting[ch] = true;

                    return false;
                }
            }
            //-
            //-

            // m_ChamberReact[ch] = false;  // 230913, BGH
            logopt[ch] = 0;
            string stypemode = "";


            //if (CurStInfo.m_steplist[CurrentNo].steptype > cls_stepInfo.enumStepType.CYCLE_END &&
            //    CurStInfo.m_steplist[CurrentNo].steptype != cls_stepInfo.enumStepType.Rest)
            //{
            //    int mmm = 0;
            //}

            switch (CurStInfo.m_steplist[CurrentNo].steptype)
            {
                case cls_stepInfo.enumStepType.CYCLE_START:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CYCLE_START;
                    break;

                case cls_stepInfo.enumStepType.CYCLE_END:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CYCLE_END;
                    break;

                case cls_stepInfo.enumStepType.Pattern:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PATTERN;
                    break;


                case cls_stepInfo.enumStepType.MBT:

                case cls_stepInfo.enumStepType.MCZ:  // ghbaik
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.ACIA;
                    break;

                case cls_stepInfo.enumStepType.Charge:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.CHARGE;
                    break;

                case cls_stepInfo.enumStepType.Discharge:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.DISCHARGE;
                    break;

                case cls_stepInfo.enumStepType.Rest:
                    //case cls_stepInfo.enumStepType.UDDS_REST:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.REST;
                    break;

                // ghbaik
                case cls_stepInfo.enumStepType.OCV:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.OCV;
                    break;

                // ghbaik
                case cls_stepInfo.enumStepType.WORK_END:
                case cls_stepInfo.enumStepType.WORK_END_wALARM:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.WORK_END;
                    break;

                case cls_stepInfo.enumStepType.Pause:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.PAUSE;
                    break;

                case cls_stepInfo.enumStepType.Ready:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.READY;
                    break;

                    // 231027, BGH
                case cls_stepInfo.enumStepType.InsulationTest:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.INSULATE;
                    break;

                default:
                    m_dispChStatus.ch_s_Step_Type = STEP_TYPE.NONE;
                    break;
            }

            // ------
            // display status
            // -----
            #region
            m_dispChStatus.isTesting = true;
            m_dispChStatus.ch_s_Step_No = CurrentNo + 1;
            m_dispChStatus.ch_s_isPaused = false;
            m_dispChStatus.ch_s_Step_Time = DateTime.Now;
            m_dispChStatus.ch_s_Spent_Time = new TimeSpan(0, 0, 0, 0, 0);
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            #endregion

            m_timelimit[ch] = -1;

            // 240102, BGH
            bool isVover = false;
            double curV = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_V;

            bool doEndCurStep = false;            
            switch (CurStInfo.m_steplist[CurrentNo].steptype)
            {
                case cls_stepInfo.enumStepType.CYCLE_START:
                    #region
                    // -------- gw123---------------------
                    // Cycle Start는 아무일 안하고 다음 Step으로 이동한다.
                    // -----------------------------------
                    CurStInfo.START_CYCLE();
                    doEndCurStep = true;

                    stypemode = "C_START";
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.CYCLE_END:
                    #region
                    
                    // 반복 카운트를 하나 빼고, 가장 가까운 위에 있는 Cycle Start로 간다.
                    // Nested Loop 처리. (gw123)                        
                    // ---------------------------------------------
                    // 현재 카운트 정리
                    // ---------------------------------------------                    
                    int m_count = CurStInfo.m_steplist[CurrentNo].operaCondition.mValue - 1;
                    int stepidx = -1;  // p3p

                    stypemode = "C_END [" + (m_count + 1).ToString() + "]";

                    CurStInfo.m_totCycle++;
                    cls_stepInfo.struStep m2_step = CurStInfo.m_steplist[CurrentNo];
                    m2_step.operaCondition.mValue = m_count;

                    if (m_count > 0)
                    {
                        //cls_stepInfo.struStep m2_step = CurStInfo.m_steplist[CurrentNo];
                        //m2_step.operaCondition.mValue = m_count;
                        //CurStInfo.m_steplist[CurrentNo] = m2_step;

                        // CYCLE START로 이동. 
                        CurStInfo.m_islooping = false;
                        for (int i = 0; i < CST_CyclingSize; i++)
                        {
                            if (cycling[ch, i, 1] == CurrentNo)
                            {
                                stepidx = cycling[ch, i, 0];
                                CurStInfo.m_islooping = true;
                                break;
                            }
                        }

                        if (stepidx != -1)
                        {
                            CurStInfo.m_currentStepNo = stepidx;
                            m_currentStep[ch] = stepidx;
                        }


                    }
                    else
                    {
                        CurStInfo.m_islooping = false;
                        for (int i = 0; i < CST_CyclingSize; i++)
                        {
                            if (cycling[ch, i, 1] == CurrentNo)
                            {
                                m2_step.operaCondition.mValue = cycling[ch, i, 2];
                                break;
                            }
                        }
                    }                    
                    CurStInfo.m_steplist[CurrentNo] = m2_step;

                    CurStInfo.END_CYCLE();
                    m_ucStepInfo_List[ch] = CurStInfo;

                    doEndCurStep = true;

                    //CurStInfo.m_depthCycle--;  // ghbaik
                    //if (CurStInfo.m_depthCycle < 0) CurStInfo.m_depthCycle = 0;
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.MBT:
                    #region
                    if (m_clsAppSet.Enable_Set.Enable_ACIR)
                    {
                        stypemode = "MBT";
                        m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                        CurStInfo.isRised = false;  // 231005, BGH

                        // 240102, BGH
                        if (!isResumeStart)
                        {
                            WriteRegLog(ch, true, false, false);
                        }

                        //+ Revision by YMJ - 240304 : MBT 측정 대기 제한 제거
                        m_timelimit[ch] = -1;
                        //-
                        // ----------------------------------------
                        // 240115 BGH
                        // ControlEnabled 추가
                        // ----------------------------------------
                        if (m_ucMbT_List[ch] != null && m_ucMbT_List[ch].ControlEnabled)
                        {
                            if (m_ucMbT_List.Count > ch)
                            {
                                int midx = m_clsSys_Link.Get_MBT_Index(ch);
                                m_ucMbT_List[ch].strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_IP;
                                m_ucMbT_List[ch].strTCPPort = "2000"; //.strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_TCP_Port;

                                m_ucMbT_List[ch].AutoDisconnect = false;  // 240115, 자동 disconnect 방지
                                m_ucMbT_List[ch].RetryCount = 0;
                                if (m_ucMbT_List[ch].isConnected)
                                {
                                    m_ucMbT_List[ch].STOPAcia();
                                    m_ucMbT_List[ch].DisCoNnect();
                                }
                                m_ucMbT_List[ch].CONnect();

                                //+ Revision by YMJ - 240304 : MBT 측정 대기 제한 제거
                                //m_timelimit[ch] = 240;  // 4 min, 240 sec
                                //-
                            }
                        }
                    }
                    else
                    {
                        stypemode = "MBT-Not supported";
                        doEndCurStep = true;
                    }                    
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.MCZ:
                    #region
                    if (m_clsAppSet.Enable_Set.Enable_ACIR)
                    {
                        //+ Revisioin by YMJ - 250213 : MxZ 스텝 시작 방식 변경
                        stypemode = "MxZ";

                        m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                        CurStInfo.isRised = false;  // 231005, BGH
                        m_timelimit[ch] = -1;
                        if (m_ucMcz_List == null)
                        {
                            doEndCurStep = true;
                        }
                        if (m_ucMcz_List[ch] != null)
                        {
                            if (m_ucMcz_List.Count > ch)
                            {
                                int midx = m_clsSys_Link.Get_MxZ_Index(ch);
                                m_ucMcz_List[ch].IPADDRESS = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_IP;
                                m_ucMcz_List[ch].PORT = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_Port;

                                m_ucMcz_List[ch].COMMRETRYCNT = 0;
                                if (m_ucMcz_List[ch].isConnected)
                                {
                                    m_ucMcz_List[ch].StopACIR();
                                    m_ucMcz_List[ch].DisConnect();
                                }
                                m_ucMcz_List[ch].Connect();

                                //m_timelimit[ch] = 240;  // 4 min, 240 sec
                            }
                        }
                        //-
                    }
                    else
                    {
                        stypemode = "MxZ-Not supported";
                        doEndCurStep = true;
                    }                    
                    #endregion
                    break;

                case cls_stepInfo.enumStepType.Pattern:
                    stypemode = "PATTERN";

                    //m_ucCycler_ABT_List[boardid].Write_CC_PacketABT(bzch, 0, 0, false);
                    CurStInfo.isRised = false;

                    string pattern_path = CurStInfo.m_steplist[CurrentNo].strPath;

                    doPatternLog[ch] = 0;
                    //+ Revision by YMJ - 241014 : 패턴 스텝 돌릴 시 pattern 파일이 없을 경우 알람 띄움)
                    if (!m_ucUDDS_List[ch].SetPatternPath(pattern_path)) 
                    {
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        AddAlarm(ch, ABT.TypeOfSafetyViolation.ETC, "[ETC001]No Pattern File");
                        //-
                        SuspendCurrentStep(ch, "No Pattern File");
                        WriteSystemLog(ch, ">> Pattern File is not exist", true);
                        return false;
                    }
                    //-
                    break;

                case cls_stepInfo.enumStepType.Charge:
                case cls_stepInfo.enumStepType.Discharge:

                case cls_stepInfo.enumStepType.Rest:
                case cls_stepInfo.enumStepType.OCV:  // ghbaik
                    #region
                    double refvalue = 0.0, secondvalue = 0.0;

                    cls_devCyclerABT.struCyclerStatus chlist = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];

                    // ---------------------------
                    // Board Index : base 0
                    // ---------------------------
                    refvalue = 0.0;
                    secondvalue = 0.0;

                    chlist.CVTargetVoltage = 0;
                    chlist.isFirstPattern = false;

                    switch (CurStInfo.m_steplist[CurrentNo].stepmode)
                    {
                        case cls_stepInfo.enumStepMode.REST:
                            stypemode = "REST";
                            if (m_RestOptionStandby)
                            {
                                chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                                m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, true);
                                
                                stypemode += "(StandBy)";
                            }
                            else
                            {
                                m_ucCycler_ABT_List[boardid].Write_Rest_PacketABT_byCC0A(bzch);
                                stypemode += "(0A CC)";
                            }
                            CurStInfo.isRised = false;

                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            break;
                        case cls_stepInfo.enumStepMode.STANDBY:
                            stypemode = "STANDBY";
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            break;
                        case cls_stepInfo.enumStepMode.OCV:
                            stypemode = "OCV";

                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;

                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, true);
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;

                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CC:                            
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CC; // ghbaik

                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CC-Charge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltCurrent;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CC-Discharge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltCurrent;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            // m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            m_ucCycler_ABT_List[boardid].Write_CC_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + stypemode + " // I=" + refvalue.ToString("F3"));

                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CV:
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CV; // ghbaik

                            // -----------------------------------------------------------------
                            // 최초 인가 전류를 CV에서는 CutOff 전류의 1.1배.
                            // 예로, CutOff 전류가 1A라면 최초 전류가 1.1A보다 커지면 스텝 시작
                            // 231019, BGH
                            // -----------------------------------------------------------------
                            // double cutoffI = CurStInfo.m_steplist[CurrentNo].cutoffCondition.CutOff_I * 1.1;
                            double cutoffI = CurStInfo.m_safety.safety_curr_h * 0.99;
                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CV-Charge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltVolt;
                                    if (refvalue < 0)
                                    {
                                        refvalue = Math.Abs(refvalue);
                                    }
                                    if (cutoffI < 0)
                                    {
                                        cutoffI = Math.Abs(refvalue);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) <= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CV-Discharge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltVolt;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1);
                                    }
                                    if (cutoffI > 0)
                                    {
                                        cutoffI *= (-1);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) >= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;
                            }

                            stepmsg += (" // " + stypemode + " // I=" + refvalue.ToString("F3"));
                            // ------------------------------
                            // 240102, BGH
                            // ------------------------------
                            if (isVover) { break; }

                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            m_ucCycler_ABT_List[boardid].Write_CV_PacketABT(bzch, refvalue, cutoffI);
                            // stepmsg += (" // " + stypemode + " // I=" + refvalue.ToString("F3"));

                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CCCV:
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CCCV; // ghbaik

                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CC/CV-Charge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltVolt;
                                    secondvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltCurrent;
                                    if (secondvalue < 0)
                                    {
                                        secondvalue *= (-1.0);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) <= curV)
                                    {
                                        isVover = true;
                                    }
                                    break;

                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CC/CV-Charge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltVolt;
                                    secondvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltCurrent;
                                    if (secondvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                        secondvalue *= (-1.0);
                                    }

                                    // 240102, BGH
                                    if (curV > 0 && Math.Abs(refvalue) >= curV)
                                    {
                                        isVover = true;                                        
                                    }
                                    break;
                            }
                            stepmsg += (" // " + stypemode + " // V=" + refvalue.ToString("F3") + " // I=" + secondvalue.ToString("F3"));

                            // ------------------------------
                            // 240102, BGH
                            // ------------------------------
                            if (isVover) { break; }


                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            
                            // -----------------------------------------------
                            // 새로운 Cycler는 CC/CV에서 무조건 1.7초 소비함
                            // 따라서, CC로 먼저 인가하고 나중에 CC/CV로 전환
                            // -----------------------------------------------                            
                            chlist.SetV = 0;
                            chlist.SetI = 0;
                            if (m_newtype_cycler)
                            {                                
                                chlist.SetV = refvalue;
                                chlist.SetI = secondvalue;
                                
                                m_ucCycler_ABT_List[boardid].Write_CC_PacketABT(bzch, secondvalue, 0, false);
                            }
                            else
                            {
                                m_ucCycler_ABT_List[boardid].Write_CCCV_PacketABT(bzch, refvalue, secondvalue);
                            }
                            chlist.CVTargetVoltage = refvalue;

                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;

                            // stepmsg += (" // " + stypemode + " // V=" + refvalue.ToString("F3") + " // I=" + secondvalue.ToString("F3"));
                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CP:                            
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CP; // ghbaik

                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CP-Charge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CP-Discharge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            //m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            m_ucCycler_ABT_List[boardid].Write_CP_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + stypemode + " // P=" + refvalue.ToString("F3"));

                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CR:
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CR; // ghbaik

                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CR-Charge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CR-Discharge";
                                    refvalue = CurStInfo.m_steplist[CurrentNo].operaCondition.fltValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            //m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            m_ucCycler_ABT_List[boardid].Write_CR_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + stypemode + " // R=" + refvalue.ToString("F3"));

                            CurStInfo.isRised = false;
                            break;

                        case cls_stepInfo.enumStepMode.CPCV_CP:
                            m_dispChStatus.ch_s_Step_Mode = STEP_MODE.CPCV; // ghbaik
                            secondvalue = 0;
                            switch (CurStInfo.m_steplist[CurrentNo].steptype)
                            {
                                case cls_stepInfo.enumStepType.Charge:
                                    stypemode = "CP/CV-Charge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltCPValue;
                                    if (refvalue < 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                                case cls_stepInfo.enumStepType.Discharge:
                                    stypemode = "CP/CV-Charge";
                                    refvalue = (double)CurStInfo.m_steplist[CurrentNo].operaCondition.fltCPValue; //.fltValue; // .fltCPValue;
                                    if (refvalue > 0)
                                    {
                                        refvalue *= (-1.0);
                                    }
                                    break;
                            }
                            //m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;
                            m_ucCycler_ABT_List[boardid].Write_CP_PacketABT(bzch, refvalue, secondvalue, false);
                            stepmsg += (" // " + stypemode + " // P=" + refvalue.ToString("F3"));
                            CurStInfo.isRised = false;
                            break;

                        default:
                            stypemode = "DEFAULT";
                            m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                            break;
                    }
                    #endregion

                    #region
                    if (m_clsAppSet.Enable_Set.Enable_ACIR)
                    {
                        if (CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MBT_ON ||
                            CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MBT_ON_W_CYCLER)
                        {
                            m_timelimitSUB[ch] = 5;

                            if (m_ucMbT_List[ch] != null)
                            {
                                // ----------------------------------------
                                // 240115 BGH
                                // ControlEnabled 추가
                                // ----------------------------------------
                                if (m_ucMbT_List.Count > ch && m_ucMbT_List[ch].ControlEnabled)
                                {
                                    int midx = m_clsSys_Link.Get_MBT_Index(ch);
                                    m_ucMbT_List[ch].strTCPIP = m_clsSys_Set.m_Sys_MBT[midx].MBT_IP;
                                    m_ucMbT_List[ch].strTCPPort = "2000";

                                    m_ucMbT_List[ch].AutoDisconnect = false;  // 240115, 자동 disconnect 방지
                                    if (m_ucMbT_List[ch].isConnected)
                                    {
                                        m_ucMbT_List[ch].STOPAcia();
                                        m_ucMbT_List[ch].DisCoNnect();
                                    }

                                    m_ucMbT_List[ch].CONnect();

                                    m_timelimitSUB[ch] = 240;  // 4 min, 240 sec
                                }
                            }
                        }

                        if (CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MXZ_ON ||
                            CurStInfo.m_steplist[CurrentNo].acia_status == cls_stepInfo.StepACIA.MXZ_ON_W_CYCLER)
                        {
                            bool isTcpOK = true;                            

                            m_timelimitSUB[ch] = 5;

                            if (m_ucMcz_List == null) doEndCurStep = true;
                            if (m_ucMcz_List[ch] != null)
                            {
                                if (m_ucMcz_List.Count > ch)
                                {
                                    //+ Revisioin by YMJ - 250213 : MxZ 스텝 시작 방식 변경
                                    int midx = m_clsSys_Link.Get_MxZ_Index(ch);
                                    m_ucMcz_List[ch].IPADDRESS = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_IP;
                                    m_ucMcz_List[ch].PORT = m_clsSys_Set.m_Sys_MCZ[midx].MCZ_Port;
                                    
                                    m_ucMcz_List[ch].COMMRETRYCNT = 0;
                                    if (m_ucMcz_List[ch].isConnected)
                                    {
                                        m_ucMcz_List[ch].StopACIR();
                                        m_ucMcz_List[ch].DisConnect();
                                    }
                                    m_ucMcz_List[ch].Connect();

                                    m_timelimitSUB[ch] = 240;  // 4 min, 240 sec
                                    //-
                                }
                            }

                            if (!isTcpOK)
                            {
                                doEndCurStep = true;
                            }
                        }
                    }
                    #endregion
                    break;

                // ghbaik
                case cls_stepInfo.enumStepType.WORK_END:
                    stypemode = "END";
                    EndTest(ch);
                    break;

                case cls_stepInfo.enumStepType.InsulationTest:
                    bool pass = true;

                    if (m_clsAppSet.Enable_Set.Enable_Insulate)
                    {
                        stypemode = "IT";
                        m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                        CurStInfo.isRised = false;  // 231005, BGH
                        
                        if (m_ucIT_List[ch] != null)
                        {
                            //+ Revision by YMJ - 240523 : 절연저항기 측정 시 List 체크 오류 수정(mbt list -> IT List)
                            if (m_ucIT_List.Count > ch)
                            //-
                            {
                                if (m_ucIT_List[ch].ControlEnabled)
                                {
                                    if (m_ITType[ch]) m_timelimit[ch] = (short)(m_IT_TestTime[ch] * 2 + 10);
                                    else m_timelimit[ch] = (short)(m_IT_TestTime[ch] + 5);

                                    if (m_ucIT_List[ch].InsConnected())
                                    {
                                        pass = false;
                                    }
                                }
                            }
                        }
                    }

                    if (pass)
                    {
                        stypemode = "IT-Not supported";
                        doEndCurStep = true;
                    }
                    break;

                case cls_stepInfo.enumStepType.Pause:
                    stypemode = "PAUSE";
                    m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    break;

                case cls_stepInfo.enumStepType.Ready:
                    stypemode = "READY";
                    // DO NOT Anything
                    break;

                default:
                    // --------------------
                    // Error Handling
                    // - ------------------
                    stypemode = "ELSE..";
                    doEndCurStep = true;
                    break;
            }

            // --------------------------------------------------
            // 240102, BGH
            // --------------------------------------------------
            if (isVover)
            {
                WriteRegLog(ch, true, false, false);

                if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.Charge)
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(ch, ABT.TypeOfSafetyViolation.OverVolt, "[CYC014]OVP[Target Voltage]");
                    //-
                    SuspendCurrentStep(ch, "OVP[CV/CCCV]");
                }
                else
                {
                    //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                    AddAlarm(ch, ABT.TypeOfSafetyViolation.UnderVolt, "[CYC015]UVP[Target Voltage]");
                    //-
                    SuspendCurrentStep(ch, "UVP[CV/CCCV]");
                }
                WriteSystemLog(ch, stepmsg, true);
                return false;
            }
            // -

            // -------------------------------------------
            // Chamber
            // 온도만 설정하고 다음스텝으로 넘어가는 경우..
            // -------------------------------------------
            if (m_ucChamber.EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chamber_Enable)
                {
                    if (!m_ucChamber.isConnected)
                    {
                        m_ucChamber.StartSerial();
                    }

					if (m_ucChamber.isConnected)
					{
						if (!CurStInfo.m_steplist[CurrentNo].Chamber_MaintainUse)
						{
                            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                            if (m_ucChamber.SP != CurStInfo.m_steplist[CurrentNo].Chamber_SP)
							{
                                //m_ucChamber.StopAction();

                                m_ucChamber.SP = CurStInfo.m_steplist[CurrentNo].Chamber_SP;
                                //+ Add by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                                m_ucChamber.HUMIDITY_S = CurStInfo.m_steplist[CurrentNo].Chamber_Humidity_S;
                                //-
                                m_ucChamber.Inclination = 1; // 1.0f;
                                //m_ucChamber.SendWriteSPValue();
                                //Thread.Sleep(100);
                                //WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                                if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.SIMPAC)
                                {
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
                                }
                                else if (m_ucChamber.ChamberType == cls_devChamber.Chamber_Type.TEMI2500)
								{
                                    m_ucChamber.SendWriteSPValue();
                                    Thread.Sleep(100);
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + "// Humidity_S=" + m_ucChamber.HUMIDITY_S.ToString() + " // PV=" + m_ucChamber.PV.ToString() + "// Humidity_P=" + m_ucChamber.HUMIDITY_P.ToString(), false);
							}
							else
							{
                                    m_ucChamber.SendWriteSPValue();
                                    Thread.Sleep(100);
                                    WriteSystemLog(ch, ">> Chamber Direction=" + ChamberDirection.ToString() + "// SP=" + m_ucChamber.SP.ToString() + " // PV=" + m_ucChamber.PV.ToString(), false);
                            }

                                //+ Add by LBG - 231120 : 알람 후 작업 재 진행 시 해당 채널 정보가 있는지 판별하기 위하여 추가
                                if (!m_ucChamber.Ch_Exist(ch))
                                {
                                    m_ucChamber.AddCh(ch);
                                }
                                //-

                                m_ucChamber.StartAction();
								m_ucChamber.DoesWorking = true;

                                WriteSystemLog(ch, ">> Chamber Start", false);

								if (m_ucChamberDIO.EnableFlag)
                                {
									m_ucChamberDIO.StartSerial();
									WriteSystemLog(ch, ">> Start Chamber DIO", false);
                                }
                            }
							else
							{
								WriteSystemLog(ch, ">> Chamber Start [Skip-Same SP]", false);
							}
							WriteSystemLog(ch, ">> Chamber on SP=" + m_ucChamber.SP.ToString() + " NO Waiting", false);
                            //-
						}
					}
                }
            }

            //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
            // ------------------
            // Chiller
            // ------------------
            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            //if (m_ucChiller.EnableFlag)
            if (m_ucChiller.ContainsKey(ch) && m_ucChiller[ch].EnableFlag)
            {
                if (CurStInfo.m_steplist[CurrentNo].Chiller_Enable)
                {
                    m_ucChiller[ch].SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP;
                    m_ucChiller[ch].Flow_SP = CurStInfo.m_steplist[CurrentNo].Chiller_SP_Flow;
                    m_ucChiller[ch].SendWriteSPValue();
                    Thread.Sleep(100);
                    m_ucChiller[ch].StartAction();                    

                    WriteSystemLog(ch, ">> Chiller on SP=" + m_ucChamber.SP.ToString() + ", Flow=" + m_ucChiller[ch].Flow_SP.ToString("F1"), false);  // BGH
                }
            }
            //-
            //-

            // -------------------------------------------
            // AUX && Balancing
            // -------------------------------------------
            #region
            if (m_BalancingEnable && m_ucBalancer_List != null)
            {
                if (m_ucBalancer_List.Count > ch)
                {
                    if (m_ucBalancer_List[ch].ControlEnabled)
                    {
                        bool bfind = false;
                        List<AUX_Volt_Recipe> vrcp = CurStInfo.m_steplist[CurrentNo].lstAUXVolt;
                        if (vrcp != null)
                        {
                            for (int i = 0; i < vrcp.Count(); i++)
                            {
                                if (vrcp[i].AUX_V_Recipe_Balance) { bfind = true; break; }
                            }
                        }
                        if (bfind) { balancingActivated[ch] = 1; }
                        else balancingActivated[ch] = 0;

                        // ------------------------------------------
                        // 밸런싱 조건
                        // balancingActivated[ch] == 1
                        // m_AUXEnableMain = true
                        // m_AUXValue[ch] 값이 들어 올 것.
                        // ------------------------------------------

                        if (balancingActivated[ch] == 1 && m_AUXEnable)
                        {
                            // ----------------------------------------------
                            // Balancing
                            // ----------------------------------------------
                            m_ucBalancer_List[ch].BalancingResis = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_R_Type;
                            m_ucBalancer_List[ch].ResetBalancingList();
                            double dstart = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Dev_Start * 0.001; // 0.001f;

                            // ------------------------------------------------------
                            // 밸런싱 대상 전압 중 최소값을 계산해 사용. 23.08.14
                            // ------------------------------------------------------
                            double vbmin = 999.99;
                            for (int i = 0; i < vrcp.Count(); i++)
                            {
                                if (vrcp[i].AUX_V_Recipe_Balance)
                                {
                                    if (m_AUX_Volt[ch, i] < vbmin) vbmin = m_AUX_Volt[ch, i];
                                }
                            }
                            if (vbmin > 10) vbmin = 0;

                            if (vbmin > 0)
                            {
                                for (int i = 0; i < vrcp.Count(); i++)
                                {
                                    if (vrcp[i].AUX_V_Recipe_Balance && vbmin > 0.1)
                                    {
                                        //Debug.WriteLine("m_AUXValue[i] - AUX_V_min = " + (m_AUXValue[i] - AUXDAU_V_min).ToString("F3"));
                                        if (m_AUX_Volt[ch, i] > CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Lower &&
                                            m_AUX_Volt[ch, i] < CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Upper &&
                                            (m_AUX_Volt[ch, i] - vbmin) > dstart)
                                        {
                                            // ---------------------------------------
                                            // 현재는 i 의 범위는 1부터 8까지이다.
                                            // ---------------------------------------
                                            m_ucBalancer_List[ch].SetBalancingMode(i + 1, true);
                                        }
                                    }
                                }

                                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = true;
                                m_ucBalancer_List[ch].isBalancing = true;
                                m_ucBalancer_List[ch].SendWriteCmdArray();
                            }

                        }
                    }
                }
            }
            #endregion

            CurStInfo.m_curCycle = CurStInfo.m_cyccount[CurStInfo.m_cycidx];

            // ----------------------------------------------
            // Cell CV 중복방지 flag을 clear하고 저장
            // 231002, BGH
            // ----------------------------------------------
            CurStInfo.isCellCVexecuted = false;
            m_ucStepInfo_List[ch] = CurStInfo;

            // ----------------------------
            // BMS Control Checking
            // ----------------------------
            #region
            if (m_clsAppSet.Enable_Set.Enable_CAN && m_CANEnable && m_NumOfCAN > ch && m_ucCAN_List[ch] != null)
            {
                // --------------------------------------------------
                // BMS 추종
                // --------------------------------------------------
                if (CurStInfo.m_steplist[CurrentNo].BMS_C_Use)
                {
                    ABT.MDBC_Info mydbc = new MDBC_Info();

                    // m_ucCANSigCtrl.Ch = ch;
                    mydbc.Signal_Addr = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Addr;
                    mydbc.Signal_Offset = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Offset;
                    mydbc.Signal_Size = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Size;
                    mydbc.Signal_Factor = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Factor;

                    m_ucCAN_List[ch].CC_COntrol = mydbc;
                    m_ucCAN_List[ch].CP_COntrol.Reset();

                    if (!m_ucCAN_List[ch].isConnected)
                    {
                        //+ Revision by YMJ - 250725 : CAN 연결 시 결과 로깅 추가
                        cls_devCAN.PCANReturnCode result;
                        if (m_ucCAN_List[ch].IS_FD_CAN) result = m_ucCAN_List[ch].StartPCANCommFD();
                        else result = m_ucCAN_List[ch].StartPCANComm();
                        if (result != cls_devCAN.PCANReturnCode.PCAN_OK)
                        {
                            WriteSystemLog("// CAN Connect Fail // Result : " + result.ToString());
                        }
                        else
                        {
                            WriteSystemLog("// CAN Connect Success // Result : " + result.ToString());
                        }
                        //-
                    }
                }
                else if (CurStInfo.m_steplist[CurrentNo].BMS_P_Use)
                {
                    ABT.MDBC_Info mydbc = new MDBC_Info();

                    //m_ucCANSigCtrl.Ch = ch;

                    mydbc.Signal_Addr = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_P.BMS_Addr;
                    mydbc.Signal_Offset = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_P.BMS_Offset;
                    mydbc.Signal_Size = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_P.BMS_Size;
                    mydbc.Signal_Factor = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_P.BMS_Factor;

                    m_ucCAN_List[ch].CP_COntrol = mydbc;

                    mydbc.Signal_Addr = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Addr;
                    mydbc.Signal_Offset = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Offset;
                    mydbc.Signal_Size = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Size;
                    mydbc.Signal_Factor = CurStInfo.m_steplist[CurrentNo].BMS_Work_Info_C.BMS_Factor;

                    m_ucCAN_List[ch].CC_COntrol = mydbc;

                    if (!m_ucCAN_List[ch].isConnected)
                    {
                        //+ Revision by YMJ - 250725 : CAN 연결 시 결과 로깅 추가
                        cls_devCAN.PCANReturnCode result;
                        if (m_ucCAN_List[ch].IS_FD_CAN) result = m_ucCAN_List[ch].StartPCANCommFD();
                        else result = m_ucCAN_List[ch].StartPCANComm();
                        if (result != cls_devCAN.PCANReturnCode.PCAN_OK)
                        {
                            WriteSystemLog("// CAN Connect Fail // Result : " + result.ToString());
                        }
                        else
                        {
                            WriteSystemLog("// CAN Connect Success // Result : " + result.ToString());
                        }
                        //-
                    }
                }
                else
                {
                    m_ucCAN_List[ch].CC_COntrol.Reset();
                    m_ucCAN_List[ch].CP_COntrol.Reset();
                }

                //+ Revision by YMJ - 250716 : CAN 사용일 경우에만 연결
                if (m_ucCAN_List[ch].ControlEnabled && !m_ucCAN_List[ch].isConnected && CurStInfo.m_steplist[CurrentNo].CAN_Use) 
                //-
                {
                    // ----------------------------------------------------
                    // CAN Open
                    // ----------------------------------------------------
                    cls_devCAN.PCANReturnCode result;
                    if (m_ucCAN_List[ch].IS_FD_CAN) result = m_ucCAN_List[ch].StartPCANCommFD();
                    else result = m_ucCAN_List[ch].StartPCANComm();
                    if (result != cls_devCAN.PCANReturnCode.PCAN_OK)
                    {
                        WriteSystemLog("// CAN Connect Fail // Result : " + result.ToString());
                    }
                    else
                    {
                        WriteSystemLog("// CAN Connect Success // Result : " + result.ToString());
                    }
                }
            }

            //+ Revision by YMJ - 250716 : CAN 통신 연결 후로 셋업 부분 이동
            // ------------------------------
            // CAN
            // --------------------------
            if (m_CANEnable && m_clsAppSet.Enable_Set.Enable_CAN)
            {
                if (CurStInfo.m_steplist[CurrentNo].steptype > cls_stepInfo.enumStepType.CYCLE_END &&
                    CurStInfo.m_steplist[CurrentNo].stepmode <= cls_stepInfo.enumStepMode.InsulationTest)
                {
                    if (m_ucCAN_List[ch] != null && m_ucCAN_List[ch].ControlEnabled && m_ucCAN_List[ch].isConnected)
                    {
                        //+ Revisiojn by YMJ - 250717 : CAN 정보 상시 디스플레이 옵션 시 Safety 및 Cutoff 적용을 위해 수정
                        //+ Revision by YMJ - 241018 : CAN 정보 상시 디스플레이 옵션 추가
                        if (!m_alwaysLog)
                        {
                            if (CurStInfo.m_steplist[CurrentNo].CAN_Use && CurStInfo.MDBC_List_Safety != null)
                            {
                                m_ucCAN_List[ch].CAN_List.Clear();
                                for (int i9 = 0; i9 < CurStInfo.MDBC_List_Safety.Count; i9++)
                                {
                                    cls_devCAN.MDBC_PARSE mdbc = new cls_devCAN.MDBC_PARSE();
                                    try
                                    {
                                        //+ Revision by YMJ - 241008 : MDBC 정보 로드 추가
                                        mdbc.CutOffCheck = false;
                                        mdbc.Name = CurStInfo.MDBC_List_Safety[i9].Signal_Name;
                                        mdbc.Addr = (uint)CurStInfo.MDBC_List_Safety[i9].Signal_Addr;
                                        mdbc.sBit = CurStInfo.MDBC_List_Safety[i9].Signal_SBit;
                                        mdbc.Size = CurStInfo.MDBC_List_Safety[i9].Signal_Size;
                                        mdbc.ByteOrder = CurStInfo.MDBC_List_Safety[i9].Signal_ByteOrder;
                                        mdbc.Type = CurStInfo.MDBC_List_Safety[i9].Signal_Type;
                                        mdbc.Factor = CurStInfo.MDBC_List_Safety[i9].Signal_Factor;
                                        mdbc.Offset = CurStInfo.MDBC_List_Safety[i9].Signal_Offset;
                                        //-

                                        //+ Revision by YMJ - 241028 : value가 0일 수도 있으므로 수정 적용
                                        mdbc.Value = -999999;
                                        //-

                                        mdbc.CutOff_L = CurStInfo.MDBC_List_Safety[i9].CAN_Cut_Lower;
                                        mdbc.CutOff_H = CurStInfo.MDBC_List_Safety[i9].CAN_Cut_Upper;
                                        mdbc.Safety_L = CurStInfo.MDBC_List_Safety[i9].CAN_Safty_Lower;
                                        mdbc.Safety_H = CurStInfo.MDBC_List_Safety[i9].CAN_Safty_Upper;
                                    }
                                    catch { }
                                    m_ucCAN_List[ch].Add_DBCList(mdbc);
                                }
                            }
                            else
                            {
                                m_ucCAN_List[ch].Reset_DBCList();
                            }

                            if (CurStInfo.m_steplist[CurrentNo].CAN_Use && CurStInfo.MDBC_List_Safety != null && CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info != null)
                            {
                                try
                                {
                                    List<cls_devCAN.MDBC_PARSE> mdbc_list = m_ucCAN_List[ch].CAN_List;
                                    for (int i9 = 0; i9 < CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info.Count; i9++)
                                    {
                                        CAN_CUT_OFF_INFO mdbc_cut = CurStInfo.m_steplist[CurrentNo].CAN_CutOff_Info[i9];
                                        if (mdbc_cut.CAN_INDEX >= 0 && mdbc_cut.CAN_INDEX < m_ucCAN_List[ch].CAN_List_Count)
                                        {
                                            cls_devCAN.MDBC_PARSE mdbc = mdbc_list[mdbc_cut.CAN_INDEX];
                                            mdbc.CutOffCheck = true;
                                            mdbc.CutOff_L = mdbc_cut.CAN_Cut_Lower;
                                            mdbc.CutOff_H = mdbc_cut.CAN_Cut_Upper;
                                            mdbc.moveStep = mdbc_cut.CAN_Move_Step;
                                            mdbc_list[mdbc_cut.CAN_INDEX] = mdbc;
                                        }
                                    }
                                }
                                catch { }
                            }
                        }
                        //+ Revision by YMJ - 251027 : CAN 정보 상시 디스플레이 옵션 시 CAN LIST 업데이트 제거 
                        //-
                        //-

                        if (m_CANTXSend != null && m_CANTXSendThread != null && CurStInfo.m_steplist[CurrentNo].CAN_TX_List != null)
                        {
                            m_CANTXSend[ch] = true;
                            m_CANTXSendThread[ch] = new Thread(() => startCANTXSend(ch, CurStInfo.m_steplist[CurrentNo].CAN_TX_List));
                            m_CANTXSendThread[ch].IsBackground = true;
                            m_CANTXSendThread[ch].Start();
                        }
                    }
                }
            }
            //-

            WriteSystemLog(ch, stepmsg, true);
            #endregion

            // ----------------------------
            // MBI
            // ----------------------------
            #region
            if (m_clsAppSet.Enable_Set.Enable_AUX && m_MBIEnable && m_NumOfMBI > ch)
            {
                if (m_ucMBI_List[ch/2].ControlEnabled && (!m_ucMBI_List[ch/2].isConnected))
                {
                    // ----------------------------------------------------
                    // CAN Open
                    // ----------------------------------------------------
                    if (m_ucMBI_List[ch/2].StartPCANComm() == cls_devMBI.PCANReturnCode.PCAN_OK)
                    {
                        m_ucMBI_List[ch/2].WriteStartCommandLaon();
                    }
                }
            }
            #endregion

            #region POWER SUPPLY
            if (CurStInfo.m_steplist[CurrentNo].PowerSupply_Enable)
            {
                if (m_ucPowerSupply_PT.isConnected)
                {
                    int sp = CurStInfo.m_steplist[CurrentNo].PowerSupply_V;
                    if (sp > 1 && sp < 50)
                    {
                        m_ucPowerSupply_PT.SetSPValue(CurStInfo.m_steplist[CurrentNo].PowerSupply_V);
                    }
                }
            }
            #endregion

            // ----------
            // TOS
            // ---------
            if ((CurStInfo.m_steplist[CurrentNo].steptype != cls_stepInfo.enumStepType.WORK_END) &&
                (CurStInfo.m_steplist[CurrentNo].steptype != cls_stepInfo.enumStepType.WORK_END_wALARM))
            {
                IsOnTesting[ch] = true;

                if (!tos_iswritting)
                {
                    WriteSystemLog(ch, ">> TOS logging", false);
                    WriteTOSLog(ch);
                }
            }

            // bbb, logCond[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time / 10;  // 10ms 단위
            logCond[ch] = CurStInfo.m_steplist[CurrentNo].wIntv.wCond_Time / 100;  // 10ms 단위
            if (logCond[ch] < 1) logCond[ch] = 1;
            logBuff[ch] = logCond[ch];
            //if (logBuff[ch] == 0) logBuff[ch] = logCond[ch];  // 최초 한번만 넣어주면 그 다음은 알아서 동작한다.

            return (doEndCurStep);
        }


        // --------------------------------------
        // Chamber
        // --------------------------------------
        public void SetChamberDirection(byte iDirection)
        {
            ChamberDirection = iDirection;

            // chamberIndex는 챔버가 여러개일때 사용하기 위해 미리 만들어 둠
            //List<int> chlist = m_ucChamber.ChList;
            //if (chlist == null) return;
            //if (chlist.Count < 1) return;
            
            //for (int i = 0; i < chlist.Count; i++)
            //{
            //    if (ChamberDirection.Length > chlist[i])
            //    {
            //        ChamberDirection[chlist[i]] = iDirection;
            //    }
            //}
        }

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        public void GotChamberTemp(double value_pv, double value_sp, double value_out)
        {
            try
            {
                #region 사용안함
                /*
                Display_Chamber_Data m_dispSP = new Display_Chamber_Data();
                Display_Chamber_Data m_dispPV = new Display_Chamber_Data();
                Display_Chamber_Data m_dispOUT = new Display_Chamber_Data();
                
                m_dispSP.Cham_Name = "Chamber SP[Setting]";
                m_dispSP.Cham_Value = value_sp.ToString("F2") + " (℃)";
                m_dispPV.Cham_Name = "Chamber PV[Measured]";
                m_dispPV.Cham_Value = value_pv.ToString("F2") + " (℃)";
                m_dispOUT.Cham_Name = "Chamber Out Ratio";
                m_dispOUT.Cham_Value = value_out.ToString("F1") + " (%)";

                m_ucChannel_Status.Disp_Chamber_Val.Clear();

                m_ucChannel_Status.Disp_Chamber_Val.Add(m_dispSP);
                m_ucChannel_Status.Disp_Chamber_Val.Add(m_dispPV);
                m_ucChannel_Status.Disp_Chamber_Val.Add(m_dispOUT);

                // -----------------------------------------
                // tVOC가 한개 이상일때
                // -----------------------------------------
                //+ Revisioin by LBG - 240520 : MTVD v2로 변경하여 해당 제어 Class 변경
                //if (m_ucTVocSOCList != null && m_NumOftVOC > 0)
                //{
                //    for (int iloop = 0; iloop < m_ucTVocSOCList.Count; iloop++)
                //    {
                //        Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                //        m_disptVoc.Cham_Name = "Dev #" + (iloop + 1).ToString() + " tVOC";
                //        m_disptVoc.Cham_Value = tVOC[iloop].ToString("F5") + " (ug/m3)";
                //        m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                //    }
                //}

                //+ Revision by LBG - 240530 : 신규 제작된 MTVD의 경우 사용자에게 노출되어선 안된다.
                if (m_NumOftVOC > 0)
                {
                    if (m_tVOCEnable)
                    {
                        if (m_iMTVD_Type == 0)
                        {
                            if (m_ucTVocSOCList != null)
                            {
                                for (int iloop = 0; iloop < m_ucTVocSOCList.Count; iloop++)
                                {
                                    Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                                    m_disptVoc.Cham_Name = "Dev #" + (iloop + 1).ToString() + " tVOC";
                                    m_disptVoc.Cham_Value = tVOC[iloop].ToString("F1") + " (ug/m3)";
                                    m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                                }
                            }
                        }
                        else
                        {
                            //if (m_cls_devMTVD_V2 != null)
                            //{
                            //    for (int i = 0; i < m_NumOftVOC; i++)
                            //    {
                            //        Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                            //        m_disptVoc.Cham_Name = "Dev #" + (i + 1).ToString() + " tVOC";
                            //        m_disptVoc.Cham_Value = tVOC[i].ToString("F1") + " (ug/m3)";
                            //        m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                            //    }
                            //}
                        }
                    }
                }
                //-
                //-
                */
                #endregion

                //+ Revision by LBG - 241104 : 챔버 데이터 디스플레이를 위하여 변경
                //rtChamChill[CST_Chamber_SP].value = value_sp;
                //rtChamChill[CST_Chamber_PV].value = value_pv;
                //rtChamChill[CST_Chamber_OUT].value = value_out;

                // Chamber SP Value
                ChamChillDisplay n_Chem_SP_Val = new ChamChillDisplay();
                n_Chem_SP_Val.Set_Value("Chamber SP[Setting]", value_sp);
                m_Chamber_Val.Add(n_Chem_SP_Val);

                // Chamber SP Value
                ChamChillDisplay n_Chem_PV_Val = new ChamChillDisplay();
                n_Chem_PV_Val.Set_Value("Chamber PV[Measured]", value_pv);
                m_Chamber_Val.Add(n_Chem_PV_Val);

                // Chamber SP Value
                ChamChillDisplay n_Chem_Out_Val = new ChamChillDisplay();
                n_Chem_Out_Val.Set_Value("Chamber Out Ratio", value_out);
                m_Chamber_Val.Add(n_Chem_Out_Val);
                //-

                mPV_Limit = value_pv;

                List<int> cham_chlist = m_ucChamber.ChList;

                for (int m = 0; m < cham_chlist.Count; m++)
                {
                    int ch = cham_chlist[m];
                    int boardid = Board_Ch_Mapping[ch];  // ghbaik
                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                    {
                        //+ Revision by YMJ - 240530 : 채널정보 UI에 온도 출력 설정값이 CHAMBER일 경우에만 온도 갱신
                        if (m_temp_Collect_dev.Equals("CHAMBER"))
                        {
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = value_pv;  // 추가함. 230911 BGH
                        }
                        //-
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_PV = value_pv;
                    }

                    if (value_pv > 100)
                    {
                        //+ Revision by YMJ - 241227 : 알람메시지에 코드 추가
                        AddAlarm(ch, TypeOfSafetyViolation.ChamberAlarm, "[CMB003]OTP:ChamberTemp[" + value_pv.ToString("F2") + " (℃)");
                    }
                }
            }
            catch { }

            DisplayChamberChiller();
        }
        //-

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        public void GotChamberTemp_SIMPAC(double value_pv, double value_sp, int n_dHumidity_S, int n_dHumidity_P)
        {
            try
            {
                //+ Revision by LBG - 241104 : 챔버 데이터 디스플레이를 위하여 변경
                //rtChamChill[CST_Chamber_SP].value = value_sp;
                //rtChamChill[CST_Chamber_PV].value = value_pv;
                ////+ Revision by LBG - 241031 : SIMPAC 챔버의 경우 습도 조절 기능이 있음, 해당 설정값 추가
                //rtChamChill[CST_Chamber_Humidity_S].value = n_dHumidity_S;
                //rtChamChill[CST_Chamber_Humidity_P].value = n_dHumidity_P;
                ////-
                ///
                ///// Chamber SP Value
                ChamChillDisplay n_Chem_SP_Val = new ChamChillDisplay();
                n_Chem_SP_Val.Set_Value("Chamber SP[Setting]", value_sp);
                m_Chamber_Val.Add(n_Chem_SP_Val);

                // Chamber PV Value
                ChamChillDisplay n_Chem_PV_Val = new ChamChillDisplay();
                n_Chem_PV_Val.Set_Value("Chamber PV[Measured]", value_pv);
                m_Chamber_Val.Add(n_Chem_PV_Val);

                // Chamber Humidity Set Value
                ChamChillDisplay n_Chem_Humidity_S_Val = new ChamChillDisplay();
                n_Chem_Humidity_S_Val.Set_Value("Chamber Humidity[Setting]", n_dHumidity_S);
                m_Chamber_Val.Add(n_Chem_Humidity_S_Val);

                // Chamber Humidity Meas Value
                ChamChillDisplay n_Chem_Humidity_P_Val = new ChamChillDisplay();
                n_Chem_Humidity_P_Val.Set_Value("Chamber Humidity[Measured]", n_dHumidity_P);
                m_Chamber_Val.Add(n_Chem_Humidity_P_Val);
                //-

                mPV_Limit = value_pv;
                m_H_PV = n_dHumidity_P;

                List<int> cham_chlist = m_ucChamber.ChList;

                for (int m = 0; m < cham_chlist.Count; m++)
                {
                    int ch = cham_chlist[m];
                    int boardid = Board_Ch_Mapping[ch];  // ghbaik
                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                    {
                        //+ Revision by YMJ - 240530 : 채널정보 UI에 온도 출력 설정값이 CHAMBER일 경우에만 온도 갱신
                        if (m_temp_Collect_dev.Equals("CHAMBER"))
                        {
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = value_pv;  // 추가함. 230911 BGH
                        }
                        //-
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_PV = value_pv;
                    }

                    if (value_pv > 100)
                    {
                        AddAlarm(ch, TypeOfSafetyViolation.ChamberAlarm, "OTP:ChamberTemp[" + value_pv.ToString("F2") + " (℃)");
                    }
                }
            }
            catch { }

            DisplayChamberChiller();
        }

        public void GotChamberTemp_TEMI2500(double n_dT_PV, double n_dT_SP, double n_dT_P_Out, double n_dH_PV, double n_dH_SP, double n_dH_P_Out)
        {
            try
            {
                ///// Chamber SP Value
                ChamChillDisplay n_Chem_SP_Val = new ChamChillDisplay();
                n_Chem_SP_Val.Set_Value("Chamber SP[Setting]", n_dT_SP);
                m_Chamber_Val.Add(n_Chem_SP_Val);

                // Chamber PV Value
                ChamChillDisplay n_Chem_PV_Val = new ChamChillDisplay();
                n_Chem_PV_Val.Set_Value("Chamber PV[Measured]", n_dT_PV);
                m_Chamber_Val.Add(n_Chem_PV_Val);

                // Chamber PV-Out Value
                ChamChillDisplay n_Chem_PV_Out_Val = new ChamChillDisplay();
                n_Chem_PV_Val.Set_Value("Chamber Out Ratio", n_dT_P_Out);
                m_Chamber_Val.Add(n_Chem_PV_Val);

                // Chamber Humidity Set Value
                ChamChillDisplay n_Chem_Humidity_S_Val = new ChamChillDisplay();
                n_Chem_Humidity_S_Val.Set_Value("Chamber Humidity[Setting]", n_dH_SP);
                m_Chamber_Val.Add(n_Chem_Humidity_S_Val);

                // Chamber Humidity Meas Value
                ChamChillDisplay n_Chem_Humidity_P_Val = new ChamChillDisplay();
                n_Chem_Humidity_P_Val.Set_Value("Chamber Humidity[Measured]", n_dH_PV);
                m_Chamber_Val.Add(n_Chem_Humidity_P_Val);

                // Chamber Humidity Meas Value
                ChamChillDisplay n_Chem_Humidity_P_Out_Val = new ChamChillDisplay();
                n_Chem_Humidity_P_Val.Set_Value("Chamber H Out Ratio", n_dH_P_Out);
                m_Chamber_Val.Add(n_Chem_Humidity_P_Val);
                //-

                mPV_Limit = n_dT_PV;
                m_H_PV = n_dH_PV;

                List<int> cham_chlist = m_ucChamber.ChList;

                for (int m = 0; m < cham_chlist.Count; m++)
                {
                    int ch = cham_chlist[m];
                    int boardid = Board_Ch_Mapping[ch];  // ghbaik
                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

                    if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null)
                    {
                        //+ Revision by YMJ - 240530 : 채널정보 UI에 온도 출력 설정값이 CHAMBER일 경우에만 온도 갱신
                        if (m_temp_Collect_dev.Equals("CHAMBER"))
                        {
                            m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = n_dT_PV;  // 추가함. 230911 BGH
                        }
                        //-
                        m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_PV = n_dT_PV;
                    }

                    if (n_dT_PV > 100)
                    {
                        AddAlarm(ch, TypeOfSafetyViolation.ChamberAlarm, "OTP:ChamberTemp[" + n_dT_PV.ToString("F2") + " (℃)");
                    }
                }
            }
            catch { }

            DisplayChamberChiller();
        }
        //-

        // --------------------------------------
        //
        // --------------------------------------
        public void DisptVOCValue(int ch)
        {
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

            try
            {
                Display_Chamber_Data m_dispSP = new Display_Chamber_Data();
                Display_Chamber_Data m_dispPV = new Display_Chamber_Data();
                // Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();

                m_dispSP.Cham_Name = "SP[Setting]";
                m_dispSP.Cham_Value = "";
                m_dispPV.Cham_Name = "PV[Measured]";
                m_dispPV.Cham_Value = "";

                //m_disptVoc.Cham_Name = "Dev #1" + " tVOC";
                //m_disptVoc.Cham_Value = tVOC[0].ToString("F5") + " (ug/m3)";

                //bool bfound = false;
                
                m_ucChannel_Status.Disp_Chamber_Val.Clear();

                m_ucChannel_Status.Disp_Chamber_Val.Add(m_dispSP);
                m_ucChannel_Status.Disp_Chamber_Val.Add(m_dispPV);
                //m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);

                // -----------------------------------------
                // tVOC가 한개 이상일때 (max 12개)
                // -----------------------------------------
                //if (m_ucTVocSOCList != null && m_NumOftVOC > 0)
                //{
                //    for (int iloop = 0; iloop < m_ucTVocSOCList.Count; iloop++)
                //    {
                //        Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                //        m_disptVoc.Cham_Name = "Dev #" + (iloop + 1).ToString() + " tVOC";
                //        m_disptVoc.Cham_Value = tVOC[iloop].ToString("F5") + " (ug/m3)";
                //        m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                //    }
                //}

                if (m_NumOftVOC > 0)
                {
                    if (m_ucTVocSOCList != null)
                    {
                        for (int iloop = 0; iloop < m_ucTVocSOCList.Count; iloop++)
                        {
                            Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                            m_disptVoc.Cham_Name = "Dev #" + (iloop + 1).ToString() + " tVOC";
                            m_disptVoc.Cham_Value = tVOC[iloop].ToString("F1") + " (ug/m3)";
                            m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                        }
                    }
                    else if (m_cls_devMTVD_V2 != null)
                    {
                        for (int i = 0; i < m_NumOftVOC; i++)
                        {
                            Display_Chamber_Data m_disptVoc = new Display_Chamber_Data();
                            m_disptVoc.Cham_Name = "Dev #" + (i + 1).ToString() + " tVOC";
                            m_disptVoc.Cham_Value = tVOC[i].ToString("F1") + " (ug/m3)";
                            m_ucChannel_Status.Disp_Chamber_Val.Add(m_disptVoc);
                        }
                    }
                }
                //-

            }
            catch { }

            DisplayChamberChiller();
        }

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        // --------------------------------------
        // Chiller
        // --------------------------------------
        public void GotChillerValue(int n_iCH, double value_pv, double value_sp, double value_flow_pv, double value_flow_sp, double out1, double out2)
        {
            //+ Revision by LBG - 241104 : 챔버 및 칠러 데이터 디스플레이를 위하여 변경
            List<ChamChillDisplay> n_Chiller_Vale = new List<ChamChillDisplay>();

            ChamChillDisplay n_Chiller_SP_Val = new ChamChillDisplay();
            n_Chiller_SP_Val.Set_Value(n_iCH, "Chiller SP[Setting]", value_sp);
            n_Chiller_Vale.Add(n_Chiller_SP_Val);

            ChamChillDisplay n_Chiller_PV_Val = new ChamChillDisplay();
            n_Chiller_PV_Val.Set_Value(n_iCH, "Chiller PV[Measured]", value_pv);
            n_Chiller_Vale.Add(n_Chiller_PV_Val);

            ChamChillDisplay n_Chiller_Out_Val = new ChamChillDisplay();
            n_Chiller_Out_Val.Set_Value(n_iCH, "Chiller Out Ratio", out1);
            n_Chiller_Vale.Add(n_Chiller_Out_Val);

            ChamChillDisplay n_Chiller_Flow_SP_Val = new ChamChillDisplay();
            n_Chiller_Flow_SP_Val.Set_Value(n_iCH, "Chiller Flow[Setting]", value_flow_sp);
            n_Chiller_Vale.Add(n_Chiller_Flow_SP_Val);

            ChamChillDisplay n_Chiller_Flow_PV_Val = new ChamChillDisplay();
            n_Chiller_Flow_PV_Val.Set_Value(n_iCH, "Chiller Flow[Measured]", value_flow_pv);
            n_Chiller_Vale.Add(n_Chiller_Flow_PV_Val);

            ChamChillDisplay n_Chiller_Flow_Out_Val = new ChamChillDisplay();
            n_Chiller_Flow_Out_Val.Set_Value(n_iCH, "Chiller Flow Out Ratio", out2);
            n_Chiller_Vale.Add(n_Chiller_Flow_Out_Val);

            if(m_Chiller_Val.ContainsKey(n_iCH))
            {
                m_Chiller_Val[n_iCH] = n_Chiller_Vale;
            }
            else
            {
                m_Chiller_Val.Add(n_iCH, n_Chiller_Vale);
            }
            //-

            DisplayChamberChiller();
        }
        //-

        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
        // -------------------------------------------------
        // 241028, BGH
        // -------------------------------------------------
        private delegate void Delegate_DisplayChamberChiller();
        public void DisplayChamberChiller()
        {
            if (this.InvokeRequired)
            {
                var d = new Delegate_DisplayChamberChiller(DisplayChamberChiller);
                this.Invoke(d, new object[] { });
                return;
            }

            if (m_ucChannel_Status.Disp_Chamber_Val != null && m_ucChannel_Status.Disp_Chamber_Val.Count > 0)
            {
                m_ucChannel_Status.Disp_Chamber_Val.Clear();
            }
            if (m_ucChannel_Status.Disp_Chiller_Val != null && m_ucChannel_Status.Disp_Chiller_Val.Count > 0)
            {
                m_ucChannel_Status.Disp_Chiller_Val.Clear();
            }
            if (m_ucChannel_Status.Disp_MTVD_Val != null && m_ucChannel_Status.Disp_MTVD_Val.Count > 0)
            {
                m_ucChannel_Status.Disp_MTVD_Val.Clear();
            }

            if (m_ucChamber.EnableFlag)
            {
                //+ Revision by LBG - 241104 : 챔버 데이터 디스플레이를 위하여 변경
                
                if(m_Chamber_Val != null && m_Chamber_Val.Count > 0)
                {
                    for(int i = 0; i < m_Chamber_Val.Count; i++)
                    {
                        Display_Chamber_Data n_dispChamber = new Display_Chamber_Data();
                        n_dispChamber.Cham_Name = m_Chamber_Val[i].Name;

                        switch (m_Chamber_Val[i].Name)
                        {
                            case "Chamber SP[Setting]":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString("F2") + " (℃)";
                                break;
                            case "Chamber PV[Measured]":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString("F2") + " (℃)";
                                break;
                            case "Chamber Out Ratio":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString("F1") + " (%)";
                                break;
                            case "Chamber Humidity[Setting]":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString() + " (%)";
                                break;
                            case "Chamber Humidity[Measured]":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString() + " (%)";
                                break;
                            case "Chamber H Out Ratio":
                                n_dispChamber.Cham_Value = m_Chamber_Val[i].value.ToString("F1") + " (%)";
                                break;
                        }

                        m_ucChannel_Status.Disp_Chamber_Val.Add(n_dispChamber);
                    }
                    m_Chamber_Val.Clear();
                    //-
                }
                //-
            }

            //+ Revision by LBG - 241104 : Chiller를 각 개별 컨트롤을 위해서 Class 다중화
            if (m_ucChiller.ContainsKey(m_iCur_CH_NO) && m_ucChiller[m_iCur_CH_NO].EnableFlag)
            {
                //+ Revision by LBG - 241104 : Chiller 데이터 디스플레이를 위하여 변경

                if (m_Chiller_Val != null && m_Chiller_Val.Count > 0)
                {
                    for (int i = 0; i < m_Chiller_Val.Count; i++)
                    {
                        List<ChamChillDisplay> n_Chiller_List = m_Chiller_Val[i];

                        for (int k = 0; k < n_Chiller_List.Count; k++)
                        {
                            Display_Chiller_Data n_dispChiller = new Display_Chiller_Data();
                            n_dispChiller.Chiller_Name = string.Format("CH_{0:00}_{1}", n_Chiller_List[k].CH_NO + 1, n_Chiller_List[k].Name);

                            switch (n_Chiller_List[k].Name)
                            {
                                case "Chiller SP[Setting]":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F2") + " (℃)";
                                    break;
                                case "Chiller PV[Measured]":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F2") + " (℃)";
                                    break;
                                case "Chiller Out Ratio":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F1") + " (%)";
                                    break;
                                case "Chiller Flow[Setting]":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F2") + " (LPM)";
                                    break;
                                case "Chiller Flow[Measured]":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F2") + " (LPM)";
                                    break;
                                case "Chiller Flow Out Ratio":
                                    n_dispChiller.Chiller_Value = n_Chiller_List[k].value.ToString("F1") + " (%)";
                                    break;
                            }

                            m_ucChannel_Status.Disp_Chiller_Val.Add(n_dispChiller);
                        }
                    }
                    //m_Chiller_Val.Clear();
                }
                //-
            }
            //-

            //+ Revision by LBG - 240530 : 신규 제작된 MTVD의 경우 사용자에게 노출되어선 안된다. m_tVOCEnable
            //+ Revision by LBG - 241104 : MTVD 데이터 디스플레이를 위하여 변경 (사용 변수 잘못되어 있음
            //if (m_MCZEnable)
            if (m_tVOCEnable)
            //-
            {
                if (m_NumOftVOC > 0)
                {
                    //+ Revision by LBG - 241104 : 챔버 데이터 디스플레이를 위하여 변경
                    for (int i = 0; i < m_MTVD_Val.Count; i++)
                    {
                        Display_MTVD_Data m_disptVoc = new Display_MTVD_Data();
                        m_disptVoc.MTVD_Name = m_MTVD_Val[i].Name;
                        m_disptVoc.MTVD_Value = m_MTVD_Val[i].value.ToString("F1") + " (ug/m3)";

                        m_ucChannel_Status.Disp_MTVD_Val.Add(m_disptVoc);
                    }

                    m_MTVD_Val.Clear();
                    //-
                }
            }
        }

        public void ChillerCoolerON(int ch)
        {
            AddTickStepAndTotalTime(ch, 2);
            WriteBasicLog(ch, "Cooler ON", eNUM_CutOFF_Type.NONE, false);
        }

        public void ChillerCoolerOff(int ch)
        {
            AddTickStepAndTotalTime(ch, 2);
            WriteBasicLog(ch, "Cooler OFF", eNUM_CutOFF_Type.NONE, false);
        }
        //-

        public double[] tVOC = new double[12] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        // --------------------------------------
        // tVOC-Socket
        // --------------------------------------
        public void GottVOC_Socket(int devch, double tVoc_value)
        {
            if (devch < 1 || devch > 12) devch = 1;
            tVOC[devch-1] = tVoc_value;
            //Debug.WriteLine("MTVD : " + devch.ToString() + " // " + tVoc_value.ToString());
        }

        public void Set_MTVDv2_Val(int n_iCH_No, long n_lTVOC_Val)
        {
            tVOC[n_iCH_No] = n_lTVOC_Val;
            //Debug.WriteLine("MTVD : " + devch.ToString() + " // " + tVoc_value.ToString());
        }

        // --------------------------------------
        // BMS Control Signal
        // --------------------------------------
        public void GotBMSControlValues(int ch, double value, byte type)
        {
            int CurrentNo; // = mtControlData[ch].CurrentNo;
            cls_stepInfo CurStInfo = new cls_stepInfo(this);

            // ---
            // 시험중이 아니라면 제어신호는 필요 없음
            // ---
            if (!IsOnTesting[ch]) return;

            //try
            //{
            //    if (m_ucStepInfo_List == null) { return; }
            //    if (m_ucStepInfo_List.Count <= ch) { return; }
            //}
            //catch { }

            CurStInfo = m_ucStepInfo_List[ch];
            //try
            //{
            //    if (CurStInfo == null) { return; }
            //    if (CurStInfo.m_currentStepNo < 0) { return; }
            //}
            //catch { }

            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2
            CurrentNo = CurStInfo.m_currentStepNo;

            double refvalue = 0;
            if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.Charge)
            {
                refvalue = value;
                if (refvalue < 0)
                {
                    refvalue *= (-1.0);
                }

                if (type == 1)
                {
                    m_ucCycler_ABT_List[boardid].Write_CC_Event(bzch, refvalue, false);
                }
                else
                if (type == 2)
                {
                    m_ucCycler_ABT_List[boardid].Write_CP_Event(bzch, refvalue, false);
                }
            }
            else if (CurStInfo.m_steplist[CurrentNo].steptype == cls_stepInfo.enumStepType.Discharge)
            {

                refvalue = value;
                if (refvalue > 0)
                {
                    refvalue *= (-1.0);
                }

                if (type == 1)
                {
                    WriteSystemLog(ch, ">> BMS control by CC signal : Current=" + refvalue.ToString("F3"), true);
                    m_ucCycler_ABT_List[boardid].Write_CC_Event(bzch, refvalue, false);
                }
                else if (type == 2)
                {
                    WriteSystemLog(ch, ">> BMS control by CP signal : Power=" + refvalue.ToString("F3"), true);
                    m_ucCycler_ABT_List[boardid].Write_CP_Event(bzch, refvalue, false);
                }
            }

            AddTickStepAndTotalTime(ch, 2);
            WriteBasicLog(ch, "BMS Control", eNUM_CutOFF_Type.NONE, false);
            //WriteBasicLog(ch, "");
            //if (type == 2) WriteBasicLog(ch, "BMS Ctrl - CP");
            //else WriteBasicLog(ch, "BMS Ctrl - CC");

            //+ Revision by LBG - 231201 : 채널 상세 정보 업데이트 일시 막음
            //ReNewChDispInformation(ch);
            //-
            Display_Channel_Status m_dispChStatus = new Display_Channel_Status();
            m_dispChStatus = SetChannelStatus(ch);
            m_ucChannel_Status.Set_Disp_CH_Status(ch, m_dispChStatus);
            //m_ucChannel_Status.Display_Data_ChOnly(ch);
        }

        // ----------
        // d_type : 0 - DAU
        //          1 - AUX
        //          2 - BMS
        //          3 - MBI
        // ----------
        public void CalcAUXMinMax(int idx, byte d_type)
        {
            if (!m_clsAppSet.Enable_Set.Enable_AUX) return;

            if (d_type == 0 && m_DAU_Volt == null) return;
            if (d_type == 1 && m_AUX_Volt == null) return;
            if (d_type == 2 && m_BMS_Volt == null) return;
            if (d_type == 3 && m_MBI_Volt == null) return;

            //double vsum = 0;
            //int mcnt = 0;

            //+ Revision by YMJ - 231124 : DAU Min, Max, Diff 구하는 구문 주석처리
            /*if (d_type == 0)
            {
                if (m_DAU_Volt != null)
                {
                    if (DAU_V_diff.Length >= idx)
                    {
                        DAU_V_diff[idx] = 0;
                        DAU_V_min[idx] = 999.99;
                        DAU_V_max[idx] = 0;

                        // for (int i = 0; i < m_DAU_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_dau[idx]; i++)
                        {
                            if (m_DAU_Volt[idx, i] > 0.1)
                            {
                                //DAU_V_avg[idx] += m_DAU_Volt[idx, i];
                                //mcnt++;

                                if (m_DAU_Volt[idx, i] > DAU_V_max[idx]) DAU_V_max[idx] = m_DAU_Volt[idx, i];
                                if (m_DAU_Volt[idx, i] < DAU_V_min[idx]) DAU_V_min[idx] = m_DAU_Volt[idx, i];
                            }
                        }

                        if (DAU_V_min[idx] > 5)
                        {
                            DAU_V_min[idx] = 0;
                        }

                        DAU_V_diff[idx] = DAU_V_max[idx] - DAU_V_min[idx];
                    }
                }
            }
            else */
            //-
            if (d_type == 2)
            {
                if (m_BMS_Volt != null)
                {
                    if (BMS_V_diff.Length >= idx)
                    {
                        BMS_V_diff[idx] = 0;
                        BMS_V_min[idx] = 999.99;
                        BMS_V_max[idx] = 0;

                        // for (int i = 0; i < m_BMS_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_bms[idx]; i++)
                        {
                            if (m_BMS_Volt[idx, i] > 0.1)
                            {
                                //BMS_V_avg[idx] += m_BMS_Volt[idx, i];
                                //mcnt++;

                                if (m_BMS_Volt[idx, i] > BMS_V_max[idx]) BMS_V_max[idx] = m_BMS_Volt[idx, i];
                                if (m_BMS_Volt[idx, i] < BMS_V_min[idx]) BMS_V_min[idx] = m_BMS_Volt[idx, i];
                            }
                        }

                        //if (mcnt == 0) mcnt = 1;
                        //BMS_V_avg[idx] = BMS_V_avg[idx] / mcnt;

                        if (BMS_V_min[idx] > 5)
                        {
                            BMS_V_min[idx] = 0;
                        }

                        BMS_V_diff[idx] = BMS_V_max[idx] - BMS_V_min[idx];
                    }
                }
            }
            else if (d_type == 1)
            {
                if (m_AUX_Volt != null)
                {
                    if (AUX_V_diff.Length >= idx)
                    {
                        AUX_V_diff[idx] = 0;
                        AUX_V_min[idx] = 999.99;
                        AUX_V_max[idx] = 0;

                        // for (int i = 0; i < m_AUX_Volt.GetLength(1); i++)
                        for (int i = 0; i < m_voltcount_aux[idx]; i++)
                        {
                            if (m_AUX_Volt[idx, i] > 0.1)
                            {
                                if (m_AUX_Volt[idx, i] > AUX_V_max[idx]) AUX_V_max[idx] = m_AUX_Volt[idx, i];
                                if (m_AUX_Volt[idx, i] < AUX_V_min[idx]) AUX_V_min[idx] = m_AUX_Volt[idx, i];

                                //AUX_V_diff[idx] += m_AUX_Volt[idx, i];
                                //mcnt++;
                            }
                        }
                    }
                }

                //if (mcnt == 0) mcnt = 1;
                //AUX_V_avg[idx] = AUX_V_avg[idx] / mcnt;
                
                if (AUX_V_min[idx] > 5)
                {
                    AUX_V_min[idx] = 0;
                }

                AUX_V_diff[idx] = AUX_V_max[idx] - AUX_V_min[idx];
            }
            else if (d_type == 3)
            {
                if (m_MBI_Volt != null)
                {
                    if (MBI_V_diff.Length >= idx)
                    {
                        MBI_V_diff[idx] = 0;
                        MBI_V_min[idx] = 999.99;
                        MBI_V_max[idx] = 0;

                        for (int i = 0; i < m_voltcount_mbi[idx]; i++)
                        {
                            if (m_MBI_Volt[idx, i] > 0.1)
                            {
                                if (m_MBI_Volt[idx, i] > MBI_V_max[idx]) MBI_V_max[idx] = m_MBI_Volt[idx, i];
                                if (m_MBI_Volt[idx, i] < MBI_V_min[idx]) MBI_V_min[idx] = m_MBI_Volt[idx, i];
                            }
                        }

                        if (MBI_V_min[idx] > 5)
                        {
                            MBI_V_min[idx] = 0;
                        }

                        MBI_V_diff[idx] = MBI_V_max[idx] - MBI_V_min[idx];
                    }
                }
            }

        }
        // --------------------------------------------------------------
        // 밸런싱은 전체 셀 대상으로 작업을 하나, 특정 채널 스케쥴에서
        // 일정을 만들어 작업하게 된다. 채널은 모듈이나 팩.
        // --------------------------------------------------------------
        public void DoBalacing(int ch)
        {
            if (m_ucBalancer_List == null) return;            
            if (!IsOnTesting[ch]) return;
            if (m_ucBalancer_List.Count <= ch) return;
            
            if (m_ucBalancer_List[ch].isBalancing == false) return;
            if (!m_ucBalancer_List[ch].ControlEnabled) return;

            // -------------------------------------------
            // AUX && Balancing
            // -------------------------------------------
                cls_stepInfo CurStInfo = new cls_stepInfo(this);
            if (m_ucStepInfo_List == null)
            {
                EndTest2ndStep(ch);
                return;
            }
            if (m_ucStepInfo_List.Count <= ch)
            {
                EndTest2ndStep(ch);
                return;
            }

            // --------------------------------------------------
            // Balancing 도중 알람 발생등의 경우엔 Balancing 중지
            // --------------------------------------------------
            int boardid = Board_Ch_Mapping[ch];
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);
            if (m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isPaused)
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                if (m_ucBalancer_List.Count > ch)
                {
                    m_ucBalancer_List[ch].isBalancing = false;
                    m_ucBalancer_List[ch].ResetBalancingList();
                    m_ucBalancer_List[ch].SendBalancingOffCmd();
                }                                    
                return;
            }

            CurStInfo = m_ucStepInfo_List[ch];
            int CurrentNo = CurStInfo.m_currentStepNo;

            List<AUX_Volt_Recipe> vrcp = CurStInfo.m_steplist[CurrentNo].lstAUXVolt;

            // ----------------------------------------------
            // Balancing
            // ----------------------------------------------
            m_ucBalancer_List[ch].BalancingResis = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_R_Type;
            bool ifAnyCell = false;
            for (int i = 0; i < m_ucBalancer_List[ch].BalancingList.Length; i++)
            {
                double dend = CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Dev_End * 0.001;

                // ------------------------------------------------------
                // 밸런싱 대상 전압 중 최소값을 계산해 사용. 23.08.14
                // ------------------------------------------------------
                double vbmin = 999.99;
                for (int i2 = 0; i2 < vrcp.Count(); i2++)
                {
                    if (vrcp[i2].AUX_V_Recipe_Balance)
                    {
                        if (m_AUX_Volt[ch, i2] < vbmin) vbmin = m_AUX_Volt[ch, i2];
                    }
                }
                if (vbmin > 10) vbmin = 0;

                if (vbmin > 0)
                {
                    if (m_ucBalancer_List[ch].BalancingList[i] == 1 && vbmin > 0.1)
                    {
                        // 종료전압 편차까지 밸런싱 실시
                        if (m_AUX_Volt[ch, i] > CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Lower &&
                            m_AUX_Volt[ch, i] < CurStInfo.m_steplist[CurrentNo].AUX_Balancing_Volt_Upper &&
                            (m_AUX_Volt[ch, i] - vbmin) > dend)
                        {
                            // ---------------------------------------
                            // 현재는 i 의 범위는 1부터 8까지이다.
                            // ---------------------------------------
                            m_ucBalancer_List[ch].SetBalancingMode(i + 1, true);
                            ifAnyCell = true;
                        }
                        else
                        {
                            m_ucBalancer_List[ch].SetBalancingMode(i + 1, false);
                        }
                    }
                }
            }

            if (ifAnyCell)
            {
                m_ucBalancer_List[ch].SendWriteCmdArray();
            }
            else
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].isBalancing = false;
                m_ucBalancer_List[ch].isBalancing = false;
                m_ucBalancer_List[ch].ResetBalancingList();
                m_ucBalancer_List[ch].SendBalancingOffCmd();

                // 현재스텝 종료신호
                EndCurrentStep(ch, eNUM_CutOFF_Type.Balancing);
            }
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        public void SendPatternCommand2ABT(int ch, int ntype, double refvalue, bool firstpacket)
        {
            try
            {
                int boardid = Board_Ch_Mapping[ch];  // ghbaik
                int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2

                doPatternLog[ch] = 0;
                if (firstpacket)
                {
                    cls_devCyclerABT.struCyclerStatus chlist = m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch];
                    chlist.isFirstPattern = true;
                    chlist.m_STepStatus = cls_devCyclerABT.STEP_STATUS.MATCH_UP;
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch] = chlist;

                    doPatternLog[ch] = 1;
                }

                if (ntype == 1)  // CP
                {
                    //m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].ResetInPattern();

                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode = cls_stepInfo.enumStepMode.CP;
                    m_ucCycler_ABT_List[boardid].Write_CP_PacketABT(bzch, refvalue, 0, true);
                }
                else if (ntype == 2) // CR
                {
                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode = cls_stepInfo.enumStepMode.CR;
                    m_ucCycler_ABT_List[boardid].Write_CR_PacketABT(bzch, refvalue, 0, true);
                }
                else if (ntype == 0)  // CC
                {
                    //m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].ResetInPattern();

                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.stepmode = cls_stepInfo.enumStepMode.CC;
                    m_ucCycler_ABT_List[boardid].Write_CC_PacketABT(bzch, refvalue, 0, true);
                }
                else
                {
                    m_ucCycler_ABT_List[boardid].ClearStatusFlag(bzch);
                }
            }
            catch { }
        }

        // ---------------------------------------------------
        //
        // ---------------------------------------------------
        private delegate void Delegate_Set_grpChName(int ch);
        public void Set_Group_Ch_No(int ch)
        {
            if (this.InvokeRequired)
            {
                var d = new Delegate_Set_grpChName(Set_Group_Ch_No);
                this.Invoke(d, new object[] { ch });
                return;
            }

            //grp_Ch_Info.Text = "채널 상세 정보 [CH-" + (ch+1).ToString("00") + "]";
            //grp_chcontrol.Text = "채널 제어 [CH-" + (ch + 1).ToString("00") + "]"; 

        }

        /// <summary>
        /// 프로그램 Log 작성 시 Log 파일 Access 중복 접근 방지를 위한 Lock Value
        /// </summary>
        object m_obLock_Log = new object();

        /// <summary>
        /// Exception 발생 시 해당 내용 Log로 저장하기 위한 Function
        /// </summary>
        /// <param name="n_sSender">Exception 발생 Function</param>
        /// <param name="n_sMsg">Exception 내용</param>
        public void Write_Log(string n_sSender, string n_sMsg)
        {
            DateTime n_NowDate = DateTime.Now;

            string n_sFolder_Path = Application.StartupPath + "\\log\\System\\" + string.Format("{0:0000}\\{1:00}\\{2:00}\\", n_NowDate.Year, n_NowDate.Month, n_NowDate.Day);
            string n_sFile_Name = n_sFolder_Path + string.Format("[{0:00}]ABT_Debug_Msg.log", n_NowDate.Hour);

            if (!Directory.Exists(n_sFolder_Path))
            {
                Directory.CreateDirectory(n_sFolder_Path);
            }

            lock (m_obLock_Log)
            {
                // StreamWriter n_SreamWriter = new StreamWriter(n_sFile_Name, true, Encoding.Default);
                StreamWriter n_SreamWriter = new StreamWriter(n_sFile_Name, true, System.Text.Encoding.Default);  // ghbaik
                n_SreamWriter.WriteLine(string.Format("[{0:yyyy-MM-dd HH:mm:ss.fff}],{1},{2}", n_NowDate, n_sSender, n_sMsg));
                n_SreamWriter.Close();
            }
        }

        // --------------------------------
        //
        // --------------------------------
        private void bt_Vent_Click(object sender, EventArgs e)
        {
            // ------------------------------
            // Vent Activation
            // ------------------------------
            WriteSystemLog("// Vent Chamber - Activation!!!!!!");

            if (!m_ucChamberDIO.EnableFlag)
            {
                WriteSystemLog("// Vent Chamber -> NO DIO");
                return;
            }
            if (!m_ucChamberDIO.isConnected)
            {
                WriteSystemLog("// Vent Chamber -> Serial:Comport Error!!");
                return;
            }


            // ------------------------------------------------------------------
            string drmsg1 = "";
            string drmsg2 = "";
            bool ventstatus = m_ucChamberDIO.VentStatus;
            if (SystemLanguage == LanguageType.KOREAN)
            {
                drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                if (ventstatus) drmsg2 = "Vent 열기";
                else drmsg2 = "Vent 닫기";
            }
            else if (SystemLanguage == LanguageType.ENGLISH)
            {
                drmsg1 = "Do you want to proceed selected job?";
                if (ventstatus) drmsg2 = "Open Vent";
                else drmsg2 = "Close Vent";
            }
            DialogResult dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
            if (dr == DialogResult.Yes)
            {
                if (ventstatus) WriteSystemLog("// Vent Chamber -> Send 'OPEN'");
                else WriteSystemLog("// Vent Chamber -> Send 'CLOSE'");

                if (ventstatus) bt_BuzzerStop.BackgroundImage = Properties.Resources.Vent1;
                else bt_BuzzerStop.BackgroundImage = Properties.Resources.Vent_Close;

                m_ucChamberDIO.SerialCmdWriteToVent();                
            }
        }

        /// <summary>
        /// Main Menu의 항목에 대하여 표시 여부 설정
        /// </summary>
        private void MainMenu_Visiable_Set()
        {
            if (!m_clsAppSet.Enable_Set.Enable_Engneer)
            {
                if (!m_clsAppSet.Enable_Set.Enable_CAN)
                {
                    mn_Setting.Visible = false;
                }
                else
                {
                    mn_Setting_System.Visible = false;
                    mn_Setting_Mapping.Visible = false;
                }
            }
            else
            {
                mn_Setting_System.Visible = true;
                mn_Setting_Mapping.Visible = true;
            }

            if (!m_clsAppSet.Enable_Set.Enable_AUX)
            {
                mn_Setting_AUX.Visible = false;
            }
            else
            {
                mn_Setting_AUX.Visible = true;
            }
        }

        /// <summary>
        /// 채널 상태에서 Popup 메뉴 버튼 결과 이벤트
        /// </summary>
        /// <param name="CH_NO">선택한 채널 번호</param>
        /// <param name="PopRet">버튼 동작 결과</param>
        private void CH_Status_Popup_Event(int CH_NO, CH_Status_Popup_Ret PopRet)
        {
            int selch = 0;
            bool rEnough = false;
            string drmsg1 = "";
            string drmsg2 = "";
            DialogResult dr;

            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
            int littlech = 0;
            int boardid = 0;
            int boardback = 0;
            int bzch = 0;
            string mstr = "";
            //-

            bool n_bIs_BD_Connected = false;

            if (m_SelCh4Schedule == null) return;
            if (m_SelCh4Schedule.Length < 1) return;

            switch (PopRet)
            {
                case CH_Status_Popup_Ret.WorkStart:
                    //+ Add by LBG - 230822 : Cycler와 통신 연결이 되지 않았을 경우 해당 기능 막기
                    if (m_ucBoard_Status != null)
                    {
                        n_bIs_BD_Connected = m_ucBoard_Status.GetBoardConnectivity(0);
                    }
                    //-

                    if (n_bIs_BD_Connected)
                    {
                        //+ Revision by YMJ - 250131 : 스타트 로직 일원화 및 타입 추가
                        Start_Schedule(2);
                        //-
                    }
                    break;

                case CH_Status_Popup_Ret.AlarmClear:
                    //+ Add by LBG - 230822 : Cycler와 통신 연결이 되지 않았을 경우 해당 기능 막기
                    
                    if (m_ucBoard_Status != null)
                    {
                        n_bIs_BD_Connected = m_ucBoard_Status.GetBoardConnectivity(0);
                    }
                    //-

                    if (n_bIs_BD_Connected)
                    {
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            selch = m_SelCh4Schedule[i];
                            boardid = Board_Ch_Mapping[selch];  // ghbaik
                            bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);  // ghbaik2

                            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                            if (CheckParallelSlave(selch))
                            {
                                WriteSystemLog(selch, ">> AlarmClear Cancelled [Parallel slave channel]", true);
                            }
                            //-
                            else
                            {
                                // 231025
                                RemoveAlarm(selch);

                                // --------------------------------------------
                                // 231126 Standby를 날릴 필요 없음, BGH
                                // --------------------------------------------
                                // m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.STANDBY, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                                m_ucCycler_ABT_List[boardid].MakeABTClearAlarmPacket(bzch + 1);
                                m_ucCycler_ABT_List[boardid].MakeABTClearNOCurrent(bzch);  // 231029

                                // + 230912
                                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(selch);
                                m_dispChStatus.ch_s_Exist_Alarm = false;
                                m_ucChannel_Status.Set_Disp_CH_Status(selch, m_dispChStatus);
                            }
                        }
                    }
                    break;

                case CH_Status_Popup_Ret.WorkPause:
                    WriteSystemLog(">> Pause Work [Popup]");

                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 한개 채널만 선택했는데 Slave 채널이면 return
                    if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_SelCh4Schedule[0]))
                    {
                        WriteSystemLog(m_SelCh4Schedule[0], ">> Pause work is Cancelled [Parallel slave channel]", true);
                        return;
                    }
                    //-

                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 최소 1개이상의 공정돌리고 있는 채널이 있어야 실행!
                    // -----------------------------------------------------------------------
                    rEnough = false;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        if (IsOnTesting[selch])
                        {
                            rEnough = true;
                            break;
                        }
                    }
                    if (!rEnough)
                    {
                        WriteSystemLog(">> No running ch");
                        return;
                    }

                    // ------------------------------------------------------------------                    
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "일시 정지";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Pause";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            selch = m_SelCh4Schedule[i];
                            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                            if (CheckParallelSlave(selch))
                            {
                                WriteSystemLog(selch, ">> Pause Work is Cancelled [Parallel slave channel]", true);
                            }
                            //-
                            else
                            {
                                if (IsOnTesting[selch])
                                {
                                    WriteSystemLog(selch, ">> pause", true);
                                    SuspendCurrentStep(selch, "");
                                }
                            }
                        }
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;

                case CH_Status_Popup_Ret.ContinueStart:
                    WriteSystemLog(">> Resume Work [Popup]");

                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 한개 채널만 선택했는데 Slave 채널이면 return
                    if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_SelCh4Schedule[0]))
                    {
                        WriteSystemLog(m_SelCh4Schedule[0], ">> Resume work is Cancelled [Parallel slave channel]", true);
                        return;
                    }
                    //-

                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 최소 1개이상의 공정돌리고 있는 채널이 있어야 실행!
                    // -----------------------------------------------------------------------
                    rEnough = false;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        if (IsOnTesting[selch])
                        {
                            rEnough = true;
                            break;
                        }
                    }
                    if (!rEnough)
                    {
                        WriteSystemLog(">> No running ch");
                        return;
                    }

                    // ------------------------------------------------------------------
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "작업 재 진행";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Continue Start";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                            if (CheckParallelSlave(selch))
                            {
                                WriteSystemLog(selch, ">> Resume Work is Cancelled [Parallel slave channel]", true);
                            }
                            //-
                            else
                            {
	                            if (IsOnTesting[selch])
	                            {
	                                RemoveAlarm(m_SelCh4Schedule[i]);
	                                ResumeCurrentStep(selch);
	
	                                WriteSystemLog(selch, ">> resume", true);
	                            }
							}
                        }
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;

                case CH_Status_Popup_Ret.WorkStop_Now:
                    WriteSystemLog(">> End Work [Popup]");

                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 한개 채널만 선택했는데 Slave 채널이면 return
                    if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_SelCh4Schedule[0]))
                    {
                        WriteSystemLog(m_SelCh4Schedule[0], ">> MEnd work is Cancelled [Parallel slave channel]", true);
                        return;
                    }
                    //-

                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 최소 1개이상의 공정돌리고 있는 채널이 있어야 실행!
                    // -----------------------------------------------------------------------
                    rEnough = false;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        if (IsOnTesting[selch])
                        {
                            rEnough = true;
                            break;
                        }
                    }
                    if (!rEnough)
                    {
                        WriteSystemLog(">> No running ch");
                        return;
                    }

                    // ------------------------------------------------------------------
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "작업 종료";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Stop Work";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                            if (CheckParallelSlave(m_SelCh4Schedule[i]))
                            {
                                WriteSystemLog(m_SelCh4Schedule[i], ">> Stop Work is Cancelled [Parallel slave channel]", true);
                            }
                            //-
                            else
                            {
                                RemoveAlarm(m_SelCh4Schedule[i]);
                                EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER, true);  // 종료전에 마지막 레코드 삽입, 231115 BGH, 231116
                                EndTest2ndStep(m_SelCh4Schedule[i]);

                                WriteSystemLog(m_SelCh4Schedule[i], ">> End work", true);
                            }
                        }

                        //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                        if (m_ucChamber.isConnected)
                        {
                            //if (m_ucChamber.DoesWorking)
                            {
                                m_ucChamber.RemoveCh(CH_NO);
                                if (m_ucChamber.GetCount() == 0)
                                {
                                    m_ucChamber.StopAction();
                                    Thread.Sleep(100);
                                    // m_ucChamber.StopSerial();
                                    m_ucChamber.DoesWorking = false;
                                    m_ucChamber.SP = 0; // -100; // -100.0f;
                                    m_ucChamber.HUMIDITY_S = 0;
                                    // -------------------------
                                    // 230917, BGH
                                    ResetChamberMaintainSetting();
                                }
                            }
                        }
                        //-
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;

                case CH_Status_Popup_Ret.NextStep:
                    WriteSystemLog(">> Next Step [Popup]");

                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 한개 채널만 선택했는데 Slave 채널이면 return
                    if (m_SelCh4Schedule.Length == 1 && CheckParallelSlave(m_SelCh4Schedule[0]))
                    {
                        WriteSystemLog(m_SelCh4Schedule[0], ">> Move next step is Cancelled [Parallel slave channel]", true);
                        return;
                    }
                    //-

                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 최소 1개이상의 공정돌리고 있는 채널이 있어야 실행!
                    // -----------------------------------------------------------------------
                    rEnough = false;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        if (IsOnTesting[selch])
                        {
                            rEnough = true;
                            break;
                        }
                    }
                    if (!rEnough)
                    {
                        WriteSystemLog(">> No running ch");
                        return;
                    }

                    // ------------------------------------------------------------------
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "다음 Step";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Next Step";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                            if (CheckParallelSlave(selch))
                            {
                                WriteSystemLog(selch, ">> Next step is Cancelled [Parallel slave channel]", true);
                            }
                            //-
                            else
                            {
                                RemoveAlarm(m_SelCh4Schedule[i]);
                                EndCurrentStep(m_SelCh4Schedule[i], eNUM_CutOFF_Type.USER); // None에서 User로 변경, 231115 BGh
                                WriteSystemLog(m_SelCh4Schedule[i], ">> Next Step", true);
                            }
                        }
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;

                case CH_Status_Popup_Ret.ScheduleView:
                    WriteSystemLog("// View schedule [Popup]");
					if (!IsOnTesting[m_iCur_CH_NO])
					{
						WriteSystemLog("// View schedule [Popup] - NOT On Test");
						break;
					}

                    //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드)
                    if (CheckParallelSlave(m_iCur_CH_NO))
                    {
                        WriteSystemLog(m_iCur_CH_NO, ">> Schedule View Cancelled [Parallel slave channel]", true);
                        break;
                    }
                    //-

                    if (!m_bCurSchedule_View)
                    {
                        WriteSystemLog(m_iCur_CH_NO, ">> View schedule - " + Recipe_Files[m_iCur_CH_NO], false);

						int m_cstep = m_ucStepInfo_List[m_iCur_CH_NO].m_currentStepNo;
						if (m_cstep < 1 || m_cstep >= Recipe_Files[m_iCur_CH_NO].Length) m_cstep = 0;

						m_bCurSchedule_View = true;
                        m_frmRecipeView = new frmRecipe_View(this, m_iCur_CH_NO, Recipe_Files[m_iCur_CH_NO], m_cstep); // m_CurChStatusInfo.Schedule_Path);
                        m_frmRecipeView.StartPosition = FormStartPosition.CenterParent;

						// ---------------------------
						// Event 지정
						// ---------------------------
						OnChangedStepNumber += m_frmRecipeView.Set_Highlight_Step;

						m_frmRecipeView.Show();
						//m_frmRecipeView.ShowDialog();
                    }
                    else
                    {
                        m_frmRecipeView.Activate();
                    }
                    break;

                case CH_Status_Popup_Ret.GraphView:
                    WriteSystemLog("// View RT-Graph [Popup]");
                    if (!m_bGraph_RT_Cycler)
                    {
                        m_bGraph_RT_Cycler = true;
                        WriteSystemLog(m_iCur_CH_NO, ">> View schedule - " + Recipe_Files[m_iCur_CH_NO], false);

                        m_Graph_RT_Cycler = new frmGraph_RT_Cycler(this, m_iCur_CH_NO);
                        m_Graph_RT_Cycler.StartPosition = FormStartPosition.CenterParent;

                        m_Graph_RT_Cycler.Show();
                    }
                    break;

                //+ Add By YMJ - 240416 : 챔버 정지 팝업 메뉴 사용 시 챔버 정지 동작
                case CH_Status_Popup_Ret.ChamberStop:
                    StopChamberAction(CH_NO);
                    break;
                //-

                //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬 설정 및 병렬 해제 팝업
                case CH_Status_Popup_Ret.SetParallelMode:
                    mstr = " >> Set Parallel Mode[Popup] ";

                    #region Running Check
                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 공정중인 채널 없어야 함
                    // -----------------------------------------------------------------------
                    int mrun = -1;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        mstr += ("//Ch" + (selch + 1).ToString());
                        if (IsOnTesting[selch]) { mrun = selch; }
                    }

                    WriteSystemLog(mstr);
                    if (mrun >= 0)
                    {
                        WriteSystemLog(">> Parallel Setting Error : Ch" + (mrun + 1).ToString() + " is running");

                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            drmsg1 = "검사중인 채널이 있습니다. 확인 후 다시 시도해 주십시오.";
                            drmsg2 = "병렬모드 설정";
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            drmsg1 = "Can't set to running channel.";
                            drmsg2 = "Set Parallel Mode";
                        }

                        MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                        return;
                    }
                    #endregion


                    #region 선택채널 갯수 검사
                    if (m_SelCh4Schedule.Length != m_bParallel_Ch_Num)
                    {
                        WriteSystemLog(">> Parallel Setting Error : Parallel ch not matched. [" + m_bParallel_Ch_Num.ToString() + " Channels should be combined]");

                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            drmsg1 = "항상 " + m_bParallel_Ch_Num.ToString() + "개의 채널을 선택하셔야 합니다.";
                            drmsg2 = "병렬모드 설정";
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            drmsg1 = "At least 2 channels are required to set.";
                            drmsg2 = "Set Parallel Mode";
                        }

                        MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                        return;
                    }
                    #endregion

                    #region 동일 통신보드 검사                     
                    if (Board_Ch_Mapping != null && Board_Ch_Mapping.Length > 0)
                    {
                        littlech = 1000;
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            selch = m_SelCh4Schedule[i];
                            if (selch < littlech) littlech = selch;
                        }
                        if (littlech > 255) littlech = 0;

                        bool isdiff = false;
                        boardback = Board_Ch_Mapping[littlech];
                        for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                        {
                            selch = m_SelCh4Schedule[i];
                            boardid = Board_Ch_Mapping[selch];

                            if (boardid != boardback)
                            {
                                isdiff = true;
                                break;
                            }
                        }

                        if (isdiff)
                        {
                            WriteSystemLog(">> Parallel Setting Error : Different Module");

                            if (SystemLanguage == LanguageType.KOREAN)
                            {
                                drmsg1 = "병렬모드 설정은 동일 모듈내의 채널들끼리만 가능합니다. 확인 후 다시 시도해 주십시오.";
                                drmsg2 = "병렬모드 설정";
                            }
                            else if (SystemLanguage == LanguageType.ENGLISH)
                            {
                                drmsg1 = "Can't set to channels of other module.";
                                drmsg2 = "Set Parallel Mode";
                            }

                            MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                            return;
                        }
                    }
                    #endregion

                    #region Parallel setting Check
                    // -----------------------------------------------------------------------
                    // 이미 설정한 병렬모드는 해제 먼저
                    // -----------------------------------------------------------------------
                    mrun = -1;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];

                        if (m_paramode[selch].use)
                        {
                            mrun = selch;
                            break;
                        }
                    }

                    if (mrun >= 0)
                    {
                        WriteSystemLog(">> Parallel Setting Error : Ch" + (mrun + 1).ToString() + " is already set");

                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            drmsg1 = "병렬모드로 설정된 채널이 있습니다. 병렬모드 해제 후 다시 시도해 주십시오.";
                            drmsg2 = "병렬모드 설정";
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            drmsg1 = "Can't set to parallel mode channel.";
                            drmsg2 = "Set Parallel Mode";
                        }

                        MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                        return;
                    }
                    #endregion

                    // ------------------------------------------------------------------
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "병렬모드 설정";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Set Parallel Mode";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        //+ Revision by YMJ - 250819 : 자동병렬 기능 관련 항목 추가
                        bool parallelChk = false;
                        if (m_bParallel_Auto)
                        {
                            parallelChk = m_ucParallel_List[0].AutoParallelRelay(true);
                            if (parallelChk)
                            {
                                WriteSystemLog(" >> AutoParallel = True // Relay On : Succress");
                            }
                        }
                        else
                        {
                            parallelChk = true;
                        }

                        if(parallelChk)
                        {
                            boardid = Board_Ch_Mapping[littlech];
                            bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(littlech);
                            int master_bzch = bzch;

                            for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                            {
                                selch = m_SelCh4Schedule[i];
                                boardid = Board_Ch_Mapping[selch];
                                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);

                                if (selch == littlech)
                                {
                                    // master
                                    m_paramode[selch].use = true;
                                    m_paramode[selch].ismaster = true;
                                    m_paramode[selch].master_ch = littlech;
                                }
                                else
                                {
                                    // slave
                                    m_paramode[selch].use = true;
                                    m_paramode[selch].ismaster = false;
                                    m_paramode[selch].master_ch = littlech;
                                }

                                m_ucCycler_ABT_List[boardid].MakeSetParallelModeABT(master_bzch + 1, bzch + 1, true);
                            }

                            PushParallelInfo();
                        }
                        else
                        {
                            WriteSystemLog(" >> AutoParallel = True // Relay On : Fail");
                        }
                        //-
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;

                case CH_Status_Popup_Ret.ClearParallelMode:
                    mstr = " >> Clear Parallel Mode[Popup] ";

                    #region Running Check
                    // -----------------------------------------------------------------------
                    // 여러 채널 선택했을때, 공정중인 채널 없어야 함
                    // -----------------------------------------------------------------------
                    mrun = -1;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {
                        selch = m_SelCh4Schedule[i];
                        mstr += ("//Ch" + (selch + 1).ToString());
                        if (IsOnTesting[selch]) { mrun = selch; }
                    }

                    WriteSystemLog(mstr);
                    if (mrun >= 0)
                    {
                        WriteSystemLog(">> Parallel Clearing Error : Ch" + (mrun + 1).ToString() + " is running");

                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            drmsg1 = "검사중인 채널이 있습니다. 확인 후 다시 시도해 주십시오.";
                            drmsg2 = "병렬모드 해제";
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            drmsg1 = "Can't set to running channel.";
                            drmsg2 = "Set Parallel Mode";
                        }

                        MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                        return;
                    }
                    #endregion

                    #region Parallel setting Check
                    // -----------------------------------------------------------------------
                    // 이미 설정한 병렬모드는 해제 먼저
                    // -----------------------------------------------------------------------
                    mrun = -1;
                    for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                    {

                        selch = m_SelCh4Schedule[i];

                        if ((!m_paramode[selch].use))
                        {
                            mrun = selch;
                            break;
                        }
                    }

                    if (mrun >= 0)
                    {
                        WriteSystemLog(">> Parallel Clearing Error : Ch" + (mrun + 1).ToString() + " is already cleared");

                        //+ Revision by YMJ - 250819 : 병렬 해제 시 필터 문구 변경
                        if (SystemLanguage == LanguageType.KOREAN)
                        {
                            drmsg1 = "이미 해제된 채널입니다.";
                            drmsg2 = "병렬모드 해제";
                        }
                        else if (SystemLanguage == LanguageType.ENGLISH)
                        {
                            drmsg1 = "Already Cleared.";
                            drmsg2 = "Set Parallel Mode";
                        }
                        //-
                        MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                        return;
                    }
                    #endregion

                    // ------------------------------------------------------------------
                    if (SystemLanguage == LanguageType.KOREAN)
                    {
                        drmsg1 = "선택하신 작업을 진행하시겠습니까?";
                        drmsg2 = "병렬모드 해제";
                    }
                    else if (SystemLanguage == LanguageType.ENGLISH)
                    {
                        drmsg1 = "Do you want to proceed selected job?";
                        drmsg2 = "Set Parallel Mode";
                    }
                    dr = MessageBox.Show(new Form { TopMost = true }, drmsg1, drmsg2, MessageBoxButtons.YesNo);
                    if (dr == DialogResult.Yes)
                    {
                        //+ Revision by YMJ - 250819 : 자동병렬 기능 관련 항목 추가
                        bool parallelChk = false;
                        if (m_bParallel_Auto)
                        {
                            parallelChk = m_ucParallel_List[0].AutoParallelRelay(false);
                            if (parallelChk)
                            {
                                WriteSystemLog(" >> AutoParallel = True // Relay OFF : Success");
                            }
                        }
                        else
                        {
                            parallelChk = true;
                        }

                        if(parallelChk)
                        {
                            boardid = Board_Ch_Mapping[littlech];
                            bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(littlech);
                            int master_bzch = 0; // bzch + 1;

                            for (int i = 0; i < m_SelCh4Schedule.Length; i++)
                            {
                                selch = m_SelCh4Schedule[i];
                                boardid = Board_Ch_Mapping[selch];
                                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);

                                if (m_paramode[selch].use)
                                {
                                    master_bzch = m_paramode[selch].master_ch;
                                    int master2_bzch = 0;

                                    for (int m = 0; m < m_paramode.Length; m++)
                                    {
                                        if (m_paramode[m].use && m_paramode[m].master_ch == master_bzch)
                                        {
                                            boardid = Board_Ch_Mapping[m];
                                            bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m);
                                            master2_bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(master_bzch);

                                            m_paramode[m].use = false;
                                            m_paramode[m].ismaster = false;
                                            m_paramode[m].master_ch = 0;

                                            m_ucCycler_ABT_List[boardid].MakeSetParallelModeABT(master2_bzch + 1, bzch + 1, false);
                                        }
                                    }
                                }
                            }

                            PushParallelInfo();
                        }
                        else
                        {
                            WriteSystemLog(" >> AutoParallel = True // Relay OFF : Fail");
                        }
                        //-
                    }
                    else
                    {
                        WriteSystemLog(">> 'NO' selected");
                    }
                    break;
                    //-

                default:
                    // None
                    break;

            }
        }

        //+ Add by YMJ - 250218 : 병렬 출력 모드 관련 이관 (TP코드 -> Main코드), 병렬모드 설정 사항 저장하거나 가져오기
        public void PushParallelInfo()
        {
            if (m_paramode == null) return;
            if (m_paramode.Length < 1) return;

            string value = "";
            cls_IniUtil inifile = new cls_IniUtil(Application.StartupPath + "\\ABTProParaSetting.ini");
            for (int i = 0; i < m_paramode.Length; i++)
            {
                value = (m_paramode[i].use) ? "TRUE" : "FALSE";
                inifile.SetIniValue("PARALLEL_#" + (i + 1).ToString(), "ENABLE", value);

                value = (m_paramode[i].ismaster) ? "TRUE" : "FALSE";
                inifile.SetIniValue("PARALLEL_#" + (i + 1).ToString(), "IS_MASTER_CH", value);

                value = m_paramode[i].master_ch.ToString();
                inifile.SetIniValue("PARALLEL_#" + (i + 1).ToString(), "MASTER_CH_NO", value);
            }
        }

        public void PopParallelInfo()
        {
            if (m_paramode == null) return;
            if (m_paramode.Length < 1) return;

            string value = "";
            cls_IniUtil inifile = new cls_IniUtil(Application.StartupPath + "\\ABTProParaSetting.ini");
            for (int i = 0; i < m_paramode.Length; i++)
            {
                value = inifile.GetIniValue("PARALLEL_#" + (i + 1).ToString(), "ENABLE", "FALSE");
                if (value.ToUpper() == "TRUE")
                {
                    m_paramode[i].use = true;
                }
                else
                {
                    m_paramode[i].use = false;
                    m_paramode[i].ismaster = false;
                    m_paramode[i].master_ch = 0;
                }

                if (m_paramode[i].use)
                {
                    value = inifile.GetIniValue("PARALLEL_#" + (i + 1).ToString(), "IS_MASTER_CH", "FALSE");
                    if (value.ToUpper() == "TRUE")
                    {
                        m_paramode[i].ismaster = true;
                    }
                    else
                    {
                        m_paramode[i].ismaster = false;
                    }

                    value = inifile.GetIniValue("PARALLEL_#" + (i + 1).ToString(), "MASTER_CH_NO", "0");
                    int mach = 0;
                    int.TryParse(value, out mach);
                    m_paramode[i].master_ch = mach;
                }
            }
        }
        //-

        private void 도구ToolStripMenuItem_Click(object sender, EventArgs e)
        {

        }

        // AUX Old Code
        // ------------------------------------------
        // AUX
        // ------------------------------------------
        //private void ReadPacketAUXM7019(int index, int mModuleId, string strRead)
        //{
        //    char[] splits = new char[] { '+', '-' };

        //    if (strRead == null) return;
        //    if (!m_AUXEnable) return;


        //    strRead = strRead.Replace("\r", "");

        //    var readlist = strRead.Split(splits);
        //    if (readlist == null) return;
        //    if (readlist.Length < 2) return;

        //    if (readlist[0].Trim() != ">") return;

        //    // ----------------------------------------------
        //    // index 1 부터 readlist.Length - 1 까지가 갯수임.
        //    // ----------------------------------------------
        //    int aux_count = readlist.Length - 1;

        //    if (mModuleId < 1 || mModuleId > 255) mModuleId = 1;
        //    if (m_unitpermodule[index] < 1 || m_unitpermodule[index] > 255) m_unitpermodule[index] = 8;

        //    int basem = (mModuleId - 1) * m_unitpermodule[index];
        //    double auxval = 0;
        //    int m_idxaux = 0;

        //    try
        //    {
        //        int ibase = 0;
        //        for (int i = 0; i < aux_count; i++)
        //        {
        //            double.TryParse(readlist[i + 1], out auxval);

        //            if (aux_count >= m_voltcount_aux[index])
        //            {
        //                ibase = 0;

        //                // if (m_idxaux < m_AUX_Temp.GetLength(1))
        //                if (m_idxaux < m_tempcount_aux[index])
        //                {
        //                    m_AUX_Temp[index, ibase] = auxval;
        //                    ibase++;
        //                }
        //            }
        //            else
        //            {
        //                m_idxaux = basem + i;

        //                // if (m_idxaux < m_AUX_Volt.GetLength(1))
        //                if (m_idxaux < m_voltcount_aux[index])
        //                {
        //                    m_AUX_Volt[index, m_idxaux] = auxval;
        //                }
        //            }

                    
        //        }
        //    }
        //    catch { }

        //}
        private void ReadPacketAUX(int m_chidx, int mModuleId, int mVCount, int mVStart, int mTCount, int mTStart, string strRead)
        {
            string vstr = "";
            char[] splits = new char[] { '+', '-' };
            //Debug.WriteLine(m_chidx.ToString() + " :2: " + mModuleId.ToString());

            if (strRead == null) return;
            if (!m_AUXEnable) return;


            strRead = strRead.Replace("\r", "");

            var readlist = strRead.Split(splits);
            if (readlist == null) return;
            if (readlist.Length < 2) return;

            if (readlist[0].Trim() != ">") return;

            // ----------------------------------------------------
            // index 1 부터 readlist.Length - 1 까지가 갯수임.
            // ----------------------------------------------------
            int mUnitPerModule = mVCount + mTCount;
            int aux_count = readlist.Length - 1;

            if (mModuleId < 1 || mModuleId > 255) mModuleId = 1;
            if (mUnitPerModule < 1 || mUnitPerModule > 255) mUnitPerModule = 8;

            int basem = (mModuleId - 1) * mUnitPerModule;
            double auxval = 0;
            
            try
            {
                int vcount = mVCount;
                int tcount = mTCount;
                int vbase = mVStart;
                int tbase = mTStart;

                //+ Revision by YMJ - 240530 : 채널정보 UI 온도 출력 설정값이 AUX일 경우 처리
                double tempSum = 0;

                for (int i = 0; i < aux_count; i++)
                {
                    double.TryParse(readlist[i + 1], out auxval);

                    if (vcount > 0)
                    {
                        if (vbase < m_voltcount_aux[m_chidx])
                        {
                            // ------------------
                            // 소숫점 3자리로 맞춤
                            // 231005, BGH
                            // ------------------
                            vstr = auxval.ToString("F3");
                            double.TryParse(vstr, out auxval);

                            m_AUX_Volt[m_chidx, vbase++] = auxval;
                            vcount--;
                        }
                        else
                        {
                            vcount = 0;
                        }
                    }
                    else if (tcount > 0)
                    {
                        if (tbase < m_tempcount_aux[m_chidx])
                        {
                            m_AUX_Temp[m_chidx, tbase++] = auxval;
                            tempSum += auxval;
                            tcount--;
                        }
                    }
                }

                double tempAvg = tempSum / mTCount;

                if (m_temp_Collect_dev.Equals("AUX"))
                {
                    int boardid = Board_Ch_Mapping[m_chidx];
                    int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(m_chidx);

                    m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].Current_T = tempAvg;
                }
                //-
            }
            catch { }
        }

        // ------------------------------------------
        // Chamber control
        // force to Vent
        // ------------------------------------------
        private void ReadPacketAUXI7055(string strRead)
        {
            char[] splits = new char[] { '+', '-' };
            string strheader = "";
            string strbody = "";

            if (strRead == null) return;
            if (!m_ucChamberDIO.EnableFlag) return;

            strRead = strRead.Replace("\r", "");
            strRead = strRead.Trim();
            strheader = strRead.Substring(0, 1);

            if (strRead.Length < 2) return;

            strbody = strRead.Substring(1);
            int value = 0;
            int.TryParse(strbody, out value);

            if (m_ucChamberDIO.ReceivedAlarmCode != value)  //(lastcounter < curcounter)
            {
                m_ucChamberDIO.ReceivedAlarmCode = value;
                if (value != 0) 
                {
                    int chidx = 0;
                    for (int i = 0; i < m_ucCycler_ABT_List.Count(); i++)
                    {
                        for (int m = 0; m < m_ucCycler_ABT_List[i].m_ChStatusList.Count(); m++)
                        {
                            chidx = m_ucCycler_ABT_List[i].ChannelStartIndex + m;
                            if (IsOnTesting[chidx])
                            {
                                m_ucCycler_ABT_List[i].m_ChStatusList[m].AlarmCode |= (int)TypeOfSafetyViolation.ChamberAlarm;
                                CheckSafetyCondition(chidx);
                            }
                                
                        }
                    }

                    bt_BuzzerStop.BackgroundImage = Properties.Resources.Vent1;
                    m_ucChamberDIO.VentStatus = true;
                }
                else
                {
                    bt_BuzzerStop.BackgroundImage = Properties.Resources.Vent_Close; ;
                }
            }
            
        }

        private Size GetActualPixelSize(TableLayoutPanel panel, int col, int row)
        {
            if (panel.ColumnCount <= col || col < 0 || panel.RowCount <= row || row < 0) return Size.Empty;
            int w = panel.Width, h = panel.Height;
            int nw, nh;

            // 고정 픽셀이면 width를 바로 알수 있다.
            if (panel.ColumnStyles[col].SizeType == SizeType.Absolute)
            {
                nw = (int)panel.ColumnStyles[col].Width;
            }
            // 다른 요소들을 검사후 값을 알아낼 수 있다.
            else
            {
                int another = 0;
                for (int i = 0; i < panel.ColumnCount; ++i)
                {
                    if (panel.ColumnStyles[i].SizeType == SizeType.Absolute)
                        another += (int)panel.ColumnStyles[i].Width;
                }
                nw = (int)((w - another) * (panel.ColumnStyles[col].Width / 100f));
            }

            // 고정 픽셀이면 height를 바로 알수있다.
            if (panel.RowStyles[row].SizeType == SizeType.Absolute)
            {
                nh = (int)panel.RowStyles[row].Height;
            }
            // 다른 요소들을 검사후 값을 알아낼 수 있다.
            else
            {
                int another = 0;

                for (int i = 0; i < panel.RowCount; ++i)
                {
                    if (panel.RowStyles[i].SizeType == SizeType.Absolute)
                        another += (int)panel.RowStyles[i].Height;
                }
                nh = (int)((h - another) * (panel.RowStyles[row].Height / 100f));
            }
            return new Size(nw, nh);
        }

        private void tlp_CH_Info_Data_Resize(object sender, EventArgs e)
        {
            Size mysize = GetActualPixelSize(tlp_CH_Info_Data, 1, 1);
            lb_V_CH_Volt.Size = mysize; // GetActualPixelSize(tlp_CH_Info_Data, 2, 1);
            lb_V_CH_Curr.Size = mysize;
            lb_V_CH_Capa.Size = mysize;
            lb_V_CH_C_Capa.Size = mysize;
            lb_V_CH_D_Capa.Size = mysize;
            lb_V_CH_Energy.Size = mysize;
            lb_V_CH_C_Energy.Size = mysize;
            lb_V_CH_D_Energy.Size = mysize;
            lb_V_CH_Power.Size = mysize;

            mysize = GetActualPixelSize(tlp_CH_Info_Data, 3, 1);
            lb_V_CH_Temperature.Size = mysize;
            lb_V_CH_Freq.Size = mysize;
            lb_V_CH_RE.Size = mysize;
            lb_V_CH_IM.Size = mysize;
            lb_V_CH_RS.Size = mysize;
            lb_V_CH_RCT.Size = mysize;
        }

        private void tlp_CH_Info_Work_Resize(object sender, EventArgs e)
        {
            Size mysize = GetActualPixelSize(tlp_CH_Info_Work, 1, 1);
            lb_V_CH_Type.Size = mysize; // GetActualPixelSize(tlp_CH_Info_Work, 2, 1);
            lb_V_CH_Code.Size = mysize;
            lb_V_CH_S_Time.Size = mysize;
            lb_V_CH_T_Time.Size = mysize;
            lb_V_CH_C_Cycle.Size = mysize;
            lb_V_CH_T_Cycle.Size = mysize;
            lb_V_CH_C_Step.Size = mysize;
            lb_V_CH_T_Step.Size = mysize;
        }



        // ----------------------------------------------------------------------
        // Menu바를 컨트롤 키를 누른 상태에서 더블클릭 하면 나타나는 히든 메뉴
        // ----------------------------------------------------------------------
        //private void mn_Main_DoubleClick(object sender, EventArgs e)
        //{
        //    if (((Control.ModifierKeys & Keys.Control) == Keys.Control))
        //    {
        //        PseudoDataMaker psfrm = new PseudoDataMaker(m_iCur_CH_NO, this);
        //        psfrm.Show();
        //        psfrm.Focus();
        //    }
        //}

        public void SetChamberPV(int ch, double pv_value)
        {
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2
            try
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chamber_PV = pv_value;
            }
            catch { }
        }
        public void SetChillerPV(int ch, double pv_value)
        {
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2
            try
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chiller_PV = pv_value;
            }
            catch { }
        }
        public void SetChillerLPMPV(int ch, double pv_value)
        {
            int boardid = Board_Ch_Mapping[ch];  // ghbaik
            int bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(ch);  // ghbaik2
            try
            {
                m_ucCycler_ABT_List[boardid].m_ChStatusList[bzch].m_step.Chiller_PV_Flow = pv_value;
            }
            catch { }
        }

        // -메인에서 버튼 없앰.
        //private void button3_Click(object sender, EventArgs e)
        //{
        //    List<Alarm_Info> n_Info_List = new List<Alarm_Info>();

        //    for (int i = 0; i < 10; i++)
        //    {
        //        Alarm_Info n_Alarm_Info = new Alarm_Info();
        //        n_Alarm_Info.Reset();

        //        n_Alarm_Info.CH_NO = i + 1;
        //        n_Alarm_Info.Alarm_Time = DateTime.Now;
        //        n_Alarm_Info.Alarm_Code = TypeOfSafetyViolation.OverVolt;
        //        n_Alarm_Info.Alarm_Desc = i.ToString() + " 번째 입니다.";

        //        n_Info_List.Add(n_Alarm_Info);
        //    }

        //    frmAlarm_Msg n_frmAlarm_Msg = new frmAlarm_Msg(this, n_Info_List);

        //    n_frmAlarm_Msg.Show();
        //}

        //+ Add by LBG - 230609 : 알람이 발생한 내용에 대한 처리 Flag 셋팅
        public void Set_Alarm_Treat(Alarm_Info n_Info_Treat)
        {
            if (m_AlarmPopupList != null && m_AlarmPopupList.Count > 0)
            {
                int boardid = 0;
                int bzch = 0;
                // bool isMBTAlarm = false;
                for (int i = 0; i < m_AlarmPopupList.Count; i++)
                {
                    if (m_AlarmPopupList[i].CH_NO == n_Info_Treat.CH_NO
                        && m_AlarmPopupList[i].Alarm_Time.Equals(n_Info_Treat.Alarm_Time)
                        && m_AlarmPopupList[i].Alarm_Code == n_Info_Treat.Alarm_Code)
                    {
                        m_AlarmPopupList[i] = n_Info_Treat;

                        // +230912
                        // 알람 플랙 클리어
                        if (n_Info_Treat.Alarm_Treat != Alarm_Treat_Type.Work_None)
                        {                            
                            int selch = m_AlarmPopupList[i].CH_NO - 1;

                            // --------------------------------
                            // 231025
                            // BGH
                            try
                            {
                                boardid = Board_Ch_Mapping[selch];
                                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);

                                // --------------------------------------------
                                // 231126 Standby를 날릴 필요 없음, BGH
                                // --------------------------------------------
                                // m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.STANDBY, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                                m_ucCycler_ABT_List[boardid].MakeABTClearAlarmPacket(bzch + 1);
                                m_ucCycler_ABT_List[boardid].MakeABTClearNOCurrent(bzch);  // 231029

                                //+ Revision by YMJ - 250902 : 부산TP 챔버 및 칠러 기능 이전
                                if (m_ucChamber.isConnected)
                                {
                                    if (m_ucChamber.DoesWorking)
                                    {
                                        m_ucChamber.RemoveCh(selch);
                                        if (m_ucChamber.GetCount() == 0)
                                        {
                                            m_ucChamber.StopAction();
                                            Thread.Sleep(100);
                                            // m_ucChamber.StopSerial();
                                            m_ucChamber.DoesWorking = false;
                                            m_ucChamber.SP = 0; // -100; // -100.0f;
                                            m_ucChamber.HUMIDITY_S = 0;
                                            // -------------------------
                                            // 230917, BGH
                                            ResetChamberMaintainSetting();
                                        }
                                    }
                                }
                                //-
                            }
                            catch (Exception ex)
                            {
                                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                                Write_Log("MainFrame.Set_Alarm_Treat()", n_sDebugMsg);
                            }

                            Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(selch);
                            m_dispChStatus.ch_s_Exist_Alarm = false;
                            m_ucChannel_Status.Set_Disp_CH_Status(selch, m_dispChStatus);

                            //+ Revision by YMJ - 250618 : steptype 중복 체크 부분 삭제
                            //-

                            // 240122 BGH
                            if (n_Info_Treat.Alarm_Code == TypeOfSafetyViolation.MBT_Err || n_Info_Treat.Alarm_Code == TypeOfSafetyViolation.MBT_COMMErr)
                            {
                                // isMBTAlarm = true;
                                ConnectionTestMBT(selch);
                            }
                        }
                        break;
                    }
                }
            }
        }
        //-

        //+ Add BGH - 230614
        public void Clear_Alarm_Treat(List<int> m_alarmchlist)
        {
            int boardid = 0; // Board_Ch_Mapping[CH_NO];  // ghbaik
            int bzch = 0; // m_ucCycler_ABT_List[boardid].GetChInBoard(CH_NO);  // ghbaik2
            int selch = 0;
            for (int i = 0; i < m_alarmchlist.Count(); i++)
            {
                selch = m_alarmchlist[i];
                boardid = Board_Ch_Mapping[selch];  // ghbaik
                bzch = m_ucCycler_ABT_List[boardid].GetChInBoard(selch);  // ghbaik2

                // 231025, 231112 BGH
                // RemoveAlarm(selch);
                if (RemoveAlarmCheckMBT(selch))
                {
                    ConnectionTestMBT(selch);
                }

                //m_ucCycler_ABT_List[boardid].MakeWritePacketOnlyABT(cls_devCyclerABT.ABTPACKETYPE.STANDBY, bzch + 1, 0, 0, false, cls_devCyclerABT.CheckCutOffFlag.DONOT_Check);
                // 231117 BGH
                if (m_ucCycler_ABT_List[boardid].m_ChStatusList != null && m_ucCycler_ABT_List[boardid].m_ChStatusList.Count() > bzch)
                {
                    // --------------------------------------------
                    // 231126 Standby를 날릴 필요 없음, BGH
                    // --------------------------------------------
                    // m_ucCycler_ABT_List[boardid].Write_Standby_PacketABT(bzch, false);
                    m_ucCycler_ABT_List[boardid].MakeABTClearAlarmPacket(bzch + 1);
                    m_ucCycler_ABT_List[boardid].MakeABTClearNOCurrent(bzch);  // 231029
                }


                // + 230912
                Display_Channel_Status m_dispChStatus = m_ucChannel_Status.Get_Disp_CH_Status(selch);
                m_dispChStatus.ch_s_Exist_Alarm = false;
                m_ucChannel_Status.Set_Disp_CH_Status(selch, m_dispChStatus);
            }
        }


        public static byte[] ToByteArray(String HexString)
        {
            int NumberChars = HexString.Length;
            byte[] bytes = new byte[NumberChars / 2];
            for (int i = 0; i < NumberChars; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(HexString.Substring(i, 2), 16);
            }
            return bytes;
        }

        //+ Add by YMJ - 250716 : CAN TX 데이터 변환 및 전송 추가
        public void startCANTXSend(int n_ch, List<CAN_TX_Info> n_CAN_TX_List)
        {
            int[] n_CAN_TX_Cnt = new int[n_CAN_TX_List.Count];
            for(int i=0;i<n_CAN_TX_List.Count;i++)
            {
                n_CAN_TX_Cnt[i] = 0;
            }
            while (m_CANTXSend[n_ch])
            {
                try
                {
                    for (int i = 0; i < n_CAN_TX_List.Count; i++)
                    {
                        n_CAN_TX_Cnt[i]++;
                        int n_Interval = n_CAN_TX_List[i].Rate / 100;
                        if(n_CAN_TX_Cnt[i] == n_Interval)
                        {
                            if (m_ucCAN_List[n_ch].IS_FD_CAN)
                            {
                                m_ucCAN_List[n_ch].WriteFD((uint)n_CAN_TX_List[i].Addr, (byte)n_CAN_TX_List[i].DLC, CANTransferTX(m_ucCAN_List[n_ch].IS_FD_CAN, n_CAN_TX_List[i]));
                            }
                            else
                            {
                                m_ucCAN_List[n_ch].Write((ushort)n_CAN_TX_List[i].Addr, CANTransferTX(m_ucCAN_List[n_ch].IS_FD_CAN, n_CAN_TX_List[i]));
                            }
                            n_CAN_TX_Cnt[i] = 0;
                        }
                    }
                }
                catch (Exception ex)
                {
                    string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                    Write_Log("startCANTXSend", n_sDebugMsg);
                }
                Thread.Sleep(100);
            }
        }

        public byte[] CANTransferTX(bool n_IS_FD_CAN, CAN_TX_Info n_CAN_TX_Info)
        {
            byte[] n_Data;
            if (n_IS_FD_CAN)
            {
                n_Data = new byte[n_CAN_TX_Info.DLC];
            }
            else
            {
                n_Data = new byte[8];
            }

            try
            {
                double n_PhysicalValue = (n_CAN_TX_Info.Value - n_CAN_TX_Info.Offset) / n_CAN_TX_Info.Factor;

                ulong n_RawValue = (ulong)n_PhysicalValue;

                ulong mask = (1UL << n_CAN_TX_Info.Size) - 1;
                n_RawValue &= mask;

                if (n_CAN_TX_Info.ByteOrder == "L")
                {
                    int n_BitPos = n_CAN_TX_Info.SBit;
                    for (int i = 0; i < n_CAN_TX_Info.Size; i++)
                    {
                        int byteIndex = (n_BitPos + i) / 8;
                        int bitIndex = (n_BitPos + i) % 8;

                        if (((n_RawValue >> i) & 1) == 1)
                        {
                            n_Data[byteIndex] |= (byte)(1 << bitIndex);
                        }
                    }
                }
                else
                {
                    int n_BitPos = n_CAN_TX_Info.SBit;
                    for (int i = 0; i < n_CAN_TX_Info.Size; i++)
                    {
                        int bitIndex = (n_BitPos - i);
                        int byteIndex = bitIndex / 8;
                        int innerBit = 7 - (bitIndex % 8);

                        if (((n_RawValue >> i) & 1) == 1)
                        {
                            n_Data[byteIndex] |= (byte)(1 << innerBit);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                string n_sDebugMsg = string.Format("Trace:{0}, Message:{1}", ex.StackTrace, ex.Message);
                Write_Log("CANTransferTX", n_sDebugMsg);
            }
            return n_Data;
        }
        //-

        private void button1_Click(object sender, EventArgs e)
        {
            //string spath = Application.StartupPath + "\\Schedule\\IONIQ5_PACK\\Discharge.xml";
            //cls_stepInfo cstinfo = new cls_stepInfo(this);
            //cstinfo.BuildStepCondition(spath);

            //GetTempNTC(0, 1.511);

            //m_ucChamber.SP = 25;
            //m_ucChamber.SendWriteSPValue();
            //Thread.Sleep(100);
            //m_ucChamber.StartAction();

            //byte[] rxstr = new byte[] { 0x01, 0x4b };
            //double ch1_pv = (double)(((int)rxstr[0]) * 256 + (int)rxstr[1]) / 10.0;

            // ------------------------------------------------
            //m_ucCAN_List[0].CAN_List.Clear();
            //for (int i = 1; i < 9; i++)
            //{
            //    cls_devCAN.MDBC_PARSE mdbc = new cls_devCAN.MDBC_PARSE();
            //    try
            //    {
            //        mdbc.Name = "VOLT_" + (i + 1).ToString();
            //        mdbc.Addr = (uint)(0x100 + i);
            //        mdbc.Offset = 0;
            //        mdbc.Size = 16;
            //        mdbc.Factor = 0.0001;

            //        mdbc.Value = 0;

            //        mdbc.CutOff_L = 0;
            //        mdbc.CutOff_H = 0;
            //        mdbc.Safety_L = 0;
            //        mdbc.Safety_H = 0;
            //    }
            //    catch { }
            //    m_ucCAN_List[0].Add_DBCList(mdbc);
            //}

            // ---------------------------------------------------
            //double matchup = -5.85899353182706;
            //double rcvCurrent = -5.19700002670288;

            //double matchup_p = 15;
            //int m_1value = 112;
            //Random erand = new Random();
            //for (int i = 0; i < 100; i++)
            //{
            //    matchup_p = (i + 1) * 5;
            //    m_1value = erand.Next(0, 777) + 1;

            //    double pc = 0.9995 + (m_1value % 5) * 0.00023;
            //    double m_2value = matchup_p * pc; // 0.9995;
            //    m_2value += ((m_1value % 5) * 0.001);

            //    double perc = (m_2value / matchup_p) * 100;

            //    double gap1 = matchup_p - m_2value;
            //    double gap2 = matchup_p * 0.1 * 0.01;
            //    double fgap = gap2 - gap1;

            //    System.Diagnostics.Debug.WriteLine("matchup_p=" + matchup_p.ToString("F3") + " // adjust=" + m_2value.ToString("F3") + " // ration=" + perc.ToString("F5") + " // diff=" + (100.0 - perc).ToString("F3"));
            //}

            //double m_1value = (rcvCurrent - (double)((int)(rcvCurrent * 100)) / 100);
            //if (Math.Abs(m_1value) < 0.001)
            //{
            //    m_1value = 0.002;
            //}
            //if (Math.Abs(m_1value) < 0.005) rcvCurrent = matchup + (m_1value / 2);
            //else rcvCurrent = matchup - (m_1value / 2);
            //double powr = (rcvCurrent * 15.3610000610352); 

            // --------------------------------------------------------
            //cls_udds mytest = new cls_udds(0, this);
            //mytest.SetPatternPath(Application.StartupPath + "\\Pattern\\CC_100ms.csv");

            //+ Add By LBG - 230916 : Chamber 통신 Test를 위하여 코드 추가
            //if (!m_ucChamber.isConnected)
            //{
            //    m_ucChamber.StartSerial();

            //    m_ucChamber.Start_ThreadTimer();
            //}
            //-

            bt_CH_Work_Start_Click(null, null);
        }

    }
}
